{
  "source_file": "source/slang/slang-diagnostic-defs.h",
  "diagnostics": [
    {
      "id": 1,
      "severity": "Error",
      "name": "cannotOpenFile",
      "message": "cannot open file '$0'.",
      "line": 91,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1705,
          "statement": "sink->diagnose(requestingLoc, Diagnostics::cannotOpenFile, defaultSourceFileName);",
          "context_before": [
            "    // of the candidate file names from the loop above",
            "    // got furthest along in the process (or just a",
            "    // list of the file names that were tried, if",
            "    // nothing was even found via the include system).",
            "    //"
          ],
          "context_after": [
            "",
            "    // If the attempt to import the module failed, then",
            "    // we will stick a null pointer into the map of loaded",
            "    // modules, so that subsequent attempts to load a module",
            "    // with this name will return null without having to"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1841,
          "statement": "sink->diagnose(loc, Diagnostics::cannotOpenFile, getText(name));",
          "context_before": [
            "",
            "    IncludeSystem includeSystem;",
            "    auto sourceFile = findFile(name, loc, includeSystem);",
            "    if (!sourceFile)",
            "    {"
          ],
          "context_after": [
            "        return result;",
            "    }",
            "",
            "    // If the file has already been included, don't need to do anything further.",
            "    if (auto existingFileDecl = module->getIncludedSourceFileMap().tryGetValue(sourceFile))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-compile-request.cpp",
          "line": 666,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::cannotOpenFile, path);",
          "context_before": [
            "    }",
            "",
            "    if (SLANG_FAILED(existsRes))",
            "    {",
            "        // Emit a diagnostic!"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    addTranslationUnitSourceArtifact(translationUnitIndex, sourceArtifact);",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3224,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::cannotOpenFile, fileName.value);",
          "context_before": [
            "                        fileName.value,",
            "                        FileMode::Open,",
            "                        FileAccess::Read,",
            "                        FileShare::None)))",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                List<uint8_t> buffer;",
            "                file.seek(SeekOrigin::End, 0);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3302,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::cannotOpenFile, fileName.value);",
          "context_before": [
            "                        fileName.value,",
            "                        FileMode::Open,",
            "                        FileAccess::Read,",
            "                        FileShare::None)))",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                List<uint8_t> buffer;",
            "                file.seek(SeekOrigin::End, 0);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-translation-unit.cpp",
          "line": 202,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::cannotOpenFile, pathInfo.getName());",
          "context_before": [
            "        {",
            "            const SlangResult res = artifact->loadBlob(ArtifactKeep::Yes, blob.writeRef());",
            "            if (SLANG_FAILED(res))",
            "            {",
            "                // Report couldn't load"
          ],
          "context_after": [
            "                return res;",
            "            }",
            "        }",
            "",
            "        // If we don't have a blob on the artifact we can now add the one we have"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 2,
      "severity": "Error",
      "name": "cannotFindFile",
      "message": "cannot find file '$0'.",
      "line": 92,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 2,
      "severity": "Error",
      "name": "unsupportedCompilerMode",
      "message": "unsupported compiler mode.",
      "line": 93,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 4,
      "severity": "Error",
      "name": "cannotWriteOutputFile",
      "message": "cannot write output file '$0'.",
      "line": 94,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-artifact-output-util.cpp",
          "line": 184,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::cannotWriteOutputFile, writerName);",
          "context_before": [
            "    SLANG_RETURN_ON_FAIL(_requireBlob(artifact, sink, blob));",
            "",
            "    const auto res = write(artifact->getDesc(), blob, writer);",
            "    if (SLANG_FAILED(res))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return res;",
            "}",
            "",
            "/* static */ SlangResult ArtifactOutputUtil::maybeConvertAndWrite("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-artifact-output-util.cpp",
          "line": 262,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::cannotWriteOutputFile, path);",
          "context_before": [
            "    SLANG_RETURN_ON_FAIL(_requireBlob(artifact, sink, blob));",
            "",
            "    const auto res = writeToFile(artifact, path);",
            "    if (SLANG_FAILED(res) && sink)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    return res;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 5,
      "severity": "Error",
      "name": "failedToLoadDynamicLibrary",
      "message": "failed to load dynamic library '$0'",
      "line": 95,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 6,
      "severity": "Error",
      "name": "tooManyOutputPathsSpecified",
      "message": "$0 output paths specified, but only $1 entry points given",
      "line": 96,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 7,
      "severity": "Error",
      "name": "noOutputPathSpecifiedForEntryPoint",
      "message": "no output path specified for entry point '$0' (the '-o' option for an entry point must precede the corresponding '-entry')",
      "line": 102,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 8,
      "severity": "Error",
      "name": "outputPathsImplyDifferentFormats",
      "message": "the output paths '$0' and '$1' require different code-generation targets",
      "line": 109,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 10,
      "severity": "Error",
      "name": "explicitOutputPathsAndMultipleTargets",
      "message": "canot use both explicit output paths ('-o') and multiple targets ('-target')",
      "line": 115,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 12,
      "severity": "Error",
      "name": "cannotDeduceSourceLanguage",
      "message": "can't deduce language for input file '$0'",
      "line": 120,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1515,
          "statement": "Diagnostics::cannotDeduceSourceLanguage, inPath);",
          "context_before": [
            "    }",
            "    if (sourceLanguage == SLANG_SOURCE_LANGUAGE_UNKNOWN)",
            "    {",
            "        m_requestImpl->getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            inPath);",
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    addInputForeignShaderPath(path, sourceLanguage, impliedStage);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 13,
      "severity": "Error",
      "name": "unknownCodeGenerationTarget",
      "message": "unknown code generation target '$0'",
      "line": 121,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2640,
          "statement": "Diagnostics::unknownCodeGenerationTarget, name.value);",
          "context_before": [
            "",
            "                if (format == CodeGenTarget::Unknown)",
            "                {",
            "                    m_sink->diagnose(",
            "                        name.loc,"
          ],
          "context_after": [
            "                        name.value);",
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                RawTarget rawTarget;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 14,
      "severity": "Error",
      "name": "unknownProfile",
      "message": "unknown profile '$0'",
      "line": 122,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2222,
          "statement": "m_sink->diagnose(operand.loc, Diagnostics::unknownProfile, profileName);",
          "context_before": [
            "    UnownedStringSlice profileName = sliceCount >= 1 ? slices[0] : UnownedTerminatedStringSlice(\"\");",
            "",
            "    SlangProfileID profileID = SlangProfileID(Slang::Profile::lookUp(profileName).raw);",
            "    if (profileID == SLANG_PROFILE_UNKNOWN)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "    else",
            "    {",
            "        auto profile = Profile(profileID);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2247,
          "statement": "m_sink->diagnose(operand.loc, Diagnostics::unknownProfile, atomName);",
          "context_before": [
            "    {",
            "        UnownedStringSlice atomName = slices[i];",
            "        CapabilityName atom = findCapabilityName(atomName);",
            "        if (atom == CapabilityName::Invalid)",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "",
            "        addCapabilityAtom(getCurrentTarget(), atom);",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2725,
          "statement": "m_sink->diagnose(operand.loc, Diagnostics::unknownProfile, atomName);",
          "context_before": [
            "                {",
            "                    UnownedStringSlice atomName = slices[i];",
            "                    CapabilityName atom = findCapabilityName(atomName);",
            "                    if (atom == CapabilityName::Invalid)",
            "                    {"
          ],
          "context_after": [
            "                        return SLANG_FAIL;",
            "                    }",
            "",
            "                    addCapabilityAtom(getCurrentTarget(), atom);",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15,
      "severity": "Error",
      "name": "unknownStage",
      "message": "unknown stage '$0'",
      "line": 123,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2759,
          "statement": "m_sink->diagnose(name.loc, Diagnostics::unknownStage, name.value);",
          "context_before": [
            "                SLANG_RETURN_ON_FAIL(m_reader.expectArg(name));",
            "",
            "                Stage stage = findStageByName(name.value);",
            "                if (stage == Stage::Unknown)",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "                else",
            "                {",
            "                    setStage(getCurrentEntryPoint(), stage);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 16,
      "severity": "Error",
      "name": "unknownPassThroughTarget",
      "message": "unknown pass-through target '$0'",
      "line": 124,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2861,
          "statement": "m_sink->diagnose(name.loc, Diagnostics::unknownPassThroughTarget, name.value);",
          "context_before": [
            "",
            "                SlangPassThrough passThrough = SLANG_PASS_THROUGH_NONE;",
            "                if (SLANG_FAILED(",
            "                        TypeTextUtil::findPassThrough(name.value.getUnownedSlice(), passThrough)))",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                m_compileRequest->setPassThrough(passThrough);",
            "                break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3111,
          "statement": "Diagnostics::unknownPassThroughTarget, compilerArg.value);",
          "context_before": [
            "                        compilerArg.value.getUnownedSlice(),",
            "                        compiler)))",
            "                {",
            "                    m_sink->diagnose(",
            "                        compilerArg.loc,"
          ],
          "context_after": [
            "                        compilerArg.value);",
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                if (SLANG_FAILED(m_session->setDefaultDownstreamCompiler(sourceLanguage, compiler)))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 17,
      "severity": "Error",
      "name": "unknownCommandLineOption",
      "message": "unknown command-line option '$0'",
      "line": 125,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2301,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::unknownCommandLineOption, argValue);",
          "context_before": [
            "",
            "        const Index optionIndex = m_cmdOptions->findOptionByName(argValue.getUnownedSlice());",
            "",
            "        if (optionIndex < 0)",
            "        {"
          ],
          "context_after": [
            "            _outputMinimalUsage();",
            "            return SLANG_FAIL;",
            "        }",
            "",
            "        const auto optionKind = OptionKind(m_cmdOptions->getOptionAt(optionIndex).userValue);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3401,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::unknownCommandLineOption, argValue);",
          "context_before": [
            "            }",
            "        default:",
            "            {",
            "                // Hmmm, we looked up and produced a valid enum, but it wasn't handled in the",
            "                // switch..."
          ],
          "context_after": [
            "",
            "                _outputMinimalUsage();",
            "                return SLANG_FAIL;",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 18,
      "severity": "Warning",
      "name": "separateDebugInfoUnsupportedForTarget",
      "message": "'-separate-debug-info' is not supported for target '$0'. This option is only supported for SPIR-V binary targets.",
      "line": 126,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4131,
          "statement": "Diagnostics::separateDebugInfoUnsupportedForTarget, targetName);",
          "context_before": [
            "                // Get the target name for the warning message",
            "                UnownedStringSlice targetName =",
            "                    TypeTextUtil::getCompileTargetName(asExternal(rawTarget.format));",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    targetName);",
            "            }",
            "        }",
            "",
            "        // Also check the default target if no explicit targets were specified"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4146,
          "statement": "Diagnostics::separateDebugInfoUnsupportedForTarget, targetName);",
          "context_before": [
            "                // Get the target name for the warning message",
            "                UnownedStringSlice targetName =",
            "                    TypeTextUtil::getCompileTargetName(asExternal(m_defaultTarget.format));",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    targetName);",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 19,
      "severity": "Error",
      "name": "unknownSourceLanguage",
      "message": "unknown source language '$0'",
      "line": 132,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2837,
          "statement": "m_sink->diagnose(name.loc, Diagnostics::unknownSourceLanguage, name.value);",
          "context_before": [
            "                const SourceLanguage sourceLanguage =",
            "                    (SourceLanguage)TypeTextUtil::findSourceLanguage(name.value.getUnownedSlice());",
            "",
            "                if (sourceLanguage == SourceLanguage::Unknown)",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "                else",
            "                {",
            "                    while (m_reader.hasArg() && !m_reader.peekValue().startsWith(\"-\"))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3099,
          "statement": "Diagnostics::unknownSourceLanguage, sourceLanguageArg.value);",
          "context_before": [
            "                    TypeTextUtil::findSourceLanguage(sourceLanguageArg.value.getUnownedSlice());",
            "                if (sourceLanguage == SLANG_SOURCE_LANGUAGE_UNKNOWN)",
            "                {",
            "                    m_sink->diagnose(",
            "                        sourceLanguageArg.loc,"
          ],
          "context_after": [
            "                        sourceLanguageArg.value);",
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                SlangPassThrough compiler;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20,
      "severity": "Error",
      "name": "entryPointsNeedToBeAssociatedWithTranslationUnits",
      "message": "when using multiple source files, entry points must be specified after their corresponding source file(s)",
      "line": 134,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3510,
          "statement": "Diagnostics::entryPointsNeedToBeAssociatedWithTranslationUnits);",
          "context_before": [
            "            }",
            "            if (anyEntryPointWithoutTranslationUnit)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                return SLANG_FAIL;",
            "            }",
            "        }",
            "",
            "        // Now that entry points are associated with translation units,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 22,
      "severity": "Error",
      "name": "unknownDownstreamCompiler",
      "message": "unknown downstream compiler '$0'",
      "line": 141,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3150,
          "statement": "Diagnostics::unknownDownstreamCompiler, passThroughSlice);",
          "context_before": [
            "                    }",
            "                    else",
            "                    {",
            "                        m_sink->diagnose(",
            "                            arg.loc,"
          ],
          "context_after": [
            "                            passThroughSlice);",
            "                        return SLANG_FAIL;",
            "                    }",
            "                }",
            "                break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 26,
      "severity": "Error",
      "name": "unknownOptimiziationLevel",
      "message": "unknown optimization level '$0'",
      "line": 143,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 28,
      "severity": "Error",
      "name": "unableToGenerateCodeForTarget",
      "message": "unable to generate code for target '$0'",
      "line": 145,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-llvm.cpp",
          "line": 786,
          "statement": "Diagnostics::unableToGenerateCodeForTarget, TypeTextUtil::getCompileTargetName( SlangCompileTarget(codeGenContext->getTargetFormat())));",
          "context_before": [
            "        ISlangSharedLibrary* library = codeGenContext->getSession()->getOrLoadSlangLLVM();",
            "        if (!library)",
            "        {",
            "            codeGenContext->getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                TypeTextUtil::getCompileTargetName(",
            "                    SlangCompileTarget(codeGenContext->getTargetFormat())));",
            "            return SLANG_FAIL;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 2190,
          "statement": "Diagnostics::unableToGenerateCodeForTarget, TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
          "context_before": [
            "",
            "    if (!sourceEmitter)",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    SLANG_RETURN_ON_FAIL(sourceEmitter->init());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 2874,
          "statement": "Diagnostics::unableToGenerateCodeForTarget, TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
          "context_before": [
            "    ISlangSharedLibrary* library = codeGenContext->getSession()->getOrLoadSlangLLVM();",
            "    if (!library)",
            "    {",
            "        codeGenContext->getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    LinkedIR linkedIR;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30,
      "severity": "Warning",
      "name": "sameStageSpecifiedMoreThanOnce",
      "message": "the stage '$0' was specified more than once for entry point '$1'",
      "line": 147,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3559,
          "statement": "Diagnostics::sameStageSpecifiedMoreThanOnce, rawEntryPoint.stage, rawEntryPoint.name);",
          "context_before": [
            "            }",
            "            else if (rawEntryPoint.redundantStageSet)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    rawEntryPoint.stage,",
            "                    rawEntryPoint.name);",
            "            }",
            "            else if (rawEntryPoint.translationUnitIndex != -1)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31,
      "severity": "Error",
      "name": "conflictingStagesForEntryPoint",
      "message": "conflicting stages have been specified for entry point '$0'",
      "line": 152,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3552,
          "statement": "Diagnostics::conflictingStagesForEntryPoint, rawEntryPoint.name);",
          "context_before": [
            "        {",
            "            if (rawEntryPoint.conflictingStagesSet)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    rawEntryPoint.name);",
            "            }",
            "            else if (rawEntryPoint.redundantStageSet)",
            "            {",
            "                m_sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 32,
      "severity": "Warning",
      "name": "explicitStageDoesntMatchImpliedStage",
      "message": "the stage specified for entry point '$0' ('$1') does not match the stage implied by the source file name ('$2')",
      "line": 157,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3577,
          "statement": "Diagnostics::explicitStageDoesntMatchImpliedStage, rawEntryPoint.name, rawEntryPoint.stage, rawTranslationUnit.impliedStage);",
          "context_before": [
            "                    rawEntryPoint.stage != Stage::Unknown &&",
            "                    rawTranslationUnit.impliedStage != rawEntryPoint.stage)",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                        rawEntryPoint.name,",
            "                        rawEntryPoint.stage,",
            "                        rawTranslationUnit.impliedStage);",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33,
      "severity": "Error",
      "name": "stageSpecificationIgnoredBecauseNoEntryPoints",
      "message": "one or more stages were specified, but no entry points were specified with '-entry'",
      "line": 163,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3469,
          "statement": "Diagnostics::stageSpecificationIgnoredBecauseNoEntryPoints);",
          "context_before": [
            "            {",
            "                if (m_rawEntryPoints.getCount() == 0)",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 34,
      "severity": "Error",
      "name": "stageSpecificationIgnoredBecauseBeforeAllEntryPoints",
      "message": "when compiling multiple entry points, any '-stage' options must follow the '-entry' option that they apply to",
      "line": 168,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3475,
          "statement": "Diagnostics::stageSpecificationIgnoredBecauseBeforeAllEntryPoints);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "",
            "        // Slang requires that every explicit entry point indicate the translation"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 35,
      "severity": "Error",
      "name": "noStageSpecifiedInPassThroughMode",
      "message": "no stage was specified for entry point '$0'; when using the '-pass-through' option, stages must be fully specified on the command line",
      "line": 174,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3598,
          "statement": "Diagnostics::noStageSpecifiedInPassThroughMode, rawEntryPoint.name);",
          "context_before": [
            "            {",
            "                if (rawEntryPoint.stage == Stage::Unknown)",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                        rawEntryPoint.name);",
            "                }",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36,
      "severity": "Error",
      "name": "expectingAnInteger",
      "message": "expecting an integer value",
      "line": 180,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1903,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::expectingAnInteger);",
          "context_before": [
            "    CommandLineArg arg;",
            "    SLANG_RETURN_ON_FAIL(m_reader.expectArg(arg));",
            "",
            "    if (SLANG_FAILED(StringUtil::parseInt(arg.value.getUnownedSlice(), outInt)))",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "    return SLANG_OK;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40,
      "severity": "Warning",
      "name": "sameProfileSpecifiedMoreThanOnce",
      "message": "the '$0' was specified more than once for target '$0'",
      "line": 182,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3810,
          "statement": "Diagnostics::sameProfileSpecifiedMoreThanOnce, rawTarget.optionSet.getProfileVersion(), rawTarget.format);",
          "context_before": [
            "            }",
            "            else if (rawTarget.redundantProfileSet)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    rawTarget.optionSet.getProfileVersion(),",
            "                    rawTarget.format);",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41,
      "severity": "Error",
      "name": "conflictingProfilesSpecifiedForTarget",
      "message": "conflicting profiles have been specified for target '$0'",
      "line": 187,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3803,
          "statement": "Diagnostics::conflictingProfilesSpecifiedForTarget, rawTarget.format);",
          "context_before": [
            "        {",
            "            if (rawTarget.conflictingProfilesSet)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    rawTarget.format);",
            "            }",
            "            else if (rawTarget.redundantProfileSet)",
            "            {",
            "                m_sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 42,
      "severity": "Error",
      "name": "profileSpecificationIgnoredBecauseNoTargets",
      "message": "a '-profile' option was specified, but no target was specified with '-target'",
      "line": 193,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3773,
          "statement": "Diagnostics::profileSpecificationIgnoredBecauseNoTargets);",
          "context_before": [
            "                    // so we didn't try to infer a target, or if the `-profile` option",
            "                    // somehow didn't imply a target.",
            "                    //",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 43,
      "severity": "Error",
      "name": "profileSpecificationIgnoredBecauseBeforeAllTargets",
      "message": "when using multiple targets, any '-profile' option must follow the '-target' it applies to",
      "line": 198,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3779,
          "statement": "Diagnostics::profileSpecificationIgnoredBecauseBeforeAllTargets);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                }",
            "            }",
            "",
            "            if (defaultTargetFloatingPointMode != FloatingPointMode::Default)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 42,
      "severity": "Error",
      "name": "targetFlagsIgnoredBecauseNoTargets",
      "message": "target options were specified, but no target was specified with '-target'",
      "line": 204,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3787,
          "statement": "m_sink->diagnose(SourceLoc(), Diagnostics::targetFlagsIgnoredBecauseNoTargets);",
          "context_before": [
            "",
            "            if (defaultTargetFloatingPointMode != FloatingPointMode::Default)",
            "            {",
            "                if (m_rawTargets.getCount() == 0)",
            "                {"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 43,
      "severity": "Error",
      "name": "targetFlagsIgnoredBecauseBeforeAllTargets",
      "message": "when using multiple targets, any target options must follow the '-target' they apply to",
      "line": 209,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3793,
          "statement": "Diagnostics::targetFlagsIgnoredBecauseBeforeAllTargets);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "        for (auto& rawTarget : m_rawTargets)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50,
      "severity": "Error",
      "name": "duplicateTargets",
      "message": "the target '$0' has been specified more than once",
      "line": 215,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3683,
          "statement": "m_sink->diagnose(SourceLoc(), Diagnostics::duplicateTargets, format);",
          "context_before": [
            "            {",
            "                auto format = m_rawTargets[targetIndex].format;",
            "",
            "                if (mapFormatToTargetIndex.containsKey(format))",
            "                {"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    mapFormatToTargetIndex[format] = targetIndex;",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 51,
      "severity": "Error",
      "name": "unhandledLanguageForSourceEmbedding",
      "message": "unhandled source language for source embedding",
      "line": 217,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3186,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::unhandledLanguageForSourceEmbedding);",
          "context_before": [
            "                SLANG_RETURN_ON_FAIL(_expectValue(m_requestImpl->m_sourceEmbedLanguage));",
            "",
            "                if (!SourceEmbedUtil::isSupported(",
            "                        (SlangSourceLanguage)m_requestImpl->m_sourceEmbedLanguage))",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "",
            "                break;",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 60,
      "severity": "Error",
      "name": "cannotDeduceOutputFormatFromPath",
      "message": "cannot infer an output format from the output path '$0'",
      "line": 223,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3944,
          "statement": "Diagnostics::cannotDeduceOutputFormatFromPath, rawOutput.path);",
          "context_before": [
            "                    // format, but the file path doesn't direclty imply a format",
            "                    // (it doesn't have a suffix like `.spv` that tells us what to write).",
            "                    //",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                        rawOutput.path);",
            "                }",
            "                else if (mapFormatToTargetIndex.tryGetValue(rawOutput.impliedFormat, targetIndex))",
            "                {",
            "                    rawOutput.targetIndex = targetIndex;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 61,
      "severity": "Error",
      "name": "cannotMatchOutputFileToTarget",
      "message": "no specified '-target' option matches the output path '$0', which implies the '$1' format",
      "line": 228,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3955,
          "statement": "Diagnostics::cannotMatchOutputFileToTarget, rawOutput.path, rawOutput.impliedFormat);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                        rawOutput.path,",
            "                        rawOutput.impliedFormat);",
            "                }",
            "            }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 62,
      "severity": "Error",
      "name": "unknownCommandLineValue",
      "message": "unknown value for option. Valid values are '$0'",
      "line": 234,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1826,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::unknownCommandLineValue, buf);",
          "context_before": [
            "        m_cmdOptions->getCategoryOptionNames(categoryIndex, names);",
            "",
            "        StringBuilder buf;",
            "        StringUtil::join(names.getBuffer(), names.getCount(), toSlice(\", \"), buf);",
            ""
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    outValue = m_cmdOptions->getOptionAt(optionIndex).userValue;",
            "    return SLANG_OK;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1880,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::unknownCommandLineValue, buf);",
          "context_before": [
            "    }",
            "",
            "    StringBuilder buf;",
            "    StringUtil::join(names.getBuffer(), names.getCount(), toSlice(\", \"), buf);",
            ""
          ],
          "context_after": [
            "    return SLANG_FAIL;",
            "}",
            "",
            "SlangResult OptionsParser::_expectValue(",
            "    ValueCategory valueCategory,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 63,
      "severity": "Error",
      "name": "unknownHelpCategory",
      "message": "unknown help category",
      "line": 235,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2093,
          "statement": "m_sink->diagnose(catArg.loc, Diagnostics::unknownHelpCategory);",
          "context_before": [
            "                m_cmdOptions->findCategoryByCaseInsensitiveName(catArg.value.getUnownedSlice());",
            "        }",
            "",
            "        if (categoryIndex < 0)",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "    }",
            "",
            "    CommandOptionsWriter::Options writerOptions;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 70,
      "severity": "Error",
      "name": "cannotMatchOutputFileToEntryPoint",
      "message": "the output path '$0' is not associated with any entry point; a '-o' option for a compiled kernel must follow the '-entry' option for its corresponding entry point",
      "line": 237,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4017,
          "statement": "Diagnostics::cannotMatchOutputFileToEntryPoint, rawOutput.path);",
          "context_before": [
            "                    default:",
            "                        if (rawOutput.path.getLength() != 0)",
            "                        {",
            "                            m_sink->diagnose(",
            "                                SourceLoc(),"
          ],
          "context_after": [
            "                                rawOutput.path);",
            "                        }",
            "                        break;",
            "                    }",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 71,
      "severity": "Error",
      "name": "invalidTypeConformanceOptionString",
      "message": "syntax error in type conformance option '$0'.",
      "line": 243,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1525,
          "statement": "Diagnostics::invalidTypeConformanceOptionString, stringValue);",
          "context_before": [
            "        Index sequentialId = -1;",
            "        if (!parseTypeConformanceArgString(stringValue, typeName, interfaceName, sequentialId))",
            "        {",
            "            compileRequest->getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                stringValue);",
            "            continue;",
            "        }",
            "        auto concreteType = globalComponentType->getTypeFromString(",
            "            String(typeName).getBuffer(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 72,
      "severity": "Error",
      "name": "invalidTypeConformanceOptionNoType",
      "message": "invalid conformance option '$0', type '$0' is not found.",
      "line": 248,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1536,
          "statement": "Diagnostics::invalidTypeConformanceOptionNoType, stringValue, typeName);",
          "context_before": [
            "            compileRequest->getSink());",
            "        if (!concreteType)",
            "        {",
            "            compileRequest->getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                stringValue,",
            "                typeName);",
            "            continue;",
            "        }",
            "        auto interfaceType = globalComponentType->getTypeFromString("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1548,
          "statement": "Diagnostics::invalidTypeConformanceOptionNoType, stringValue, interfaceName);",
          "context_before": [
            "            compileRequest->getSink());",
            "        if (!interfaceType)",
            "        {",
            "            compileRequest->getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                stringValue,",
            "                interfaceName);",
            "            continue;",
            "        }",
            "        ComPtr<slang::ITypeConformance> conformanceComponent;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 73,
      "severity": "Error",
      "name": "cannotCreateTypeConformance",
      "message": "cannot create type conformance '$0'.",
      "line": 253,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1568,
          "statement": "Diagnostics::cannotCreateTypeConformance, stringValue);",
          "context_before": [
            "            // If we failed to create the conformance component, then",
            "            // we should report the diagnostics that were generated.",
            "            //",
            "            compileRequest->getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                stringValue);",
            "            if (diagnostics)",
            "            {",
            "                compileRequest->getSink()->diagnoseRaw(",
            "                    Severity::Error,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 80,
      "severity": "Error",
      "name": "duplicateOutputPathsForEntryPointAndTarget",
      "message": "multiple output paths have been specified entry point '$0' on target '$1'",
      "line": 255,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4083,
          "statement": "Diagnostics::duplicateOutputPathsForEntryPointAndTarget, entryPointReq->getName(), target->getTarget());",
          "context_before": [
            "            // String outputPath;",
            "            if (targetInfo->entryPointOutputPaths.containsKey(entryPointID))",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    entryPointReq->getName(),",
            "                    target->getTarget());",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 81,
      "severity": "Error",
      "name": "duplicateOutputPathsForTarget",
      "message": "multiple output paths have been specified for target '$0'",
      "line": 260,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4052,
          "statement": "Diagnostics::duplicateOutputPathsForTarget, target->getTarget());",
          "context_before": [
            "        {",
            "            if (targetInfo->wholeTargetOutputPath != \"\")",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    target->getTarget());",
            "            }",
            "            else",
            "            {",
            "                target->getOptionSet().addTargetFlags(SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 82,
      "severity": "Error",
      "name": "duplicateDependencyOutputPaths",
      "message": "the -dep argument can only be specified once",
      "line": 265,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2966,
          "statement": "Diagnostics::duplicateDependencyOutputPaths);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    m_sink->diagnose(",
            "                        dependencyPath.loc,"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "                break;",
            "            }",
            "        case OptionKind::LineDirectiveMode:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 82,
      "severity": "Error",
      "name": "unableToWriteReproFile",
      "message": "unable to write repro file '%0'",
      "line": 271,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1551,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::unableToWriteReproFile, dumpRepro);",
          "context_before": [
            "        if (dumpRepro.getLength())",
            "        {",
            "            SlangResult saveRes = ReproUtil::saveState(this, dumpRepro);",
            "            if (SLANG_FAILED(saveRes))",
            "            {"
          ],
          "context_after": [
            "                return saveRes;",
            "            }",
            "        }",
            "        else if (dumpReproOnError && SLANG_FAILED(res))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1570,
          "statement": "Diagnostics::unableToWriteReproFile, reproFileName);",
          "context_before": [
            "",
            "            if (SLANG_FAILED(saveRes))",
            "            {",
            "                getSink()->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    reproFileName);",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 83,
      "severity": "Error",
      "name": "unableToWriteModuleContainer",
      "message": "unable to write module container '%0'",
      "line": 272,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 84,
      "severity": "Error",
      "name": "unableToReadModuleContainer",
      "message": "unable to read module container '%0'",
      "line": 273,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 85,
      "severity": "Error",
      "name": "unableToAddReferenceToModuleContainer",
      "message": "unable to add a reference to a module container",
      "line": 274,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 86,
      "severity": "Error",
      "name": "unableToCreateModuleContainer",
      "message": "unable to create module container",
      "line": 279,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 574,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::unableToCreateModuleContainer);",
          "context_before": [
            "    {",
            "        OwnedMemoryStream stream(FileAccess::Write);",
            "        SlangResult res = writeContainerToStream(&stream);",
            "        if (SLANG_FAILED(res))",
            "        {"
          ],
          "context_after": [
            "            return res;",
            "        }",
            "",
            "        // Need to turn into a blob",
            "        List<uint8_t> blobData;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 87,
      "severity": "Error",
      "name": "unableToSetDefaultDownstreamCompiler",
      "message": "unable to set default downstream compiler for source language '%0' to '%1'",
      "line": 281,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3120,
          "statement": "Diagnostics::unableToSetDefaultDownstreamCompiler, compilerArg.value, sourceLanguageArg.value);",
          "context_before": [
            "",
            "                if (SLANG_FAILED(m_session->setDefaultDownstreamCompiler(sourceLanguage, compiler)))",
            "                {",
            "                    m_sink->diagnose(",
            "                        arg.loc,"
          ],
          "context_after": [
            "                        compilerArg.value,",
            "                        sourceLanguageArg.value);",
            "                    return SLANG_FAIL;",
            "                }",
            "                break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 88,
      "severity": "Error",
      "name": "unknownArchiveType",
      "message": "archive type '%0' is unknown",
      "line": 287,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 89,
      "severity": "Error",
      "name": "expectingSlangRiffContainer",
      "message": "expecting a slang riff container",
      "line": 288,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1243,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::expectingSlangRiffContainer);",
          "context_before": [
            "        sink->diagnose(SourceLoc(), Diagnostics::unableToReadRiff);",
            "        return SLANG_FAIL;",
            "    }",
            "    if (rootChunk->getType() != kSlangStateFileFourCC)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    auto dataChunk = rootChunk->findDataChunk(kSlangStateDataFourCC);",
            "    if (!dataChunk)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1250,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::expectingSlangRiffContainer);",
          "context_before": [
            "    }",
            "",
            "    auto dataChunk = rootChunk->findDataChunk(kSlangStateDataFourCC);",
            "    if (!dataChunk)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    MemoryReader reader(dataChunk->getPayload(), dataChunk->getPayloadSize());",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1261,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::expectingSlangRiffContainer);",
          "context_before": [
            "    Header header;",
            "    {",
            "        auto result = reader.read(header);",
            "        if (SLANG_FAILED(result))",
            "        {"
          ],
          "context_after": [
            "            return result;",
            "        }",
            "    }",
            "",
            "    if (!g_semanticVersion.isBackwardsCompatibleWith(header.m_semanticVersion))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1293,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::expectingSlangRiffContainer);",
          "context_before": [
            "",
            "    {",
            "        auto result = reader.read(&outBuffer[0], remainingSize);",
            "        if (SLANG_FAILED(result))",
            "        {"
          ],
          "context_after": [
            "            return result;",
            "        }",
            "    }",
            "",
            "    return SLANG_OK;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 90,
      "severity": "Error",
      "name": "incompatibleRiffSemanticVersion",
      "message": "incompatible riff semantic version %0 expecting %1",
      "line": 289,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1274,
          "statement": "Diagnostics::incompatibleRiffSemanticVersion, headerBuf, currentBuf);",
          "context_before": [
            "        header.m_semanticVersion.append(headerBuf);",
            "        g_semanticVersion.append(currentBuf);",
            "",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            headerBuf,",
            "            currentBuf);",
            "        return SLANG_FAIL;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 91,
      "severity": "Error",
      "name": "riffHashMismatch",
      "message": "riff hash mismatch - incompatible riff",
      "line": 294,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1282,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::riffHashMismatch);",
          "context_before": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    if (header.m_typeHash != _getTypeHash())",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    auto remainingSize = reader.getRemainingSize();",
            "    outBuffer.setCount(remainingSize);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 92,
      "severity": "Error",
      "name": "unableToCreateDirectory",
      "message": "unable to create directory '$0'",
      "line": 295,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1346,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::unableToCreateDirectory, dirPath);",
          "context_before": [
            "    String dirPath;",
            "    SLANG_RETURN_ON_FAIL(ReproUtil::calcDirectoryPathFromFilename(filename, dirPath));",
            "",
            "    if (!Path::createDirectory(dirPath))",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    // Set up a file system to write into this directory",
            "    RelativeFileSystem relFileSystem(OSFileSystem::getMutableSingleton(), dirPath);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 93,
      "severity": "Error",
      "name": "unableExtractReproToDirectory",
      "message": "unable to extract repro to directory '$0'",
      "line": 296,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2487,
          "statement": "Diagnostics::unableExtractReproToDirectory, reproName.value);",
          "context_before": [
            "                    const Result res = ReproUtil::extractFilesToDirectory(reproName.value, m_sink);",
            "                    if (SLANG_FAILED(res))",
            "                    {",
            "                        m_sink->diagnose(",
            "                            reproName.loc,"
          ],
          "context_after": [
            "                            reproName.value);",
            "                        return res;",
            "                    }",
            "                }",
            "                break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 94,
      "severity": "Error",
      "name": "unableToReadRiff",
      "message": "unable to read as 'riff'/not a 'riff' file",
      "line": 297,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1221,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::unableToReadRiff);",
          "context_before": [
            "    List<Byte> streamData;",
            "    {",
            "        auto result = StreamUtil::readAll(stream, streamData);",
            "        if (SLANG_FAILED(result))",
            "        {"
          ],
          "context_after": [
            "            return result;",
            "        }",
            "    }",
            "",
            "    return loadState(streamData.getBuffer(), streamData.getCount(), sink, outBuffer);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-repro.cpp",
          "line": 1238,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::unableToReadRiff);",
          "context_before": [
            "    List<uint8_t>& outBuffer)",
            "{",
            "    auto rootChunk = RIFF::RootChunk::getFromBlob(data, dataSize);",
            "    if (!rootChunk)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "    if (rootChunk->getType() != kSlangStateFileFourCC)",
            "    {",
            "        sink->diagnose(SourceLoc(), Diagnostics::expectingSlangRiffContainer);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 95,
      "severity": "Error",
      "name": "unknownLibraryKind",
      "message": "unknown library kind '$0'",
      "line": 299,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1919,
          "statement": "sink->diagnose(loc, Diagnostics::unknownLibraryKind, Path::getPathExt(path));",
          "context_before": [
            "{",
            "    auto desc = ArtifactDescUtil::getDescFromPath(path.getUnownedSlice());",
            "",
            "    if (desc.kind == ArtifactKind::Unknown)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    // If it's a GPU binary, then we'll assume it's a library",
            "    if (ArtifactDescUtil::isGpuUsable(desc))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 96,
      "severity": "Error",
      "name": "kindNotLinkable",
      "message": "not a known linkable kind '$0'",
      "line": 300,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1937,
          "statement": "sink->diagnose(loc, Diagnostics::kindNotLinkable, Path::getPathExt(path));",
          "context_before": [
            "        desc.payload = ArtifactPayload::CompileResults;",
            "    }",
            "",
            "    if (!ArtifactDescUtil::isLinkable(desc))",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    const String name = ArtifactDescUtil::getBaseNameFromPath(desc, path.getUnownedSlice());",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 97,
      "severity": "Error",
      "name": "libraryDoesNotExist",
      "message": "library '$0' does not exist",
      "line": 301,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 1968,
          "statement": "sink->diagnose(loc, Diagnostics::libraryDoesNotExist, path);",
          "context_before": [
            "            IOSFileArtifactRepresentation::Kind::Reference,",
            "            path.getUnownedSlice(),",
            "            nullptr);",
            "        if (!fileRep->exists())",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "    }",
            "    artifact->addRepresentation(fileRep);",
            "    *outArtifact = artifact.detach();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 98,
      "severity": "Error",
      "name": "cannotAccessAsBlob",
      "message": "cannot access as a blob",
      "line": 302,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-artifact-output-util.cpp",
          "line": 160,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::cannotAccessAsBlob);",
          "context_before": [
            "    ComPtr<ISlangBlob>& outBlob)",
            "{",
            "    const auto res = artifact->loadBlob(ArtifactKeep::No, outBlob.writeRef());",
            "    if (SLANG_FAILED(res))",
            "    {"
          ],
          "context_after": [
            "        return res;",
            "    }",
            "    return SLANG_OK;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99,
      "severity": "Error",
      "name": "unknownDebugOption",
      "message": "unknown debug option, known options are ($0)",
      "line": 303,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 104,
      "severity": "Error",
      "name": "needToEnableExperimentFeature",
      "message": "'$0' is an experimental module, need to enable'-experimental-feature' to load this module",
      "line": 304,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1679,
          "statement": "Diagnostics::needToEnableExperimentFeature, moduleName);",
          "context_before": [
            "                                ->findDecoration<IRExperimentalModuleDecoration>() &&",
            "                            !m_optionSet.getBoolOption(CompilerOptionName::ExperimentalFeature))",
            "                        {",
            "                            sink->diagnose(",
            "                                requestingLoc,"
          ],
          "context_after": [
            "                                moduleName);",
            "                        }",
            "                    }",
            "                    return module;",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 105,
      "severity": "Error",
      "name": "nullComponentType",
      "message": "componentTypes[$0] is `nullptr`",
      "line": 310,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 364,
          "statement": "sink.diagnose(SourceLoc{}, Diagnostics::nullComponentType, 0);",
          "context_before": [
            "    if (componentTypeCount == 1)",
            "    {",
            "        auto componentType = componentTypes[0];",
            "        if (componentType == nullptr)",
            "        {"
          ],
          "context_after": [
            "            sink.getBlobIfNeeded(outDiagnostics);",
            "            return SLANG_E_INVALID_ARG;",
            "        }",
            "        componentType->addRef();",
            "        *outCompositeComponentType = componentType;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-session.cpp",
          "line": 378,
          "statement": "sink.diagnose(SourceLoc{}, Diagnostics::nullComponentType, cc);",
          "context_before": [
            "    List<RefPtr<ComponentType>> childComponents;",
            "    for (Int cc = 0; cc < componentTypeCount; ++cc)",
            "    {",
            "        if (componentTypes[cc] == nullptr)",
            "        {"
          ],
          "context_after": [
            "            sink.getBlobIfNeeded(outDiagnostics);",
            "            return SLANG_E_INVALID_ARG;",
            "        }",
            "        childComponents.add(asInternal(componentTypes[cc]));",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 100,
      "severity": "Error",
      "name": "failedToLoadDownstreamCompiler",
      "message": "failed to load downstream compiler '$0'",
      "line": 316,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check.cpp",
          "line": 144,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::failedToLoadDownstreamCompiler, type);",
          "context_before": [
            "            // \"I need all of these libraries\" vs. \"I need at least one of these",
            "            // libraries\").",
            "            //",
            "            if (sink)",
            "            {"
          ],
          "context_after": [
            "            }",
            "            SinkSharedLibraryLoader loader(m_sharedLibraryLoader, sink);",
            "            locator(m_downstreamCompilerPaths[int(type)], &loader, m_downstreamCompilerSet);",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 101,
      "severity": "Error",
      "name": "downstreamCompilerDoesntSupportWholeProgramCompilation",
      "message": "downstream compiler '$0' doesn't support whole program compilation",
      "line": 317,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-code-gen.cpp",
          "line": 686,
          "statement": "Diagnostics::downstreamCompilerDoesntSupportWholeProgramCompilation, downstreamCompilerName);",
          "context_before": [
            "                auto downstreamCompilerName =",
            "                    TypeTextUtil::getPassThroughName((SlangPassThrough)compilerType);",
            "",
            "                sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    downstreamCompilerName);",
            "                return SLANG_FAIL;",
            "            }",
            "        }",
            "        else if (entryPointIndicesCount == 1)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15000,
      "severity": "Error",
      "name": "endOfFileInPreprocessorConditional",
      "message": "end of file encountered during preprocessor conditional",
      "line": 331,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4660,
          "statement": "GetSink(this)->diagnose(eofToken, Diagnostics::endOfFileInPreprocessorConditional);",
          "context_before": [
            "    // at the end of the file.",
            "    //",
            "    for (auto conditional = inputFile->getInnerMostConditional(); conditional;",
            "         conditional = conditional->parent)",
            "    {"
          ],
          "context_after": [
            "        GetSink(this)->diagnose(",
            "            conditional->ifToken,",
            "            Diagnostics::seeDirective,",
            "            conditional->ifToken.getContent());",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDirective"
          ]
        }
      ]
    },
    {
      "id": 15001,
      "severity": "Error",
      "name": "directiveWithoutIf",
      "message": "'$0' directive without '#if'",
      "line": 336,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3335,
          "statement": "Diagnostics::directiveWithoutIf, GetDirectiveName(context));",
          "context_before": [
            "    Conditional* conditional = inputFile->getInnerMostConditional();",
            "    if (!conditional)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        return;",
            "    }",
            "",
            "    // if we've already seen a `#else`, then it is an error"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3399,
          "statement": "Diagnostics::directiveWithoutIf, GetDirectiveName(context));",
          "context_before": [
            "    Conditional* conditional = inputFile->getInnerMostConditional();",
            "    if (!conditional)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        return;",
            "    }",
            "",
            "    // if we've already seen a `#else`, then it is an error"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3457,
          "statement": "Diagnostics::directiveWithoutIf, GetDirectiveName(context));",
          "context_before": [
            "    Conditional* conditional = inputFile->getInnerMostConditional();",
            "    if (!conditional)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        return;",
            "    }",
            "",
            "    inputFile->popConditional();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15002,
      "severity": "Error",
      "name": "directiveAfterElse",
      "message": "'$0' directive without '#if'",
      "line": 337,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3345,
          "statement": "Diagnostics::directiveAfterElse, GetDirectiveName(context));",
          "context_before": [
            "    // if we've already seen a `#else`, then it is an error",
            "    if (conditional->elseToken.type != TokenType::Unknown)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        GetSink(context)->diagnose(conditional->elseToken.loc, Diagnostics::seeDirective);",
            "        return;",
            "    }",
            "    conditional->elseToken = context->m_directiveToken;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDirective"
          ]
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3409,
          "statement": "Diagnostics::directiveAfterElse, GetDirectiveName(context));",
          "context_before": [
            "    // if we've already seen a `#else`, then it is an error",
            "    if (conditional->elseToken.type != TokenType::Unknown)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        GetSink(context)->diagnose(conditional->elseToken.loc, Diagnostics::seeDirective);",
            "        return;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDirective"
          ]
        }
      ]
    },
    {
      "id": 15100,
      "severity": "Error",
      "name": "expectedPreprocessorDirectiveName",
      "message": "expected preprocessor directive name",
      "line": 342,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4611,
          "statement": "Diagnostics::expectedPreprocessorDirectiveName);",
          "context_before": [
            "    // Otherwise the directive name had better be an identifier",
            "    if (directiveTokenType != TokenType::Identifier)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "        SkipToEndOfLine(context);",
            "        return;",
            "    }",
            "",
            "    // Look up the handler for the directive."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15101,
      "severity": "Error",
      "name": "unknownPreprocessorDirective",
      "message": "unknown preprocessor directive '$0'",
      "line": 343,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4503,
          "statement": "Diagnostics::unknownPreprocessorDirective, GetDirectiveName(context));",
          "context_before": [
            "// Handle an invalid directive",
            "static void HandleInvalidDirective(PreprocessorDirectiveContext* context)",
            "{",
            "    GetSink(context)->diagnose(",
            "        GetDirectiveLoc(context),"
          ],
          "context_after": [
            "        GetDirectiveName(context));",
            "    SkipToEndOfLine(context);",
            "}",
            "",
            "// Callback interface used by preprocessor directives"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15102,
      "severity": "Error",
      "name": "expectedTokenInPreprocessorDirective",
      "message": "expected '$0' in '$1' directive",
      "line": 344,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3297,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &nameToken)) return;",
          "context_before": [
            "    // Expect a raw identifier, so we can check if it is defined",
            "    Token nameToken;",
            "    if (!ExpectRaw(",
            "            context,",
            "            TokenType::Identifier,"
          ],
          "context_after": [
            "            &nameToken))",
            "        return;",
            "    Name* name = nameToken.getName();",
            "",
            "    // Check if the name is defined."
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3314,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &nameToken)) return;",
          "context_before": [
            "    // Expect a raw identifier, so we can check if it is defined",
            "    Token nameToken;",
            "    if (!ExpectRaw(",
            "            context,",
            "            TokenType::Identifier,"
          ],
          "context_after": [
            "            &nameToken))",
            "        return;",
            "    Name* name = nameToken.getName();",
            "",
            "    // Check if the name is defined."
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3546,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &pathToken);",
          "context_before": [
            "    {",
            "        StringBuilder pathSB;",
            "        Expect(",
            "            context,",
            "            TokenType::OpLess,"
          ],
          "context_after": [
            "            &pathToken);",
            "        while (PeekRawTokenType(context) != TokenType::OpGreater &&",
            "               PeekRawTokenType(context) != TokenType::EndOfFile)",
            "        {",
            "            pathSB << AdvanceRawToken(context).getContent();"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3556,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective)) return;",
          "context_before": [
            "            pathSB << AdvanceRawToken(context).getContent();",
            "        }",
            "        if (!Expect(",
            "                context,",
            "                TokenType::OpGreater,"
          ],
          "context_after": [
            "            return;",
            "        path = pathSB.produceString();",
            "        includeMode = IncludeSystem::Mode::System;",
            "    }",
            "    else"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3566,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &pathToken);",
          "context_before": [
            "    else",
            "    {",
            "        Expect(",
            "            context,",
            "            TokenType::StringLiteral,"
          ],
          "context_after": [
            "            &pathToken);",
            "        path = getFileNameTokenValue(pathToken);",
            "    }",
            "",
            "    auto directiveLoc = GetDirectiveLoc(context);"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3793,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &nameToken)) return;",
          "context_before": [
            "{",
            "    Token nameToken;",
            "    if (!ExpectRaw(",
            "            context,",
            "            TokenType::Identifier,"
          ],
          "context_after": [
            "            &nameToken))",
            "        return;",
            "    Name* name = nameToken.getName();",
            "",
            "    MacroDefinition* oldMacro = LookupMacro(&context->m_preprocessor->globalEnv, name);"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4003,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective, &nameToken)) return;",
          "context_before": [
            "{",
            "    Token nameToken;",
            "    if (!ExpectRaw(",
            "            context,",
            "            TokenType::Identifier,"
          ],
          "context_after": [
            "            &nameToken))",
            "        return;",
            "    Name* name = nameToken.getName();",
            "",
            "    Environment* env = &context->m_preprocessor->globalEnv;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4155,
          "statement": "Diagnostics::expectedTokenInPreprocessorDirective);",
          "context_before": [
            "",
            "    default:",
            "        Expect(",
            "            context,",
            "            TokenType::StringLiteral,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    auto sourceView = inputStream->getLexer()->m_sourceView;",
            "    sourceView->addLineDirective(directiveLoc, file, line);"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15102,
      "severity": "Error",
      "name": "expected2TokensInPreprocessorDirective",
      "message": "expected '$0' or '$1' in '$2' directive",
      "line": 345,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4090,
          "statement": "Diagnostics::expected2TokensInPreprocessorDirective, TokenType::IntegerLiteral, \"default\", GetDirectiveName(context));",
          "context_before": [
            "",
            "static void _diagnoseInvalidLineDirective(PreprocessorDirectiveContext* context)",
            "{",
            "    GetSink(context)->diagnose(",
            "        PeekLoc(context),"
          ],
          "context_after": [
            "        TokenType::IntegerLiteral,",
            "        \"default\",",
            "        GetDirectiveName(context));",
            "    context->m_parseError = true;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15103,
      "severity": "Error",
      "name": "unexpectedTokensAfterDirective",
      "message": "unexpected tokens following '$0' directive",
      "line": 350,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3489,
          "statement": "Diagnostics::unexpectedTokensAfterDirective, GetDirectiveName(context));",
          "context_before": [
            "        // emit another one for the same directive.",
            "        if (!context->m_parseError)",
            "        {",
            "            GetSink(context)->diagnose(",
            "                PeekLoc(context),"
          ],
          "context_after": [
            "                GetDirectiveName(context));",
            "        }",
            "        SkipToEndOfLine(context);",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15200,
      "severity": "Error",
      "name": "expectedTokenInPreprocessorExpression",
      "message": "expected '$0' in preprocessor expression",
      "line": 358,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2937,
          "statement": "Diagnostics::expectedTokenInPreprocessorExpression)) { GetSink(context)->diagnose(leftParen.loc, Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "            Token leftParen = token;",
            "            PreprocessorExpressionValue value = _parseAndEvaluateExpression(context);",
            "            if (!Expect(",
            "                    context,",
            "                    TokenType::RParent,"
          ],
          "context_after": [
            "            {",
            "                GetSink(context)->diagnose(leftParen.loc, Diagnostics::seeOpeningToken, leftParen);",
            "            }",
            "            return value;",
            "        }"
          ],
          "call_pattern": "unknown",
          "uses_notes": [
            "seeOpeningToken"
          ]
        }
      ]
    },
    {
      "id": 15201,
      "severity": "Error",
      "name": "syntaxErrorInPreprocessorExpression",
      "message": "syntax error in preprocessor expression",
      "line": 363,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2914,
          "statement": "Diagnostics::syntaxErrorInPreprocessorExpression);",
          "context_before": [
            "    {",
            "    case TokenType::EndOfFile:",
            "    case TokenType::NewLine:",
            "        GetSink(context)->diagnose(",
            "            PeekLoc(context),"
          ],
          "context_after": [
            "        return 0;",
            "    }",
            "",
            "    auto token = AdvanceToken(context);",
            "    switch (token.type)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3045,
          "statement": "GetSink(context)->diagnose(token.loc, Diagnostics::syntaxErrorInPreprocessorExpression);",
          "context_before": [
            "                token.getName());",
            "            return 0;",
            "        }",
            "",
            "    default:"
          ],
          "context_after": [
            "        return 0;",
            "    }",
            "}",
            "",
            "// Determine the precedence level of an infix operator"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15202,
      "severity": "Error",
      "name": "divideByZeroInPreprocessorExpression",
      "message": "division by zero in preprocessor expression",
      "line": 368,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3137,
          "statement": "Diagnostics::divideByZeroInPreprocessorExpression);",
          "context_before": [
            "            {",
            "                if (!context->m_parseError)",
            "                {",
            "                    GetSink(context)->diagnose(",
            "                        opToken.loc,"
          ],
          "context_after": [
            "                }",
            "                return 0;",
            "            }",
            "            return left / right;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3151,
          "statement": "Diagnostics::divideByZeroInPreprocessorExpression);",
          "context_before": [
            "            {",
            "                if (!context->m_parseError)",
            "                {",
            "                    GetSink(context)->diagnose(",
            "                        opToken.loc,"
          ],
          "context_after": [
            "                }",
            "                return 0;",
            "            }",
            "            return left % right;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15203,
      "severity": "Error",
      "name": "expectedTokenInDefinedExpression",
      "message": "expected '$0' in 'defined' expression",
      "line": 373,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2965,
          "statement": "Diagnostics::expectedTokenInDefinedExpression, &nameToken)) { return 0;",
          "context_before": [
            "                // Expect an identifier",
            "                Token nameToken;",
            "                if (!ExpectRaw(",
            "                        context,",
            "                        TokenType::Identifier,"
          ],
          "context_after": [
            "                        &nameToken))",
            "                {",
            "                    return 0;",
            "                }",
            "                Name* name = nameToken.getName();"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2978,
          "statement": "Diagnostics::expectedTokenInDefinedExpression)) { GetSink(context)->diagnose( leftParen.loc, Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "                if (leftParen.type != TokenType::Unknown)",
            "                {",
            "                    if (!ExpectRaw(",
            "                            context,",
            "                            TokenType::RParent,"
          ],
          "context_after": [
            "                    {",
            "                        GetSink(context)->diagnose(",
            "                            leftParen.loc,",
            "                            Diagnostics::seeOpeningToken,",
            "                            leftParen);"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3006,
          "statement": "Diagnostics::expectedTokenInDefinedExpression, &nameToken)) { return 0;",
          "context_before": [
            "                // Expect an identifier",
            "                Token nameToken;",
            "                if (!ExpectRaw(",
            "                        context,",
            "                        TokenType::Identifier,"
          ],
          "context_after": [
            "                        &nameToken))",
            "                {",
            "                    return 0;",
            "                }",
            ""
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3018,
          "statement": "Diagnostics::expectedTokenInDefinedExpression)) { GetSink(context)->diagnose( leftParen.loc, Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "                if (leftParen.type != TokenType::Unknown)",
            "                {",
            "                    if (!ExpectRaw(",
            "                            context,",
            "                            TokenType::RParent,"
          ],
          "context_after": [
            "                    {",
            "                        GetSink(context)->diagnose(",
            "                            leftParen.loc,",
            "                            Diagnostics::seeOpeningToken,",
            "                            leftParen);"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15204,
      "severity": "Warning",
      "name": "directiveExpectsExpression",
      "message": "'$0' directive requires an expression",
      "line": 374,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3387,
          "statement": "Diagnostics::directiveExpectsExpression, GetDirectiveName(context));",
          "context_before": [
            "    {",
            "    case TokenType::EndOfFile:",
            "    case TokenType::NewLine:",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            GetDirectiveName(context));",
            "        HandleElseDirective(context);",
            "        return;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15205,
      "severity": "Warning",
      "name": "undefinedIdentifierInPreprocessorExpression",
      "message": "undefined identifier '$0' in preprocessor expression will evaluate to zero",
      "line": 375,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3039,
          "statement": "Diagnostics::undefinedIdentifierInPreprocessorExpression, token.getName());",
          "context_before": [
            "            // An identifier here means it was not defined as a macro (or",
            "            // it is defined, but as a function-like macro. These should",
            "            // just evaluate to zero (possibly with a warning)",
            "            GetSink(context)->diagnose(",
            "                token.loc,"
          ],
          "context_after": [
            "                token.getName());",
            "            return 0;",
            "        }",
            "",
            "    default:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15206,
      "severity": "Error",
      "name": "expectedIntegralVersionNumber",
      "message": "Expected integer for #version number",
      "line": 380,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4420,
          "statement": "Diagnostics::expectedIntegralVersionNumber);",
          "context_before": [
            "        version = stringToInt(AdvanceToken(context).getContent());",
            "        break;",
            "    default:",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "        break;",
            "    }",
            "",
            "    SkipToEndOfLine(context);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4478,
          "statement": "Diagnostics::expectedIntegralVersionNumber);",
          "context_before": [
            "        }",
            "        break;",
            "    default:",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "        break;",
            "    }",
            "",
            "    SkipToEndOfLine(context);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15207,
      "severity": "Error",
      "name": "unknownLanguageVersion",
      "message": "unknown language version '$0'.",
      "line": 381,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5528,
          "statement": "Diagnostics::unknownLanguageVersion, currentModule->languageVersion);",
          "context_before": [
            "    {",
            "        if (!isValidSlangLanguageVersion(currentModule->languageVersion))",
            "        {",
            "            sink->diagnose(",
            "                program->loc,"
          ],
          "context_after": [
            "                currentModule->languageVersion);",
            "        }",
            "    }",
            "",
            "    // If the program already has a scope, then"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2742,
          "statement": "m_sink->diagnose(name.loc, Diagnostics::unknownLanguageVersion, name.value);",
          "context_before": [
            "",
            "                SlangLanguageVersion stdRevision =",
            "                    TypeTextUtil::findLanguageVersion(name.value.getUnownedSlice());",
            "                if (stdRevision == SLANG_LANGUAGE_VERSION_UNKNOWN)",
            "                {"
          ],
          "context_after": [
            "                    return SLANG_FAIL;",
            "                }",
            "                else",
            "                {",
            "                    linkage->m_optionSet.add(OptionKind::LanguageVersion, stdRevision);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4434,
          "statement": "Diagnostics::unknownLanguageVersion, version);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            version);",
            "    }",
            "}",
            "",
            "static void HandleLanguageDirective(PreprocessorDirectiveContext* context)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4493,
          "statement": "Diagnostics::unknownLanguageVersion, version);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "            version);",
            "    }",
            "}",
            "",
            "// Handle an invalid directive"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15208,
      "severity": "Error",
      "name": "unknownLanguage",
      "message": "unknown language '$0'.",
      "line": 382,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4470,
          "statement": "Diagnostics::unknownLanguage, token);",
          "context_before": [
            "                version = stringToInt(token.getContent());",
            "            else",
            "            {",
            "                GetSink(context)->diagnose(",
            "                    GetDirectiveLoc(context),"
          ],
          "context_after": [
            "                    token);",
            "            }",
            "        }",
            "        break;",
            "    default:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15208,
      "severity": "Error",
      "name": "languageVersionDiffersFromIncludingModule",
      "message": "the source file declares a different language version than the including module.",
      "line": 383,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1907,
          "statement": "Diagnostics::languageVersionDiffersFromIncludingModule);",
          "context_before": [
            "",
            "    if (slangLanguageVersion != module->getModuleDecl()->languageVersion)",
            "    {",
            "        sink->diagnose(",
            "            tokens.begin()->getLoc(),"
          ],
          "context_after": [
            "    }",
            "",
            "    auto outerScope = module->getModuleDecl()->ownedScope;",
            "    parseSourceFile(",
            "        module->getASTBuilder(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15300,
      "severity": "Error",
      "name": "includeFailed",
      "message": "failed to find include file '$0'",
      "line": 391,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3580,
          "statement": "GetSink(context)->diagnose(pathToken.loc, Diagnostics::includeFailed, path);",
          "context_before": [
            "        SourceLocType::Actual);",
            "",
            "    IncludeSystem* includeSystem = context->m_preprocessor->includeSystem;",
            "    if (!includeSystem)",
            "    {"
          ],
          "context_after": [
            "        GetSink(context)->diagnose(pathToken.loc, Diagnostics::noIncludeHandlerSpecified);",
            "        return;",
            "    }",
            "",
            "    /* Find the path relative to the foundPath */"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "noIncludeHandlerSpecified"
          ]
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3591,
          "statement": "GetSink(context)->diagnose(pathToken.loc, Diagnostics::includeFailed, path);",
          "context_before": [
            "    PathInfo filePathInfo;",
            "    if (SLANG_FAILED(",
            "            includeSystem",
            "                ->findFile(path, includedFromPathInfo.foundPath, filePathInfo, includeMode)))",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // We must have a uniqueIdentity to be compare",
            "    if (!filePathInfo.hasUniqueIdentity())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3630,
          "statement": "GetSink(context)->diagnose(pathToken.loc, Diagnostics::includeFailed, path);",
          "context_before": [
            "    if (!sourceFile)",
            "    {",
            "        ComPtr<ISlangBlob> foundSourceBlob;",
            "        if (SLANG_FAILED(readFile(context, filePathInfo.foundPath, foundSourceBlob.writeRef())))",
            "        {"
          ],
          "context_after": [
            "            return;",
            "        }",
            "",
            "        sourceFile = sourceManager->createSourceFileWithBlob(filePathInfo, foundSourceBlob);",
            "        sourceManager->addSourceFile(filePathInfo.uniqueIdentity, sourceFile);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15301,
      "severity": "Error",
      "name": "importFailed",
      "message": "failed to find imported file '$0'",
      "line": 392,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-serialize-ast.cpp",
          "line": 1516,
          "statement": "_sink->diagnose(_requestingSourceLoc, Diagnostics::importFailed, moduleName);",
          "context_before": [
            "    serialize(serializer, moduleName);",
            "    auto module = _linkage->findOrImportModule(moduleName, _requestingSourceLoc, _sink);",
            "    if (!module)",
            "    {",
            "        if (_sink)"
          ],
          "context_after": [
            "        return nullptr;",
            "    }",
            "    return module->getModuleDecl();",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15302,
      "severity": "Error",
      "name": "cyclicInclude",
      "message": "cyclic `#include` of file '$0'",
      "line": 393,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3644,
          "statement": "Diagnostics::cyclicInclude, pathToken.getContent());",
          "context_before": [
            "    if (context->m_preprocessor->includedFiles.contains(fileIdentity))",
            "    {",
            "        // This file has already been included, we should diagnose an error and return.",
            "        GetSink(context)->diagnose(",
            "            pathToken.loc,"
          ],
          "context_after": [
            "            pathToken.getContent());",
            "        return;",
            "    }",
            "",
            "    // If we are running the preprocessor as part of compiling a"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": -1,
      "severity": "Error",
      "name": "noIncludeHandlerSpecified",
      "message": "no `#include` handler was specified",
      "line": 394,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3581,
          "statement": "GetSink(context)->diagnose(pathToken.loc, Diagnostics::noIncludeHandlerSpecified);",
          "context_before": [
            "",
            "    IncludeSystem* includeSystem = context->m_preprocessor->includeSystem;",
            "    if (!includeSystem)",
            "    {",
            "        GetSink(context)->diagnose(pathToken.loc, Diagnostics::includeFailed, path);"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    /* Find the path relative to the foundPath */",
            "    PathInfo filePathInfo;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15302,
      "severity": "Error",
      "name": "noUniqueIdentity",
      "message": "`#include` handler didn't generate a unique identity for file '$0'",
      "line": 395,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3598,
          "statement": "GetSink(context)->diagnose(pathToken.loc, Diagnostics::noUniqueIdentity, path);",
          "context_before": [
            "    }",
            "",
            "    // We must have a uniqueIdentity to be compare",
            "    if (!filePathInfo.hasUniqueIdentity())",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    reportIncludeFileForContentAssist(context->m_preprocessor, pathToken, filePathInfo.foundPath);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15303,
      "severity": "Error",
      "name": "cannotResolveImportedDecl",
      "message": "cannot resolve imported declaration '$0' from precompiled module '$1'. Make sure module '$1' is up-to-date. If you suspect this to be a compiler bug, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord for assistance",
      "line": 400,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-serialize-ast.cpp",
          "line": 1566,
          "statement": "Diagnostics::cannotResolveImportedDecl, mangledName, importedFromModule->getName());",
          "context_before": [
            "        importedFromModule->findExportedDeclByMangledName(mangledName.getUnownedSlice());",
            "    if (!importedDecl)",
            "    {",
            "        _sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            mangledName,",
            "            importedFromModule->getName());",
            "    }",
            "    return importedDecl;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15400,
      "severity": "Warning",
      "name": "macroRedefinition",
      "message": "redefinition of macro '$0'",
      "line": 410,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3809,
          "statement": "sink->diagnose(nameToken.loc, Diagnostics::macroRedefinition, name);",
          "context_before": [
            "        {",
            "            sink->diagnose(nameToken.loc, Diagnostics::builtinMacroRedefinition, name);",
            "        }",
            "        else",
            "        {"
          ],
          "context_after": [
            "            sink->diagnose(oldMacro->getLoc(), Diagnostics::seePreviousDefinitionOf, name);",
            "        }",
            "",
            "        delete oldMacro;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seePreviousDefinitionOf"
          ]
        }
      ]
    },
    {
      "id": 15401,
      "severity": "Warning",
      "name": "macroNotDefined",
      "message": "macro '$0' is not defined",
      "line": 411,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4020,
          "statement": "GetSink(context)->diagnose(nameToken.loc, Diagnostics::macroNotDefined, name);",
          "context_before": [
            "        delete macro;",
            "    }",
            "    else",
            "    {",
            "        // name wasn't defined"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "static String _readDirectiveMessage(PreprocessorDirectiveContext* context)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15403,
      "severity": "Error",
      "name": "expectedTokenInMacroParameters",
      "message": "expected '$0' in macro parameters",
      "line": 412,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3853,
          "statement": "Diagnostics::expectedTokenInMacroParameters, &paramNameToken)) break;",
          "context_before": [
            "                if (PeekRawTokenType(context) != TokenType::Ellipsis)",
            "                {",
            "                    if (!ExpectRaw(",
            "                            context,",
            "                            TokenType::Identifier,"
          ],
          "context_after": [
            "                            &paramNameToken))",
            "                        break;",
            "                }",
            "",
            "                // Whether or not a name was seen, we allow an ellipsis"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3929,
          "statement": "ExpectRaw(context, TokenType::Comma, Diagnostics::expectedTokenInMacroParameters);",
          "context_before": [
            "",
            "                // If we see `)` then we are done with arguments",
            "                if (PeekRawTokenType(context) == TokenType::RParent)",
            "                    break;",
            ""
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        ExpectRaw(context, TokenType::RParent, Diagnostics::expectedTokenInMacroParameters);",
            ""
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3933,
          "statement": "ExpectRaw(context, TokenType::RParent, Diagnostics::expectedTokenInMacroParameters);",
          "context_before": [
            "",
            "                ExpectRaw(context, TokenType::Comma, Diagnostics::expectedTokenInMacroParameters);",
            "            }",
            "        }",
            ""
          ],
          "context_after": [
            "",
            "        // Once we have parsed the macro parameters, we can perform the additional validation",
            "        // step of checking that any parameters before the last parameter are not variadic.",
            "        //",
            "        Index lastParamIndex = macro->params.getCount() - 1;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15404,
      "severity": "Warning",
      "name": "builtinMacroRedefinition",
      "message": "Redefinition of builtin macro '$0'",
      "line": 413,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3805,
          "statement": "sink->diagnose(nameToken.loc, Diagnostics::builtinMacroRedefinition, name);",
          "context_before": [
            "    {",
            "        auto sink = GetSink(context);",
            "",
            "        if (oldMacro->isBuiltin())",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            sink->diagnose(nameToken.loc, Diagnostics::macroRedefinition, name);",
            "            sink->diagnose(oldMacro->getLoc(), Diagnostics::seePreviousDefinitionOf, name);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15405,
      "severity": "Error",
      "name": "tokenPasteAtStart",
      "message": "'##' is not allowed at the start of a macro body",
      "line": 415,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3734,
          "statement": "GetSink(preprocessor)->diagnose(token.loc, Diagnostics::tokenPasteAtStart);",
          "context_before": [
            "            break;",
            "",
            "        case TokenType::PoundPound:",
            "            if (macro->ops.getCount() == 0 && (spanBeginIndex == spanEndIndex))",
            "            {"
          ],
          "context_after": [
            "                continue;",
            "            }",
            "",
            "            if (macro->tokens.m_tokens[cursor].type == TokenType::EndOfFile)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15406,
      "severity": "Error",
      "name": "tokenPasteAtEnd",
      "message": "'##' is not allowed at the end of a macro body",
      "line": 416,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3740,
          "statement": "GetSink(preprocessor)->diagnose(token.loc, Diagnostics::tokenPasteAtEnd);",
          "context_before": [
            "                continue;",
            "            }",
            "",
            "            if (macro->tokens.m_tokens[cursor].type == TokenType::EndOfFile)",
            "            {"
          ],
          "context_after": [
            "                continue;",
            "            }",
            "",
            "            newOp.opcode = MacroDefinition::Opcode::TokenPaste;",
            "            newOp.index0 = tokenIndex;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15407,
      "severity": "Error",
      "name": "expectedMacroParameterAfterStringize",
      "message": "'#' in macro body must be followed by the name of a macro parameter",
      "line": 417,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3711,
          "statement": "->diagnose(token.loc, Diagnostics::expectedMacroParameterAfterStringize);",
          "context_before": [
            "                auto paramNameTokenIndex = cursor;",
            "                auto paramNameToken = macro->tokens.m_tokens[paramNameTokenIndex];",
            "                if (paramNameToken.type != TokenType::Identifier)",
            "                {",
            "                    GetSink(preprocessor)"
          ],
          "context_after": [
            "                    continue;",
            "                }",
            "                auto paramName = paramNameToken.getName();",
            "                Index paramIndex = -1;",
            "                if (!mapParamNameToIndex.tryGetValue(paramName, paramIndex))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3719,
          "statement": "->diagnose(token.loc, Diagnostics::expectedMacroParameterAfterStringize);",
          "context_before": [
            "                auto paramName = paramNameToken.getName();",
            "                Index paramIndex = -1;",
            "                if (!mapParamNameToIndex.tryGetValue(paramName, paramIndex))",
            "                {",
            "                    GetSink(preprocessor)"
          ],
          "context_after": [
            "                    continue;",
            "                }",
            "",
            "                cursor++;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15408,
      "severity": "Error",
      "name": "duplicateMacroParameterName",
      "message": "redefinition of macro parameter '$0'",
      "line": 422,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3916,
          "statement": "Diagnostics::duplicateMacroParameterName, name);",
          "context_before": [
            "                auto paramName = param.nameLoc.name;",
            "                if (mapParamNameToIndex.containsKey(paramName))",
            "                {",
            "                    GetSink(context)->diagnose(",
            "                        param.nameLoc.loc,"
          ],
          "context_after": [
            "                        name);",
            "                }",
            "                else",
            "                {",
            "                    mapParamNameToIndex[paramName] = paramIndex;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15409,
      "severity": "Error",
      "name": "variadicMacroParameterMustBeLast",
      "message": "a variadic macro parameter is only allowed at the end of the parameter list",
      "line": 423,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3947,
          "statement": "Diagnostics::variadicMacroParameterMustBeLast, param.nameLoc.name);",
          "context_before": [
            "            if (!param.isVariadic)",
            "                continue;",
            "",
            "            GetSink(context)->diagnose(",
            "                param.nameLoc.loc,"
          ],
          "context_after": [
            "                param.nameLoc.name);",
            "",
            "            // As a precaution, we will unmark the variadic-ness of the parameter, so that",
            "            // logic downstream from this step doesn't have to deal with the possibility",
            "            // of a variadic parameter in the middle of the parameter list."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15500,
      "severity": "Warning",
      "name": "expectedTokenInMacroArguments",
      "message": "expected '$0' in macro invocation",
      "line": 430,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1844,
          "statement": "Diagnostics::expectedTokenInMacroArguments, TokenType::RParent, m_inputStreams.peekTokenType());",
          "context_before": [
            "                else",
            "                {",
            "                    GetSink(preprocessor)",
            "                        ->diagnose(",
            "                            m_inputStreams.peekLoc(),"
          ],
          "context_after": [
            "                            TokenType::RParent,",
            "                            m_inputStreams.peekTokenType());",
            "                }",
            "",
            "                // The number of arguments at the macro invocation site might not"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15501,
      "severity": "Error",
      "name": "wrongNumberOfArgumentsToMacro",
      "message": "wrong number of arguments to macro (expected $0, got $1)",
      "line": 431,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1866,
          "statement": "Diagnostics::wrongNumberOfArgumentsToMacro, paramCount, argCount);",
          "context_before": [
            "                    if (argCount != paramCount)",
            "                    {",
            "                        GetSink(preprocessor)",
            "                            ->diagnose(",
            "                                leftParen.loc,"
          ],
          "context_after": [
            "                                paramCount,",
            "                                argCount);",
            "                        return;",
            "                    }",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1885,
          "statement": "Diagnostics::wrongNumberOfArgumentsToMacro, requiredArgCount, argCount);",
          "context_before": [
            "                    if (argCount < requiredArgCount)",
            "                    {",
            "                        GetSink(preprocessor)",
            "                            ->diagnose(",
            "                                leftParen.loc,"
          ],
          "context_after": [
            "                                requiredArgCount,",
            "                                argCount);",
            "                        return;",
            "                    }",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15502,
      "severity": "Error",
      "name": "errorParsingToMacroInvocationArgument",
      "message": "error parsing macro '$0' invocation argument to '$1'",
      "line": 436,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1648,
          "statement": "Diagnostics::errorParsingToMacroInvocationArgument, paramCount, macro->getName());",
          "context_before": [
            "            // ahead for a closing `)`. For now it is simplest",
            "            // to just bail.",
            "            //",
            "            getSink()->diagnose(",
            "                m_inputStreams.peekLoc(),"
          ],
          "context_after": [
            "                paramCount,",
            "                macro->getName());",
            "            return;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15503,
      "severity": "Warning",
      "name": "invalidTokenPasteResult",
      "message": "toking pasting with '##' resulted in the invalid token '$0'",
      "line": 442,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2224,
          "statement": "Diagnostics::invalidTokenPasteResult, pastedContent);",
          "context_before": [
            "                //",
            "                if (lexedTokens.m_tokens.getCount() > 2)",
            "                {",
            "                    getSink()->diagnose(",
            "                        tokenPasteLoc,"
          ],
          "context_after": [
            "                        pastedContent);",
            "                }",
            "",
            "                // No matter what sequence of tokens we got, we can create an input stream to",
            "                // represent them and push it as the representation of the `##` macro definition op."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15600,
      "severity": "Error",
      "name": "expectedPragmaDirectiveName",
      "message": "expected a name after '#pragma'",
      "line": 449,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4391,
          "statement": "Diagnostics::expectedPragmaDirectiveName);",
          "context_before": [
            "    // The sub-directive had better be an identifier",
            "    if (subDirectiveToken.type != TokenType::Identifier)",
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),"
          ],
          "context_after": [
            "        SkipToEndOfLine(context);",
            "        return;",
            "    }",
            "    AdvanceRawToken(context);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15601,
      "severity": "Warning",
      "name": "unknownPragmaDirectiveIgnored",
      "message": "ignoring unknown directive '#pragma $0'",
      "line": 450,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4173,
          "statement": "Diagnostics::unknownPragmaDirectiveIgnored, subDirectiveToken.getName());",
          "context_before": [
            "",
            "SLANG_PRAGMA_DIRECTIVE_CALLBACK(handleUnknownPragmaDirective)",
            "{",
            "    GetSink(context)->diagnose(",
            "        subDirectiveToken,"
          ],
          "context_after": [
            "        subDirectiveToken.getName());",
            "    SkipToEndOfLine(context);",
            "    return;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15602,
      "severity": "Warning",
      "name": "pragmaOnceIgnored",
      "message": "pragma once was ignored - this is typically because is not placed in an include",
      "line": 451,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4195,
          "statement": "GetSink(context)->diagnose(subDirectiveToken, Diagnostics::pragmaOnceIgnored);",
          "context_before": [
            "        SourceLocType::Actual);",
            "",
            "    // Must have uniqueIdentity for a #pragma once to work",
            "    if (!issuedFromPathInfo.hasUniqueIdentity())",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    context->m_preprocessor->pragmaOnceUniqueIdentities.add(issuedFromPathInfo.uniqueIdentity);",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15610,
      "severity": "Error",
      "name": "pragmaWarningGenericError",
      "message": "Error in #pragma warning processing: $0",
      "line": 456,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 15611,
      "severity": "Warning",
      "name": "pragmaWarningPopEmpty",
      "message": "Detected #pragma warning(pop) with no corresponding #pragma warning(push)",
      "line": 457,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1260,
          "statement": "sink->diagnose(location, Diagnostics::pragmaWarningPopEmpty);",
          "context_before": [
            "                }",
            "            }",
            "        }",
            "        else if (sink)",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "};",
            "",
            "/// State of the preprocessor"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15612,
      "severity": "Warning",
      "name": "pragmaWarningPushNotPopped",
      "message": "Detected #pragma warning(push) with no corresponding #pragma warning(pop)",
      "line": 462,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4849,
          "statement": "sink->diagnose(pushed, Diagnostics::pragmaWarningPushNotPopped);",
          "context_before": [
            "    if (tracker)",
            "    {",
            "        auto sink = GetSink(preprocessor);",
            "        for (const auto& pushed : tracker->stack)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        tracker->stack.clearAndDeallocate();",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15613,
      "severity": "Warning",
      "name": "pragmaWarningUnknownSpecifier",
      "message": "Unknown #pragma warning specifier '$0'",
      "line": 467,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4283,
          "statement": "Diagnostics::pragmaWarningUnknownSpecifier, id.getContent());",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    GetSink(context)->diagnose(",
            "                        specifierLocation,"
          ],
          "context_after": [
            "                        id.getContent());",
            "                    return finish();",
            "                }",
            "                Expect(context, TokenType::Colon, Diagnostics::syntaxError);",
            "                // Read the id list"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15614,
      "severity": "Warning",
      "name": "pragmaWarningSuppressCannotIdentifyNextLine",
      "message": "Cannot identify the next line to suppress in #pragma warning suppress",
      "line": 468,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4275,
          "statement": "Diagnostics::pragmaWarningSuppressCannotIdentifyNextLine);",
          "context_before": [
            "                    nextLineEnd = FindNextEndOfLine(context, specifierLocation, 2);",
            "                    if (!nextLineEnd.isValid())",
            "                    {",
            "                        GetSink(context)->diagnose(",
            "                            specifierLocation,"
          ],
          "context_after": [
            "                        return finish();",
            "                    }",
            "                }",
            "                else",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15615,
      "severity": "Warning",
      "name": "pragmaWarningCannotInsertHere",
      "message": "Cannot insert #pragma warning here for id '$0'",
      "line": 473,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1155,
          "statement": "sink->diagnose(debugLoc, Diagnostics::pragmaWarningCannotInsertHere, id);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            if (sink)",
            "            {"
          ],
          "context_after": [
            "                const Entry* prevEntry = findEntry(location);",
            "                if (prevEntry && prevEntry->specifier == PragmaWarningSpecifier::Suppress)",
            "                {",
            "                    sink->diagnose(",
            "                        SourceLoc::fromRaw(prevEntry->debugLocation),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15900,
      "severity": "Error",
      "name": "userDefinedError",
      "message": "#error: $0",
      "line": 486,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4075,
          "statement": "GetSink(context)->diagnose(GetDirectiveLoc(context), Diagnostics::userDefinedError, message);",
          "context_before": [
            "    String message = _readDirectiveMessage(context);",
            "",
            "    _setLexerDiagnosticSuppression(getInputFile(context), false);",
            "",
            "    // Report the custom error."
          ],
          "context_after": [
            "}",
            "",
            "static void _handleDefaultLineDirective(PreprocessorDirectiveContext* context)",
            "{",
            "    SourceLoc directiveLoc = GetDirectiveLoc(context);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 15901,
      "severity": "Warning",
      "name": "userDefinedWarning",
      "message": "#warning: $0",
      "line": 487,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4058,
          "statement": "GetSink(context)->diagnose(GetDirectiveLoc(context), Diagnostics::userDefinedWarning, message);",
          "context_before": [
            "    String message = _readDirectiveMessage(context);",
            "",
            "    _setLexerDiagnosticSuppression(getInputFile(context), false);",
            "",
            "    // Report the custom error."
          ],
          "context_after": [
            "}",
            "",
            "// Handle a `#error` directive",
            "static void HandleErrorDirective(PreprocessorDirectiveContext* context)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20003,
      "severity": "Error",
      "name": "unexpectedToken",
      "message": "unexpected $0",
      "line": 493,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 290,
          "statement": "Diagnostics::unexpectedToken, parser->tokenReader.peekTokenType());",
          "context_before": [
            "    // Don't emit \"unexpected token\" errors if we are in recovering mode",
            "    if (!parser->isRecovering)",
            "    {",
            "        parser->diagnose(",
            "            parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "            parser->tokenReader.peekTokenType());",
            "",
            "        // Switch into recovery mode, to suppress additional errors",
            "        parser->isRecovering = true;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 4303,
          "statement": "Diagnostics::unexpectedToken, peekToken(parser));",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        parser->sink->diagnose(",
            "            parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "            peekToken(parser));",
            "    }",
            "}",
            "",
            "// Parse a semantic declaration: \"semantic <name> { [accessor]* }\""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5227,
          "statement": "Diagnostics::unexpectedToken, parser->tokenReader.peekToken());",
          "context_before": [
            "            // skip the whole `{}` block and return an empty decl.",
            "            if (!parser->isRecovering)",
            "            {",
            "                parser->sink->diagnose(",
            "                    loc,"
          ],
          "context_after": [
            "                    parser->tokenReader.peekToken());",
            "            }",
            "            SkipBalancedToken(&parser->tokenReader);",
            "            decl = parser->astBuilder->create<EmptyDecl>();",
            "            decl->loc = loc;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4326,
          "statement": "Diagnostics::unexpectedToken, end.getContent());",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    GetSink(context)->diagnose(",
            "                        endLoc,"
          ],
          "context_after": [
            "                        end.getContent());",
            "                    return finish();",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "unexpectedTokenExpectedTokenType",
      "message": "unexpected $0, expected $1",
      "line": 494,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 323,
          "statement": "Diagnostics::unexpectedTokenExpectedTokenType, parser->tokenReader.peekTokenType(), expected);",
          "context_before": [
            "    {",
            "        if (parser->lastErrorLoc != parser->tokenReader.peekLoc())",
            "        {",
            "            parser->sink->diagnose(",
            "                parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "                parser->tokenReader.peekTokenType(),",
            "                expected);",
            "            parser->lastErrorLoc = parser->tokenReader.peekLoc();",
            "        }",
            "        // Switch into recovery mode, to suppress additional errors"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5627,
          "statement": "Diagnostics::unexpectedTokenExpectedTokenType, \"';'\");",
          "context_before": [
            "                PopScope();",
            "                if (!LookAheadToken(TokenType::Semicolon))",
            "                {",
            "                    this->diagnose(",
            "                        this->tokenReader.peekToken().loc,"
          ],
          "context_after": [
            "                        \"';'\");",
            "                }",
            "                return rs;",
            "            }",
            "            if (LookAheadToken(TokenType::Semicolon))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5827,
          "statement": "Diagnostics::unexpectedTokenExpectedTokenType, parser->tokenReader.peekToken(), \"'case' or 'default'\");",
          "context_before": [
            "        }",
            "        if (caseNames.getCount() == 0)",
            "        {",
            "            parser->sink->diagnose(",
            "                parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "                parser->tokenReader.peekToken(),",
            "                \"'case' or 'default'\");",
            "            parser->isRecovering = true;",
            "            goto recover;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 6614,
          "statement": "Diagnostics::unexpectedTokenExpectedTokenType, \"expression\");",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            sink->diagnose(",
            "                stmt->initialStatement->loc,"
          ],
          "context_after": [
            "                \"expression\");",
            "        }",
            "    }",
            "    else",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "unexpectedTokenExpectedTokenName",
      "message": "unexpected $0, expected '$1'",
      "line": 495,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 305,
          "statement": "Diagnostics::unexpectedTokenExpectedTokenName, parser->tokenReader.peekTokenType(), expected);",
          "context_before": [
            "    // Don't emit \"unexpected token\" errors if we are in recovering mode",
            "    if (!parser->isRecovering)",
            "    {",
            "        parser->sink->diagnose(",
            "            parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "            parser->tokenReader.peekTokenType(),",
            "            expected);",
            "",
            "        // Switch into recovery mode, to suppress additional errors",
            "        parser->isRecovering = true;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 0,
      "severity": "Error",
      "name": "tokenNameExpectedButEOF",
      "message": "\\\"$0\\\" expected but end of file encountered.",
      "line": 497,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 0,
      "severity": "Error",
      "name": "tokenTypeExpectedButEOF",
      "message": "$0 expected but end of file encountered.",
      "line": 498,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "tokenNameExpected",
      "message": "\\\"$0\\\" expected",
      "line": 499,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "tokenNameExpectedButEOF2",
      "message": "\\\"$0\\\" expected but end of file encountered.",
      "line": 500,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "tokenTypeExpected",
      "message": "$0 expected",
      "line": 501,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 2387,
          "statement": "Diagnostics::tokenTypeExpected, \"'>'\");",
          "context_before": [
            "    else if (parser->LookAheadToken(TokenType::OpGreater))",
            "        parser->ReadToken(TokenType::OpGreater);",
            "    else",
            "        parser->sink->diagnose(",
            "            parser->tokenReader.peekToken(),"
          ],
          "context_after": [
            "            \"'>'\");",
            "    return genericApp;",
            "}",
            "",
            "static bool isGenericName(Parser* parser, Name* name)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "tokenTypeExpectedButEOF2",
      "message": "$0 expected but end of file encountered.",
      "line": 502,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "typeNameExpectedBut",
      "message": "unexpected $0, expected type name",
      "line": 503,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "typeNameExpectedButEOF",
      "message": "type name expected but end of file encountered.",
      "line": 504,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 20001,
      "severity": "Error",
      "name": "unexpectedEOF",
      "message": " Unexpected end of file.",
      "line": 505,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 20002,
      "severity": "Error",
      "name": "syntaxError",
      "message": "syntax error.",
      "line": 506,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7668,
          "statement": "parser->diagnose(parser->tokenReader.peekLoc(), Diagnostics::syntaxError);",
          "context_before": [
            "{",
            "    switch (peekTokenType(parser))",
            "    {",
            "    default:",
            "        // TODO: should this return an error expression instead of NULL?"
          ],
          "context_after": [
            "        return parser->astBuilder->create<IncompleteExpr>();",
            "",
            "    // Either:",
            "    // - parenthesized expression `(exp)`",
            "    // - cast `(type) exp`"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8823,
          "statement": "parser->diagnose(newExpr->loc, Diagnostics::syntaxError);",
          "context_before": [
            "                    newExpr->arguments = invokeExpr->arguments;",
            "                    newExpr->argumentDelimeterLocs = invokeExpr->argumentDelimeterLocs;",
            "                }",
            "                else",
            "                {"
          ],
          "context_after": [
            "                    newExpr->functionExpr = parser->astBuilder->create<IncompleteExpr>();",
            "                }",
            "                return newExpr;",
            "            }",
            "            else if (AdvanceIf(parser, \"spirv_asm\"))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-linkable.cpp",
          "line": 796,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::syntaxError);",
          "context_before": [
            "    SLANG_AST_BUILDER_RAII(linkage->getASTBuilder());",
            "    auto astBuilder = linkage->getASTBuilder();",
            "    Scope* scope = _getOrCreateScopeForLegacyLookup(astBuilder);",
            "    Expr* expr = linkage->parseTermString(exprStr, scope);",
            "    if (!expr || as<IncompleteExpr>(expr))"
          ],
          "context_after": [
            "    return expr;",
            "}",
            "",
            "Type* ComponentType::getTypeFromString(String const& typeStr, DiagnosticSink* sink)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4207,
          "statement": "Expect(context, TokenType::LParent, Diagnostics::syntaxError);",
          "context_before": [
            "SLANG_PRAGMA_DIRECTIVE_CALLBACK(handlePragmaWarningDirective)",
            "{",
            "    auto directiveLoc = GetDirectiveLoc(context);",
            "    SLANG_UNUSED(subDirectiveToken)",
            "    SLANG_UNUSED(directiveLoc);"
          ],
          "context_after": [
            "    Token tk = PeekToken(context);",
            "    auto finish = [&]() -> void { SkipToEndOfLine(context); };",
            "    if (tk.type == TokenType::Identifier)",
            "    {",
            "        // #pragma warning (push)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4246,
          "statement": "Expect(context, TokenType::Identifier, Diagnostics::syntaxError, &id);",
          "context_before": [
            "                // and the token is 'suppress' located at the macro definition on line (a)",
            "                // The #pragma warning should take effect from line (b), not line (a),",
            "                // So we need the raw token location.",
            "                SourceLoc specifierLocation = PeekRawToken(context).loc;",
            "                Token id;"
          ],
          "context_after": [
            "                PragmaWarningSpecifier specifier;",
            "                SourceLoc nextLineEnd = {}; // Needed for suppress",
            "                if (id.getContent() == \"default\")",
            "                {",
            "                    specifier = PragmaWarningSpecifier::Default;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4287,
          "statement": "Expect(context, TokenType::Colon, Diagnostics::syntaxError);",
          "context_before": [
            "                        specifierLocation,",
            "                        Diagnostics::pragmaWarningUnknownSpecifier,",
            "                        id.getContent());",
            "                    return finish();",
            "                }"
          ],
          "context_after": [
            "                // Read the id list",
            "                while (true)",
            "                {",
            "                    // Same logic as for the specifierLocation",
            "                    SourceLoc idLocation = PeekRawToken(context).loc;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4335,
          "statement": "GetSink(context)->diagnose(tk, Diagnostics::syntaxError);",
          "context_before": [
            "            }",
            "        }",
            "    }",
            "    else",
            "    {"
          ],
          "context_after": [
            "        return finish();",
            "    }",
            "    Expect(context, TokenType::RParent, Diagnostics::syntaxError);",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4338,
          "statement": "Expect(context, TokenType::RParent, Diagnostics::syntaxError);",
          "context_before": [
            "    else",
            "    {",
            "        GetSink(context)->diagnose(tk, Diagnostics::syntaxError);",
            "        return finish();",
            "    }"
          ],
          "context_after": [
            "}",
            "",
            "// Information about a specific `#pragma` directive",
            "struct PragmaDirective",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20004,
      "severity": "Error",
      "name": "unexpectedTokenExpectedComponentDefinition",
      "message": "unexpected token '$0', only component definitions are allowed in a shader scope.",
      "line": 507,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20005,
      "severity": "Error",
      "name": "invalidEmptyParenthesisExpr",
      "message": "empty parenthesis '()' is not a valid expression.",
      "line": 512,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7735,
          "statement": "parser->diagnose(openParen, Diagnostics::invalidEmptyParenthesisExpr);",
          "context_before": [
            "                    }",
            "                    else",
            "                    {",
            "                        // We don't support empty parentheses `()` as a valid expression prior to",
            "                        // Slang 2026."
          ],
          "context_after": [
            "                        base = parser->astBuilder->create<IncompleteExpr>();",
            "                        base->type = parser->astBuilder->getErrorType();",
            "                    }",
            "                }",
            "                else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20008,
      "severity": "Error",
      "name": "invalidOperator",
      "message": "invalid operator '$0'.",
      "line": 517,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 1431,
          "statement": "parser->sink->diagnose(nameToken.loc, Diagnostics::invalidOperator, nameToken);",
          "context_before": [
            "                // Concat : onto ?",
            "                nameToken.setContent(UnownedStringSlice::fromLiteral(\"?:\"));",
            "                break;",
            "            }; // fall-thru",
            "        default:"
          ],
          "context_after": [
            "            break;",
            "        }",
            "",
            "        if (nameToken.type == TokenType::LParent)",
            "            return NameLoc(getName(parser, \"()\"), nameToken.loc);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20011,
      "severity": "Error",
      "name": "unexpectedColon",
      "message": "unexpected ':'.",
      "line": 518,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 20012,
      "severity": "Error",
      "name": "invalidSPIRVVersion",
      "message": "Expecting SPIR-V version as either 'major.minor', or quoted if has patch (eg for SPIR-V 1.2, '1.2' or \\\"1.2\\\"')",
      "line": 519,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 9256,
          "statement": "parser->sink->diagnose(token, Diagnostics::invalidSPIRVVersion);",
          "context_before": [
            "    {",
            "        auto modifier = parser->astBuilder->create<RequiredSPIRVVersionModifier>();",
            "        modifier->version = version;",
            "        return modifier;",
            "    }"
          ],
          "context_after": [
            "    return nullptr;",
            "}",
            "",
            "static NodeBase* parseCUDASMVersionModifier(Parser* parser, void* /*userData*/)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20013,
      "severity": "Error",
      "name": "invalidCUDASMVersion",
      "message": "Expecting CUDA SM version as either 'major.minor', or quoted if has patch (eg for '7.0' or \\\"7.0\\\"')",
      "line": 525,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 9270,
          "statement": "parser->sink->diagnose(token, Diagnostics::invalidCUDASMVersion);",
          "context_before": [
            "    {",
            "        auto modifier = parser->astBuilder->create<RequiredCUDASMVersionModifier>();",
            "        modifier->version = version;",
            "        return modifier;",
            "    }"
          ],
          "context_after": [
            "    return nullptr;",
            "}",
            "",
            "static NodeBase* parseSharedModifier(Parser* parser, void* /*userData*/)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20014,
      "severity": "Error",
      "name": "classIsReservedKeyword",
      "message": "'class' is a reserved keyword in this context; use 'struct' instead.",
      "line": 531,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 20015,
      "severity": "Error",
      "name": "unknownSPIRVCapability",
      "message": "unknown SPIR-V capability '$0'.",
      "line": 536,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 20016,
      "severity": "Error",
      "name": "missingLayoutBindingModifier",
      "message": "Expecting 'binding' modifier in the layout qualifier here",
      "line": 537,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2263,
          "statement": "getSink()->diagnose(glslOffsetAttribute, Diagnostics::missingLayoutBindingModifier);",
          "context_before": [
            "                    glslOffsetAttribute->offset);",
            "            }",
            "        }",
            "        else",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    postProcessingOnModifiers(m_astBuilder, syntaxNode->modifiers);",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20017,
      "severity": "Error",
      "name": "constNotAllowedOnCStylePtrDecl",
      "message": "'const' not allowed on pointer typed declarations using the C style '*' operator. If the intent is to restrict the pointed-to value to read-only, use 'Ptr<T, Access.Read>'; if the intent is to make the pointer itself immutable, use 'let' or 'const Ptr<...>'.",
      "line": 542,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1730,
          "statement": "getSink()->diagnose(m, Diagnostics::constNotAllowedOnCStylePtrDecl);",
          "context_before": [
            "        if (auto varDeclBase = as<VarDeclBase>(syntaxNode))",
            "        {",
            "            if (as<PointerTypeExpr>(varDeclBase->type.exp))",
            "            {",
            "                // Disallow `const T*` syntax."
          ],
          "context_after": [
            "                return nullptr;",
            "            }",
            "        }",
            "    }",
            "    if (auto glslLayoutAttribute = as<UncheckedGLSLLayoutAttribute>(m))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20018,
      "severity": "Error",
      "name": "constNotAllowedOnType",
      "message": "cannot use 'const' as a type modifier",
      "line": 549,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6273,
          "statement": "getSink()->diagnose(modifier, Diagnostics::constNotAllowedOnType);",
          "context_before": [
            "    {",
            "        return m_astBuilder->getNoDiffModifierVal();",
            "    }",
            "    else if (as<ConstModifier>(modifier))",
            "    {"
          ],
          "context_after": [
            "        return nullptr;",
            "    }",
            "    else",
            "    {",
            "        // TODO: more complete error message here"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20101,
      "severity": "Warning",
      "name": "unintendedEmptyStatement",
      "message": "potentially unintended empty statement at this location; use {} instead.",
      "line": 551,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 6268,
          "statement": "sink->diagnose(tokenReader.peekLoc(), Diagnostics::unintendedEmptyStatement);",
          "context_before": [
            "        if (as<IfStmt>(parentStmt))",
            "        {",
            "            // An empty statement after an `if` is probably a mistake,",
            "            // so we will diagnose it as such.",
            "            //"
          ],
          "context_after": [
            "        }",
            "        statement = astBuilder->create<EmptyStmt>();",
            "        FillPosition(statement);",
            "        ReadToken(TokenType::Semicolon);",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 20102,
      "severity": "Error",
      "name": "unexpectedBodyAfterSemicolon",
      "message": "unexpected function body after signature declaration, is this ';' a typo?",
      "line": 556,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 1847,
          "statement": "parser->sink->diagnose(semiColonToken.loc, Diagnostics::unexpectedBodyAfterSemicolon);",
          "context_before": [
            "        // empty body",
            "        // if we see a `{` after a `;`, it is very likely an user error to",
            "        // have the `;`, so we will provide a better diagnostic for it.",
            "        if (peekTokenType(parser) == TokenType::LBrace)",
            "        {"
          ],
          "context_after": [
            "",
            "            // Fall through to parse the block stmt.",
            "        }",
            "        else",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30102,
      "severity": "Error",
      "name": "declNotAllowed",
      "message": "$0 is not allowed here.",
      "line": 561,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5029,
          "statement": "parser->sink->diagnose(decl->loc, Diagnostics::declNotAllowed, decl->astNodeType);",
          "context_before": [
            "        if (!isDeclAllowed(",
            "                parser->options.isInLanguageServer,",
            "                containerDecl->astNodeType,",
            "                decl->astNodeType))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            // For generic decls, we also need to check if the inner decl type is allowed to be",
            "            // nested here."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5044,
          "statement": "Diagnostics::declNotAllowed, declToModify->astNodeType);",
          "context_before": [
            "                        containerDecl->astNodeType,",
            "                        declToModify->astNodeType))",
            "                {",
            "                    parser->sink->diagnose(",
            "                        decl->loc,"
          ],
          "context_after": [
            "                        declToModify->astNodeType);",
            "                }",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 6446,
          "statement": "sink->diagnose(decl->loc, Diagnostics::declNotAllowed, decl->astNodeType);",
          "context_before": [
            "    else if (as<UsingDecl>(decl))",
            "    {",
            "    }",
            "    else",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return varDeclrStatement;",
            "}",
            "",
            "static Expr* constructIfLetPredicate(Parser* parser, VarExpr* varExpr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29000,
      "severity": "Error",
      "name": "snippetParsingFailed",
      "message": "unable to parse target intrinsic snippet: $0",
      "line": 564,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-spirv-legalize.cpp",
          "line": 2467,
          "statement": "m_sink->diagnose(intrinsic, Diagnostics::snippetParsingFailed, intrinsic->getDefinition());",
          "context_before": [
            "        return snippet.Ptr();",
            "    }",
            "    snippet = SpvSnippet::parse(*m_grammarInfo, intrinsic->getDefinition());",
            "    if (!snippet)",
            "    {"
          ],
          "context_after": [
            "        return nullptr;",
            "    }",
            "    m_parsedSpvSnippets[intrinsic] = snippet;",
            "    return snippet;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29100,
      "severity": "Error",
      "name": "unrecognizedSPIRVOpcode",
      "message": "unrecognized spirv opcode: $0",
      "line": 566,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8618,
          "statement": "Diagnostics::unrecognizedSPIRVOpcode, ret.opcode.token);",
          "context_before": [
            "    // an error",
            "    if (!opInfo && resultOperand)",
            "    {",
            "        parser->diagnose(",
            "            resultOperand->token,"
          ],
          "context_after": [
            "            ret.opcode.token);",
            "        return std::nullopt;",
            "    }",
            "",
            "    // If we have an explicit result operand (because this was a `x ="
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8718,
          "statement": "Diagnostics::unrecognizedSPIRVOpcode, ret.opcode.token);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            parser->diagnose(",
            "                ret.opcode.token,"
          ],
          "context_after": [
            "                ret.opcode.token);",
            "            return std::nullopt;",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29101,
      "severity": "Error",
      "name": "misplacedResultIdMarker",
      "message": "the result-id marker must only be used in the last instruction of a spriv_asm expression",
      "line": 567,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6455,
          "statement": "getSink()->diagnose(operand.token, Diagnostics::misplacedResultIdMarker);",
          "context_before": [
            "",
            "                    // TODO: We could consider relaxing this, because SPIR-V",
            "                    // does have forward references for decorations and such",
            "                    if (!isLast)",
            "                    {"
          ],
          "context_after": [
            "                        getSink()->diagnoseWithoutSourceView(",
            "                            expr,",
            "                            Diagnostics::considerOpCopyObject);",
            "                    }",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "considerOpCopyObject"
          ]
        }
      ]
    },
    {
      "id": 29104,
      "severity": "Error",
      "name": "spirvInstructionWithoutResultId",
      "message": "cannot use this 'x = $0...' syntax because $0 does not have a <result-id> operand",
      "line": 578,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8629,
          "statement": "Diagnostics::spirvInstructionWithoutResultId, ret.opcode.token);",
          "context_before": [
            "    // OpFoo` instruction) then diagnose if we don't know where to put it",
            "    if (resultOperand && opInfo && opInfo->resultIdIndex == -1)",
            "    {",
            "        parser->diagnose(",
            "            resultOperand->token,"
          ],
          "context_after": [
            "            ret.opcode.token);",
            "        return std::nullopt;",
            "    }",
            "",
            "    // Likewise for the type"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29105,
      "severity": "Error",
      "name": "spirvInstructionWithoutResultTypeId",
      "message": "cannot use this 'x : <type> = $0...' syntax because $0 does not have a <result-type-id> operand",
      "line": 583,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8639,
          "statement": "Diagnostics::spirvInstructionWithoutResultTypeId, ret.opcode.token);",
          "context_before": [
            "    // Likewise for the type",
            "    if (resultTypeOperand && opInfo && opInfo->resultTypeIndex == -1)",
            "    {",
            "        parser->diagnose(",
            "            resultTypeOperand->token,"
          ],
          "context_after": [
            "            ret.opcode.token);",
            "    }",
            "",
            "    //",
            "    // Now we've parsed the tricky preamble, grab the rest of the operands"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29106,
      "severity": "Warning",
      "name": "spirvInstructionWithTooManyOperands",
      "message": "too many operands for $0 (expected max $1), did you forget a semicolon?",
      "line": 590,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8682,
          "statement": "Diagnostics::spirvInstructionWithTooManyOperands, ret.opcode.token, opInfo->maxOperandCount);",
          "context_before": [
            "                token.type == TokenType::OpMod && (parser->LookAheadToken(TokenType::OpAssign, 2) ||",
            "                                                   parser->LookAheadToken(TokenType::Colon, 2)))",
            "            {",
            "                parser->diagnose(",
            "                    parser->tokenReader.peekLoc(),"
          ],
          "context_after": [
            "                    ret.opcode.token,",
            "                    opInfo->maxOperandCount);",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6353,
          "statement": "Diagnostics::spirvInstructionWithTooManyOperands, inst.opcode.token, 0);",
          "context_before": [
            "        if (opInfo && opInfo->numOperandTypes == 0 && inst.operands.getCount())",
            "        {",
            "            failed = true;",
            "            getSink()->diagnose(",
            "                inst.opcode.token,"
          ],
          "context_after": [
            "                inst.opcode.token,",
            "                0);",
            "            continue;",
            "        }",
            "        int resultIdIndex = -1;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29107,
      "severity": "Error",
      "name": "spirvUnableToResolveName",
      "message": "unknown SPIR-V identifier $0, it's not a known enumerator or opcode",
      "line": 595,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6489,
          "statement": "Diagnostics::spirvUnableToResolveName, operand.token.getContent());",
          "context_before": [
            "                    if (!enumValue)",
            "                    {",
            "                        failed = true;",
            "                        getSink()->diagnose(",
            "                            operand.token,"
          ],
          "context_after": [
            "                            operand.token.getContent());",
            "                        return;",
            "                    }",
            "",
            "                    operand.knownValue = *enumValue;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6509,
          "statement": "Diagnostics::spirvUnableToResolveName, operand.token.getContent());",
          "context_before": [
            "                    if (!builtinVarKind)",
            "                    {",
            "                        failed = true;",
            "                        getSink()->diagnose(",
            "                            operand.token,"
          ],
          "context_after": [
            "                            operand.token.getContent());",
            "                        return;",
            "                    }",
            "                    operand.knownValue = builtinVarKind.value();",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29108,
      "severity": "Error",
      "name": "spirvNonConstantBitwiseOr",
      "message": "only integer literals and enum names can appear in a bitwise or expression",
      "line": 600,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6532,
          "statement": "getSink()->diagnose(operand.token, Diagnostics::spirvNonConstantBitwiseOr);",
          "context_before": [
            "                if (operand.bitwiseOrWith.getCount() &&",
            "                    operand.flavor != SPIRVAsmOperand::Literal &&",
            "                    operand.flavor != SPIRVAsmOperand::NamedValue)",
            "                {",
            "                    failed = true;"
          ],
          "context_after": [
            "                }",
            "                for (auto& o : operand.bitwiseOrWith)",
            "                {",
            "                    if (o.flavor != SPIRVAsmOperand::Literal &&",
            "                        o.flavor != SPIRVAsmOperand::NamedValue)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6540,
          "statement": "getSink()->diagnose(operand.token, Diagnostics::spirvNonConstantBitwiseOr);",
          "context_before": [
            "                {",
            "                    if (o.flavor != SPIRVAsmOperand::Literal &&",
            "                        o.flavor != SPIRVAsmOperand::NamedValue)",
            "                    {",
            "                        failed = true;"
          ],
          "context_after": [
            "                    }",
            "                    go(go, o);",
            "                    operand.knownValue |= o.knownValue;",
            "                }",
            "            };"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29109,
      "severity": "Error",
      "name": "spirvOperandRange",
      "message": "Literal ints must be in the range 0 to 0xffffffff",
      "line": 605,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8525,
          "statement": "parser->diagnose(tok, Diagnostics::spirvOperandRange);",
          "context_before": [
            "    else if (parser->LookAheadToken(TokenType::IntegerLiteral))",
            "    {",
            "        const auto tok = parser->ReadToken();",
            "        const auto v = getIntegerLiteralValue(tok, parser->sink);",
            "        if (v < 0 || v > 0xffffffff)"
          ],
          "context_after": [
            "        return SPIRVAsmOperand{SPIRVAsmOperand::Literal, tok, nullptr, {}, SpvWord(v)};",
            "    }",
            "    // A literal string",
            "    else if (parser->LookAheadToken(TokenType::StringLiteral))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29110,
      "severity": "Error",
      "name": "unknownTargetName",
      "message": "unknown target name '$0'",
      "line": 607,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5872,
          "statement": "Diagnostics::unknownTargetName, caseName.getContent());",
          "context_before": [
            "                auto cap = findCapabilityName(caseName.getContent());",
            "                if (caseName.getContent().getLength() && cap == CapabilityName::Invalid)",
            "                {",
            "                    parser->sink->diagnose(",
            "                        caseName.loc,"
          ],
          "context_after": [
            "                        caseName.getContent());",
            "                }",
            "                targetCase->capability = (int32_t)cap;",
            "                targetCase->capabilityToken = caseName;",
            "                targetCase->loc = caseName.loc;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29111,
      "severity": "Error",
      "name": "spirvInvalidTruncate",
      "message": "__truncate has been given a source smaller than its target",
      "line": 609,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 9987,
          "statement": "m_sink->diagnose(inst, Diagnostics::spirvInvalidTruncate);",
          "context_before": [
            "                    const auto toVector = cast<IRVectorType>(unwrapAttributedType(toType));",
            "                    const auto toVectorSize = getIntVal(toVector->getElementCount());",
            "                    const auto fromVector = cast<IRVectorType>(unwrapAttributedType(fromType));",
            "                    const auto fromVectorSize = getIntVal(fromVector->getElementCount());",
            "                    if (toVectorSize > fromVectorSize)"
          ],
          "context_after": [
            "                    last = emitInstCustomOperandFunc(",
            "                        parent,",
            "                        isLast ? as<IRInst>(inst) : spvInst,",
            "                        SpvOpVectorShuffle,",
            "                        [&]()"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29112,
      "severity": "Error",
      "name": "spirvInstructionWithNotEnoughOperands",
      "message": "not enough operands for $0",
      "line": 614,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6388,
          "statement": "Diagnostics::spirvInstructionWithNotEnoughOperands, inst.opcode.token);",
          "context_before": [
            "            if (inst.operands.getCount() <= resultIdIndex)",
            "            {",
            "                failed = true;",
            "                getSink()->diagnose(",
            "                    inst.opcode.token,"
          ],
          "context_after": [
            "                    inst.opcode.token);",
            "                continue;",
            "            }",
            "            auto& resultIdOperand = inst.operands[resultIdIndex];",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29113,
      "severity": "Error",
      "name": "spirvIdRedefinition",
      "message": "SPIRV id '%$0' is already defined in the current assembly block",
      "line": 615,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6399,
          "statement": "Diagnostics::spirvIdRedefinition, inst.opcode.token);",
          "context_before": [
            "            if (!definedIds.add(resultIdOperand.token.getName()))",
            "            {",
            "                failed = true;",
            "                getSink()->diagnose(",
            "                    inst.opcode.token,"
          ],
          "context_after": [
            "                    inst.opcode.token);",
            "                continue;",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29114,
      "severity": "Error",
      "name": "spirvUndefinedId",
      "message": "SPIRV id '%$0' is not defined in the current assembly block location",
      "line": 620,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6522,
          "statement": "Diagnostics::spirvUndefinedId, operand.token);",
          "context_before": [
            "                    if (!definedIds.contains(operand.token.getName()))",
            "                    {",
            "                        failed = true;",
            "                        getSink()->diagnose(",
            "                            operand.token,"
          ],
          "context_after": [
            "                            operand.token);",
            "                        return;",
            "                    }",
            "                }",
            "                if (operand.bitwiseOrWith.getCount() &&"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 29115,
      "severity": "Error",
      "name": "targetSwitchCaseCannotBeAStage",
      "message": "cannot use a stage name in '__target_switch', use '__stage_switch' for stage-specific code.",
      "line": 626,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 460,
          "statement": "Diagnostics::targetSwitchCaseCannotBeAStage);",
          "context_before": [
            "        {",
            "            if (isStage)",
            "            {",
            "                getSink()->diagnose(",
            "                    caseStmt->capabilityToken.loc,"
          ],
          "context_after": [
            "            }",
            "            else if (",
            "                caseStmt->capabilityToken.getContentLength() != 0 &&",
            "                (set.getCapabilityTargetSets().getCount() != 1 || set.isInvalid() || set.isEmpty()))",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30002,
      "severity": "Error",
      "name": "divideByZero",
      "message": "divide by zero",
      "line": 635,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-sccp.cpp",
          "line": 987,
          "statement": "shared->sink->diagnose(inst->sourceLoc, Diagnostics::divideByZero);",
          "context_before": [
            "                    {",
            "                        auto c = as<IRConstant>(divisor.value);",
            "                        if (c->value.intVal == 0)",
            "                        {",
            "                            if (shared->sink)"
          ],
          "context_after": [
            "                            return LatticeVal::getAny();",
            "                        }",
            "                    }",
            "                }",
            "                return evalDiv(inst->getDataType(), getLatticeVal(inst->getOperand(0)), divisor);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-sccp.cpp",
          "line": 1007,
          "statement": "shared->sink->diagnose(inst->sourceLoc, Diagnostics::divideByZero);",
          "context_before": [
            "                    {",
            "                        auto c = as<IRConstant>(divisor.value);",
            "                        if (c->value.intVal == 0)",
            "                        {",
            "                            if (shared->sink)"
          ],
          "context_after": [
            "                            return LatticeVal::getAny();",
            "                        }",
            "                    }",
            "                }",
            "                return evalRem(inst->getDataType(), getLatticeVal(inst->getOperand(0)), divisor);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ast-val.cpp",
          "line": 1653,
          "statement": "sink->diagnose(newFuncDecl.getLoc(), Diagnostics::divideByZero); \\",
          "context_before": [
            "    if (opNameSlice == toSlice(#op))                                             \\",
            "    {                                                                            \\",
            "        if (constArgs[1]->getValue() == 0)                                       \\",
            "        {                                                                        \\",
            "            if (sink)                                                            \\"
          ],
          "context_after": [
            "            return nullptr;                                                      \\",
            "        }                                                                        \\",
            "        resultValue = constArgs[0]->getValue() op constArgs[1]->getValue();      \\",
            "    }                                                                            \\",
            "    else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30003,
      "severity": "Error",
      "name": "breakOutsideLoop",
      "message": "'break' must appear inside loop or switch constructs.",
      "line": 636,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 197,
          "statement": "getSink()->diagnose(stmt, Diagnostics::breakOutsideLoop);",
          "context_before": [
            "        // enclosing statement that is a valid `break` target.",
            "        //",
            "        targetOuterStmt = FindOuterStmt<BreakableStmt>();",
            "        if (!targetOuterStmt)",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    // We do not (currently) allow a `break` to proceed \"through\"",
            "    // an enclosing `defer` statement. Thus, we search for"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30004,
      "severity": "Error",
      "name": "continueOutsideLoop",
      "message": "'continue' must appear inside loop constructs.",
      "line": 637,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 231,
          "statement": "getSink()->diagnose(stmt, Diagnostics::continueOutsideLoop);",
          "context_before": [
            "void SemanticsStmtVisitor::visitContinueStmt(ContinueStmt* stmt)",
            "{",
            "    auto targetOuterStmt = FindOuterStmt<LoopStmt>();",
            "    if (!targetOuterStmt)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    else",
            "    {",
            "        if (FindOuterStmt<DeferStmt>(targetOuterStmt))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30005,
      "severity": "Error",
      "name": "whilePredicateTypeError",
      "message": "'while': expression must evaluate to int.",
      "line": 638,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30006,
      "severity": "Error",
      "name": "ifPredicateTypeError",
      "message": "'if': expression must evaluate to int.",
      "line": 639,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30006,
      "severity": "Error",
      "name": "returnNeedsExpression",
      "message": "'return' should have an expression.",
      "line": 640,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 567,
          "statement": "getSink()->diagnose(stmt, Diagnostics::returnNeedsExpression);",
          "context_before": [
            "    if (!stmt->expression)",
            "    {",
            "        if (expectedReturnType && !expectedReturnType->equals(m_astBuilder->getVoidType()) &&",
            "            !as<ConstructorDecl>(function))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else",
            "    {",
            "        stmt->expression = CheckTerm(stmt->expression);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30007,
      "severity": "Error",
      "name": "componentReturnTypeMismatch",
      "message": "expression type '$0' does not match component's type '$1'",
      "line": 641,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30007,
      "severity": "Error",
      "name": "functionReturnTypeMismatch",
      "message": "expression type '$0' does not match function's return type '$1'",
      "line": 646,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30008,
      "severity": "Error",
      "name": "variableNameAlreadyDefined",
      "message": "variable $0 already defined.",
      "line": 651,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30009,
      "severity": "Error",
      "name": "invalidTypeVoid",
      "message": "invalid type 'void'.",
      "line": 652,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 439,
          "statement": "getSink()->diagnose(result.exp, Diagnostics::invalidTypeVoid);",
          "context_before": [
            "    {",
            "        // TODO: `void` shouldn't be a basic type, to make this easier to avoid",
            "        if (basicType->getBaseType() == BaseType::Void)",
            "        {",
            "            // TODO(tfoley): pick the right diagnostic message"
          ],
          "context_after": [
            "            result.type = m_astBuilder->getErrorType();",
            "            return result;",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2208,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::invalidTypeVoid);",
          "context_before": [
            "        SemanticsVisitor subVisitor(withDeclToExcludeFromLookup(varDecl));",
            "        TypeExp typeExp = subVisitor.CheckUsableType(varDecl->type, varDecl);",
            "        varDecl->type = typeExp;",
            "        if (varDecl->type.equals(m_astBuilder->getVoidType()))",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        // If this is an unsized array variable, then we first want to give",
            "        // it a chance to infer an array size from its initializer",
            "        //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30010,
      "severity": "Error",
      "name": "whilePredicateTypeError2",
      "message": "'while': expression must evaluate to int.",
      "line": 653,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30011,
      "severity": "Error",
      "name": "assignNonLValue",
      "message": "left of '=' is not an l-value.",
      "line": 654,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2838,
          "statement": "getSink()->diagnose(expr, Diagnostics::assignNonLValue);",
          "context_before": [
            "        else",
            "        {",
            "            // Provide a more helpful diagnostic about const variable assignment",
            "            maybeDiagnoseConstVariableAssignment(expr->left);",
            ""
          ],
          "context_after": [
            "        }",
            "    }",
            "    expr->type = type;",
            "    return expr;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30012,
      "severity": "Error",
      "name": "noApplicationUnaryOperator",
      "message": "no overload found for operator $0 ($1).",
      "line": 655,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30012,
      "severity": "Error",
      "name": "noOverloadFoundForBinOperatorOnTypes",
      "message": "no overload found for operator $0  ($1, $2).",
      "line": 656,
      "param_count": 3,
      "call_sites": []
    },
    {
      "id": 30013,
      "severity": "Error",
      "name": "subscriptNonArray",
      "message": "no subscript operation found for type '$0'",
      "line": 661,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2722,
          "statement": "getSink()->diagnose(subscriptExpr, Diagnostics::subscriptNonArray, baseType);",
          "context_before": [
            "    if (!lookupResult.isValid())",
            "    {",
            "        if (!diagnosed)",
            "        {",
            "            if (!maybeDiagnoseAmbiguousReference(baseExpr))"
          ],
          "context_after": [
            "        }",
            "        return CreateErrorExpr(subscriptExpr);",
            "    }",
            "    auto subscriptFuncExpr = createLookupResultExpr(",
            "        operatorName,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30014,
      "severity": "Error",
      "name": "subscriptIndexNonInteger",
      "message": "index expression must evaluate to int.",
      "line": 662,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30016,
      "severity": "Error",
      "name": "callOperatorNotFound",
      "message": "no call operation found for type '$0'",
      "line": 663,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3395,
          "statement": "getSink()->diagnose(expr, Diagnostics::callOperatorNotFound, baseType);",
          "context_before": [
            "        lookupResult =",
            "            filterLookupResultByVisibilityAndDiagnose(lookupResult, expr->loc, diagnosed);",
            "        if (!lookupResult.isValid())",
            "        {",
            "            if (!diagnosed)"
          ],
          "context_after": [
            "            return CreateErrorExpr(expr);",
            "        }",
            "        auto callFuncExpr = createLookupResultExpr(",
            "            operatorName,",
            "            lookupResult,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30015,
      "severity": "Error",
      "name": "undefinedIdentifier2",
      "message": "undefined identifier '$0'.",
      "line": 664,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1893,
          "statement": "Diagnostics::undefinedIdentifier2, targetIntrinsic->scrutinee.name);",
          "context_before": [
            "                    genDecl->ownedScope);",
            "                if (!scrutineeResults.isValid())",
            "                {",
            "                    getSink()->diagnose(",
            "                        targetIntrinsic->scrutinee.loc,"
          ],
          "context_after": [
            "                        targetIntrinsic->scrutinee.name);",
            "                }",
            "                if (scrutineeResults.isOverloaded())",
            "                {",
            "                    getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3513,
          "statement": "getSink()->diagnose(expr, Diagnostics::undefinedIdentifier2, expr->name);",
          "context_before": [
            "            return maybeRegisterLambdaCapture(lookupResultExpr);",
            "        return lookupResultExpr;",
            "    }",
            "",
            "    if (!diagnosed)"
          ],
          "context_after": [
            "",
            "    return resultExpr;",
            "}",
            "",
            "Expr* SemanticsExprVisitor::maybeRegisterLambdaCapture(Expr* exprIn)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1361,
          "statement": "sink->diagnose(loc, Diagnostics::undefinedIdentifier2, declRef.getName());",
          "context_before": [
            "        // this as an undefined identifier.",
            "        //",
            "        // TODO: This code could break if we ever go down this path with",
            "        // an identifier that doesn't have a name.",
            "        //"
          ],
          "context_after": [
            "    }",
            "    return QualType(astBuilder->getErrorType());",
            "}",
            "",
            "QualType getTypeForDeclRef(ASTBuilder* astBuilder, DeclRef<Decl> declRef, SourceLoc loc)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30019,
      "severity": "Error",
      "name": "typeMismatch",
      "message": "expected an expression of type '$0', got '$1'",
      "line": 665,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1024,
          "statement": "sink->diagnose(fromExpr->loc, Diagnostics::typeMismatch, toType, fromExpr->type);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            if (sink)",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "    return false;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1983,
          "statement": "sink->diagnose(fromExpr, Diagnostics::typeMismatch, toType, fromType);",
          "context_before": [
            "        {",
            "            if (cost >= kConversionCost_Explicit)",
            "            {",
            "                if (sink)",
            "                {"
          ],
          "context_after": [
            "                    sink->diagnoseWithoutSourceView(",
            "                        fromExpr,",
            "                        Diagnostics::noteExplicitConversionPossible,",
            "                        fromType,",
            "                        toType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "noteExplicitConversionPossible"
          ]
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1564,
          "statement": "Diagnostics::typeMismatch, diffType, declRefExpr->type);",
          "context_before": [
            "        derivativeMemberAttr->memberDeclRef = declRefExpr;",
            "        if (!diffType->equals(declRefExpr->type))",
            "        {",
            "            getSink()->diagnose(",
            "                derivativeMemberAttr,"
          ],
          "context_after": [
            "                diffType,",
            "                declRefExpr->type);",
            "        }",
            "        if (!varDecl->parentDecl)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4075,
          "statement": "Diagnostics::typeMismatch, \"uint3\", expr->threadGroupSize->type);",
          "context_before": [
            "    expr->threadGroupSize = dispatchExpr(expr->threadGroupSize, *this);",
            "    if (!isInt3Type(expr->threadGroupSize->type.type))",
            "    {",
            "        getSink()->diagnose(",
            "            expr->threadGroupSize,"
          ],
          "context_after": [
            "            \"uint3\",",
            "            expr->threadGroupSize->type);",
            "    }",
            "    expr->dispatchSize = dispatchExpr(expr->dispatchSize, *this);",
            "    if (!isInt3Type(expr->dispatchSize->type.type))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4084,
          "statement": "Diagnostics::typeMismatch, \"uint3\", expr->dispatchSize->type);",
          "context_before": [
            "    expr->dispatchSize = dispatchExpr(expr->dispatchSize, *this);",
            "    if (!isInt3Type(expr->dispatchSize->type.type))",
            "    {",
            "        getSink()->diagnose(",
            "            expr->dispatchSize,"
          ],
          "context_after": [
            "            \"uint3\",",
            "            expr->dispatchSize->type);",
            "    }",
            "    PassthroughHighOrderExprCheckingActionsBase<DispatchKernelExpr> actions;",
            "    return _checkHigherOrderInvokeExpr(this, expr, &actions);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4128,
          "statement": "getSink()->diagnose(expr, Diagnostics::typeMismatch, \"array\", expr->arrayExpr->type);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        if (!as<ErrorType>(expr->arrayExpr->type))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        expr->type = m_astBuilder->getErrorType();",
            "    }",
            "    return expr;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30021,
      "severity": "Error",
      "name": "noApplicationFunction",
      "message": "$0: no overload takes arguments ($1)",
      "line": 666,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30022,
      "severity": "Error",
      "name": "invalidTypeCast",
      "message": "invalid type cast between \\\"$0\\\" and \\\"$1\\\".",
      "line": 667,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30023,
      "severity": "Error",
      "name": "typeHasNoPublicMemberOfName",
      "message": "\\\"$0\\\" does not have public member \\\"$1\\\".",
      "line": 668,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 30024,
      "severity": "Error",
      "name": "cannotConvertArrayOfSmallerToLargerSize",
      "message": "Cannot convert array of size $0 to array of size $1 as this would truncate data",
      "line": 669,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1931,
          "statement": "Diagnostics::cannotConvertArrayOfSmallerToLargerSize, fromSize, toSize);",
          "context_before": [
            "                    auto fromSize = getIntVal(declaredArraySize);",
            "                    if (toSize < fromSize)",
            "                    {",
            "                        context->getSink()->diagnose(",
            "                            userDeclaredParamVarLayout,"
          ],
          "context_after": [
            "                            fromSize,",
            "                            toSize);",
            "                    }",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30025,
      "severity": "Error",
      "name": "invalidArraySize",
      "message": "array size must be non-negative.",
      "line": 674,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2668,
          "statement": "Diagnostics::invalidArraySize);",
          "context_before": [
            "            {",
            "                if (constElementCount->getValue() < 0)",
            "                {",
            "                    getSink()->diagnose(",
            "                        subscriptExpr->indexExprs[0],"
          ],
          "context_after": [
            "                    return CreateErrorExpr(subscriptExpr);",
            "                }",
            "            }",
            "        }",
            "        else if (subscriptExpr->indexExprs.getCount() != 0)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4121,
          "statement": "getSink()->diagnose(expr, Diagnostics::invalidArraySize);",
          "context_before": [
            "    if (auto arrType = as<ArrayExpressionType>(expr->arrayExpr->type))",
            "    {",
            "        expr->type = m_astBuilder->getIntType();",
            "        if (arrType->isUnsized())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else",
            "    {",
            "        if (!as<ErrorType>(expr->arrayExpr->type))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10434,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::invalidArraySize);",
          "context_before": [
            "    {",
            "        // Note(tfoley): For now we allow arrays of unspecified size",
            "        // everywhere, because some source languages (e.g., GLSL)",
            "        // allow them in specific cases.",
            "#if 0"
          ],
          "context_after": [
            "#endif",
            "        return;",
            "    }",
            "",
            "    // TODO(tfoley): How to handle the case where bound isn't known?"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10443,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::invalidArraySize);",
          "context_before": [
            "",
            "    // TODO(tfoley): How to handle the case where bound isn't known?",
            "    auto elementCount = arrayType->getElementCount();",
            "    if (GetMinBound(elementCount) < 0)",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    if (elementCount->isLinkTimeVal())",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30027,
      "severity": "Error",
      "name": "disallowedArrayOfNonAddressableType",
      "message": "Arrays of non-addressable type '$0' are not allowed",
      "line": 675,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10465,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::disallowedArrayOfNonAddressableType, elementType);",
          "context_before": [
            "",
            "    // Check if the element type has the NonAddressable tag",
            "    TypeTag elementTags = getTypeTags(elementType);",
            "    if ((int)elementTags & (int)TypeTag::NonAddressable)",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "}",
            "",
            "bool getExtensionTargetDeclList("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30028,
      "severity": "Error",
      "name": "nonAddressableTypeInStructuredBuffer",
      "message": "'$0' is non-addressable and cannot be used in StructuredBuffer",
      "line": 681,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14959,
          "statement": "Diagnostics::nonAddressableTypeInStructuredBuffer, elementType);",
          "context_before": [
            "    TypeTag elementTags = visitor->getTypeTags(elementType);",
            "    if ((int)elementTags & (int)TypeTag::NonAddressable)",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            varDecl->loc,"
          ],
          "context_after": [
            "            elementType);",
            "    }",
            "}",
            "",
            "void diagnoseMissingCapabilityProvenance("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30029,
      "severity": "Error",
      "name": "arrayIndexOutOfBounds",
      "message": "array index '$0' is out of bounds for array of size '$1'.",
      "line": 686,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-out-of-bound-access.cpp",
          "line": 55,
          "statement": "sink->diagnose(inst, Diagnostics::arrayIndexOutOfBounds, indexValue, arraySizeValue);",
          "context_before": [
            "        IRIntegerValue arraySizeValue = arraySizeLit->getValue();",
            "",
            "        // Check bounds: index should be >= 0 and < arraySize",
            "        if (indexValue < 0 || indexValue >= arraySizeValue)",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    void processModule()",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30026,
      "severity": "Error",
      "name": "returnInComponentMustComeLast",
      "message": "'return' can only appear as the last statement in component definition.",
      "line": 691,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30027,
      "severity": "Error",
      "name": "noMemberOfNameInType",
      "message": "'$0' is not a member of '$1'.",
      "line": 696,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5727,
          "statement": "getSink()->diagnose(expr, Diagnostics::noMemberOfNameInType, expr->name, baseType);",
          "context_before": [
            "",
            "    expr->type = QualType(m_astBuilder->getErrorType());",
            "    if (!supressDiagnostic)",
            "    {",
            "        if (!maybeDiagnoseAmbiguousReference(GetBaseExpr(expr)))"
          ],
          "context_after": [
            "    }",
            "    return expr;",
            "}",
            "",
            "Expr* SemanticsVisitor::maybeInsertImplicitOpForMemberBase("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30028,
      "severity": "Error",
      "name": "forPredicateTypeError",
      "message": "'for': predicate expression must evaluate to bool.",
      "line": 697,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30030,
      "severity": "Error",
      "name": "projectionOutsideImportOperator",
      "message": "'project': invalid use outside import operator.",
      "line": 702,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30031,
      "severity": "Error",
      "name": "projectTypeMismatch",
      "message": "'project': expression must evaluate to record type '$0'.",
      "line": 707,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30033,
      "severity": "Error",
      "name": "invalidTypeForLocalVariable",
      "message": "cannot declare a local variable of this type.",
      "line": 712,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30035,
      "severity": "Error",
      "name": "componentOverloadTypeMismatch",
      "message": "'$0': type of overloaded component mismatches previous definition.",
      "line": 717,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30041,
      "severity": "Error",
      "name": "bitOperationNonIntegral",
      "message": "bit operation: operand must be integral type.",
      "line": 722,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30043,
      "severity": "Error",
      "name": "getStringHashRequiresStringLiteral",
      "message": "getStringHash parameter can only accept a string literal",
      "line": 723,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 30047,
      "severity": "Error",
      "name": "argumentExpectedLValue",
      "message": "argument passed to parameter '$0' must be l-value.",
      "line": 728,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3113,
          "statement": "Diagnostics::argumentExpectedLValue, pp);",
          "context_before": [
            "                                    }",
            "                                }",
            "",
            "                                getSink()->diagnose(",
            "                                    argExpr,"
          ],
          "context_after": [
            "                                    pp);",
            "",
            "",
            "                                if (implicitCastExpr)",
            "                                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30048,
      "severity": "Error",
      "name": "argumentHasMoreMemoryQualifiersThanParam",
      "message": "argument passed in to parameter has a memory qualifier the parameter type is missing: '$0'",
      "line": 733,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2944,
          "statement": "getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"coherent\");",
          "context_before": [
            "    if (paramMemMods)",
            "        paramQualifiers = paramMemMods->getMemoryQualifierBit();",
            "",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kCoherent &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kCoherent))"
          ],
          "context_after": [
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kReadOnly &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kReadOnly))",
            "        getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"readonly\");",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2947,
          "statement": "getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"readonly\");",
          "context_before": [
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kCoherent &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kCoherent))",
            "        getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"coherent\");",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kReadOnly &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kReadOnly))"
          ],
          "context_after": [
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly))",
            "        getSink()->diagnose(",
            "            arg,",
            "            Diagnostics::argumentHasMoreMemoryQualifiersThanParam,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2952,
          "statement": "Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"writeonly\");",
          "context_before": [
            "        getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"readonly\");",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kWriteOnly))",
            "        getSink()->diagnose(",
            "            arg,"
          ],
          "context_after": [
            "            \"writeonly\");",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kVolatile &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kVolatile))",
            "        getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"volatile\");",
            "    // dropping a `restrict` qualifier from arguments is allowed in GLSL with memory qualifiers"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2956,
          "statement": "getSink()->diagnose(arg, Diagnostics::argumentHasMoreMemoryQualifiersThanParam, \"volatile\");",
          "context_before": [
            "            arg,",
            "            Diagnostics::argumentHasMoreMemoryQualifiersThanParam,",
            "            \"writeonly\");",
            "    if (argQualifiers & MemoryQualifierSetModifier::Flags::kVolatile &&",
            "        !(paramQualifiers & MemoryQualifierSetModifier::Flags::kVolatile))"
          ],
          "context_after": [
            "    // dropping a `restrict` qualifier from arguments is allowed in GLSL with memory qualifiers",
            "}",
            "",
            "Expr* SemanticsVisitor::CheckInvokeExprWithCheckedOperands(InvokeExpr* expr)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30050,
      "severity": "Error",
      "name": "mutatingMethodOnImmutableValue",
      "message": "mutating method '$0' cannot be called on an immutable value",
      "line": 746,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 964,
          "statement": "Diagnostics::mutatingMethodOnImmutableValue, funcDeclRef.getName());",
          "context_before": [
            "            {",
            "                if (context.mode == OverloadResolveContext::Mode::ForReal)",
            "                {",
            "                    getSink()->diagnose(",
            "                        context.loc,"
          ],
          "context_after": [
            "                        funcDeclRef.getName());",
            "                    maybeDiagnoseConstVariableAssignment(context.baseExpr);",
            "                }",
            "                return false;",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30051,
      "severity": "Error",
      "name": "invalidValueForArgument",
      "message": "invalid value for argument '$0'",
      "line": 752,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30052,
      "severity": "Error",
      "name": "invalidSwizzleExpr",
      "message": "invalid swizzle pattern '$0' on type '$1'",
      "line": 753,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5309,
          "statement": "->diagnose(memberExpr, Diagnostics::invalidSwizzleExpr, swizzleText, baseTupleType);",
          "context_before": [
            "        elementCoord = (uint32_t)StringUtil::parseIntAndAdvancePos(span, pos);",
            "",
            "        if (elementCoord >= tupleElementCount)",
            "        {",
            "            getSink()"
          ],
          "context_after": [
            "            return CreateErrorExpr(memberExpr);",
            "        }",
            "",
            "        // Check if we've seen this index before",
            "        for (int ee = 0; ee < elementCoords.getCount(); ee++)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30053,
      "severity": "Error",
      "name": "breakLabelNotFound",
      "message": "label '$0' used as break target is not found.",
      "line": 754,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 170,
          "statement": "getSink()->diagnose(stmt, Diagnostics::breakLabelNotFound, stmt->targetLabel.getName());",
          "context_before": [
            "        // an outer statement matching that label.",
            "        //",
            "        auto foundOuterStmt = findOuterStmtWithLabel(stmt->targetLabel.getName());",
            "        if (!foundOuterStmt)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            // It is possible that the labelled statement",
            "            // is not a valid one for a `break` to target,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30054,
      "severity": "Error",
      "name": "targetLabelDoesNotMarkBreakableStmt",
      "message": "invalid break target: statement labeled '$0' is not breakable.",
      "line": 755,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 183,
          "statement": "Diagnostics::targetLabelDoesNotMarkBreakableStmt, stmt->targetLabel.getName());",
          "context_before": [
            "            targetOuterStmt = as<BreakableStmt>(foundOuterStmt);",
            "            if (!targetOuterStmt)",
            "            {",
            "                getSink()->diagnose(",
            "                    stmt,"
          ],
          "context_after": [
            "                    stmt->targetLabel.getName());",
            "            }",
            "        }",
            "    }",
            "    else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30055,
      "severity": "Error",
      "name": "useOfNonShortCircuitingOperatorInDiffFunc",
      "message": "non-short-circuiting `?:` operator is not allowed in a differentiable function, use `select` instead.",
      "line": 760,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3246,
          "statement": "getSink()->diagnose(expr->loc, Diagnostics::useOfNonShortCircuitingOperatorInDiffFunc);",
          "context_before": [
            "",
            "    if (getParentDifferentiableAttribute())",
            "    {",
            "        // If we are in a differentiable func, issue",
            "        // a diagnostic on use of non short-circuiting select."
          ],
          "context_after": [
            "    }",
            "    else",
            "    {",
            "        // For all other functions, we issue a warning for deprecation of vector-typed ?: operator.",
            "        getSink()->diagnose(expr->loc, Diagnostics::useOfNonShortCircuitingOperator);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30056,
      "severity": "Warning",
      "name": "useOfNonShortCircuitingOperator",
      "message": "non-short-circuiting `?:` operator is deprecated, use 'select' instead.",
      "line": 766,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3251,
          "statement": "getSink()->diagnose(expr->loc, Diagnostics::useOfNonShortCircuitingOperator);",
          "context_before": [
            "        getSink()->diagnose(expr->loc, Diagnostics::useOfNonShortCircuitingOperatorInDiffFunc);",
            "    }",
            "    else",
            "    {",
            "        // For all other functions, we issue a warning for deprecation of vector-typed ?: operator."
          ],
          "context_after": [
            "    }",
            "    return result;",
            "}",
            "",
            "Expr* SemanticsExprVisitor::convertToLogicOperatorExpr(InvokeExpr* expr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30057,
      "severity": "Error",
      "name": "assignmentInPredicateExpr",
      "message": "use an assignment operation as predicate expression is not allowed, wrap the assignment with '()' to clarify the intent.",
      "line": 771,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 252,
          "statement": "getSink()->diagnose(expr, Diagnostics::assignmentInPredicateExpr);",
          "context_before": [
            "",
            "Expr* SemanticsVisitor::checkPredicateExpr(Expr* expr)",
            "{",
            "    if (as<AssignExpr>(expr))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    Expr* e = expr;",
            "    e = CheckTerm(e);",
            "    e = coerce(CoercionSite::General, m_astBuilder->getBoolType(), e, getSink());",
            "    return e;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30058,
      "severity": "Warning",
      "name": "danglingEqualityExpr",
      "message": "result of '==' not used, did you intend '='?",
      "line": 777,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 679,
          "statement": "getSink()->diagnose(operatorExpr, Diagnostics::danglingEqualityExpr);",
          "context_before": [
            "    {",
            "        if (auto func = as<VarExpr>(operatorExpr->functionExpr))",
            "        {",
            "            if (func->name && func->name->text == \"==\")",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30060,
      "severity": "Error",
      "name": "expectedAType",
      "message": "expected a type, got a '$0'",
      "line": 779,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 127,
          "statement": "getSink()->diagnose(expr, Diagnostics::expectedAType, expr->type);",
          "context_before": [
            "    else if (const auto errorType = as<ErrorType>(expr->type))",
            "    {",
            "        return expr;",
            "    }",
            ""
          ],
          "context_after": [
            "    return CreateErrorExpr(expr);",
            "}",
            "",
            "Type* SemanticsVisitor::ExpectAType(Expr* expr)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 276,
          "statement": "Diagnostics::expectedAType, originalExpr->getClass().getName());",
          "context_before": [
            "                // diagnostic.",
            "",
            "                // Get the AST node type info, so we can output a 'got' name",
            "                diagSink->diagnose(",
            "                    originalExpr,"
          ],
          "context_after": [
            "                    originalExpr->getClass().getName());",
            "            }",
            "        }",
            "",
            "        if (outProperType)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30061,
      "severity": "Error",
      "name": "expectedANamespace",
      "message": "expected a namespace, got a '$0'",
      "line": 780,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11541,
          "statement": "getSink()->diagnose(decl->arg, Diagnostics::expectedANamespace, decl->arg->type);",
          "context_before": [
            "    }",
            "",
            "    if (!scopesAdded)",
            "    {",
            "        if (!hasValidNamespace)"
          ],
          "context_after": [
            "        return;",
            "    }",
            "}",
            "",
            "void SemanticsDeclScopeWiringVisitor::visitNamespaceDecl(NamespaceDecl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30065,
      "severity": "Error",
      "name": "newCanOnlyBeUsedToInitializeAClass",
      "message": "`new` can only be used to initialize a class",
      "line": 801,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 128,
          "statement": "getSink()->diagnose(context.originalExpr, Diagnostics::newCanOnlyBeUsedToInitializeAClass);",
          "context_before": [
            "        isNewExpr = true;",
            "    }",
            "",
            "    if (isNewExpr && !isClassType)",
            "    {"
          ],
          "context_after": [
            "        return false;",
            "    }",
            "    if (!isNewExpr && isClassType && context.originalExpr)",
            "    {",
            "        getSink()->diagnose(context.originalExpr, Diagnostics::classCanOnlyBeInitializedWithNew);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30066,
      "severity": "Error",
      "name": "classCanOnlyBeInitializedWithNew",
      "message": "a class can only be initialized by a `new` clause",
      "line": 806,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 133,
          "statement": "getSink()->diagnose(context.originalExpr, Diagnostics::classCanOnlyBeInitializedWithNew);",
          "context_before": [
            "        getSink()->diagnose(context.originalExpr, Diagnostics::newCanOnlyBeUsedToInitializeAClass);",
            "        return false;",
            "    }",
            "    if (!isNewExpr && isClassType && context.originalExpr)",
            "    {"
          ],
          "context_after": [
            "        return false;",
            "    }",
            "    return true;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30067,
      "severity": "Error",
      "name": "mutatingMethodOnFunctionInputParameterError",
      "message": "mutating method '$0' called on `in` parameter '$1'; changes will not be visible to caller. copy the parameter into a local variable if this behavior is intended",
      "line": 812,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 987,
          "statement": "isNonCopyable ? Diagnostics::mutatingMethodOnFunctionInputParameterError : Diagnostics::mutatingMethodOnFunctionInputParameterWarning;",
          "context_before": [
            "                if (auto paramDecl = isReferenceIntoFunctionInputParameter(context.baseExpr))",
            "                {",
            "                    const bool isNonCopyable = isNonCopyableType(paramDecl->getType());",
            "",
            "                    const auto& diagnotic ="
          ],
          "context_after": [
            "                                      : Diagnostics::mutatingMethodOnFunctionInputParameterWarning;",
            "",
            "                    getSink()->diagnose(",
            "                        context.loc,",
            "                        diagnotic,"
          ],
          "call_pattern": "unknown",
          "uses_notes": [
            "mutatingMethodOnFunctionInputParameterWarning"
          ]
        }
      ]
    },
    {
      "id": 30068,
      "severity": "Warning",
      "name": "mutatingMethodOnFunctionInputParameterWarning",
      "message": "mutating method '$0' called on `in` parameter '$1'; changes will not be visible to caller. copy the parameter into a local variable if this behavior is intended",
      "line": 818,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 988,
          "statement": ": Diagnostics::mutatingMethodOnFunctionInputParameterWarning;",
          "context_before": [
            "                {",
            "                    const bool isNonCopyable = isNonCopyableType(paramDecl->getType());",
            "",
            "                    const auto& diagnotic =",
            "                        isNonCopyable ? Diagnostics::mutatingMethodOnFunctionInputParameterError"
          ],
          "context_after": [
            "",
            "                    getSink()->diagnose(",
            "                        context.loc,",
            "                        diagnotic,",
            "                        funcDeclRef.getName(),"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30070,
      "severity": "Error",
      "name": "unsizedMemberMustAppearLast",
      "message": "member with unknown size at compile time can only appear as the last member in a composite type.",
      "line": 825,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2943,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::unsizedMemberMustAppearLast);",
          "context_before": [
            "",
            "                // At this point we've run into a non-`static` variable declaration",
            "                // that comes *after* the unsized variable declaration, which",
            "                // means the unsized variable declaration is invalid.",
            "                //"
          ],
          "context_after": [
            "                break;",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30071,
      "severity": "Error",
      "name": "varCannotBeUnsized",
      "message": "cannot instantiate a variable of unsized type.",
      "line": 831,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2958,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::varCannotBeUnsized);",
          "context_before": [
            "    if (isGlobalOrLocalVar)",
            "    {",
            "        bool isUnsized = (((int)varTypeTags & (int)TypeTag::Unsized) != 0);",
            "        if (isUnsized)",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        bool isOpaque = (((int)varTypeTags & (int)TypeTag::Opaque) != 0);",
            "        if (isOpaque && isGlobalDecl(varDecl) && !varDecl->hasModifier<ConstModifier>() &&",
            "            varDecl->hasModifier<HLSLStaticModifier>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30072,
      "severity": "Error",
      "name": "paramCannotBeUnsized",
      "message": "function parameter cannot be unsized.",
      "line": 832,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9745,
          "statement": "getSink()->diagnose(paramDecl, Diagnostics::paramCannotBeUnsized, paramDecl);",
          "context_before": [
            "    auto typeExpr = paramDecl->type;",
            "",
            "    if (!as<ArrayExpressionType>(paramDecl->type) &&",
            "        doesTypeHaveTag(paramDecl->type, TypeTag::Unsized))",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    // The \"initializer\" expression for a parameter represents",
            "    // a default argument value to use if an explicit one is",
            "    // not supplied."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30075,
      "severity": "Error",
      "name": "cannotSpecializeGeneric",
      "message": "cannot specialize generic '$0' with the provided arguments.",
      "line": 834,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 350,
          "statement": "Diagnostics::cannotSpecializeGeneric, candidate.item.declRef);",
          "context_before": [
            "    {",
            "        if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "        {",
            "            getSink()->diagnose(",
            "                context.loc,"
          ],
          "context_after": [
            "                candidate.item.declRef);",
            "        }",
            "    };",
            "    List<QualType> paramTypes;",
            "    for (auto memberRef : getMembers(m_astBuilder, genericDeclRef))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30076,
      "severity": "Error",
      "name": "globalVarCannotHaveOpaqueType",
      "message": "global variable cannot have opaque type.",
      "line": 840,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2966,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::globalVarCannotHaveOpaqueType);",
          "context_before": [
            "        bool isOpaque = (((int)varTypeTags & (int)TypeTag::Opaque) != 0);",
            "        if (isOpaque && isGlobalDecl(varDecl) && !varDecl->hasModifier<ConstModifier>() &&",
            "            varDecl->hasModifier<HLSLStaticModifier>())",
            "        {",
            "            // Opaque type global variable must be const."
          ],
          "context_after": [
            "            if (varDecl->initExpr)",
            "                getSink()->diagnose(varDecl, Diagnostics::doYouMeanStaticConst);",
            "            else",
            "                getSink()->diagnose(varDecl, Diagnostics::doYouMeanUniform);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "doYouMeanStaticConst"
          ]
        }
      ]
    },
    {
      "id": 30077,
      "severity": "Error",
      "name": "concreteArgumentToOutputInterface",
      "message": "argument passed to parameter '$0' is of concrete type '$1', but interface-typed output parameters require interface-typed arguments. To allow passing a concrete type to this function, you can replace '$2 $0' with a generic 'T $0' and a 'where T : $2' constraint.",
      "line": 841,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 789,
          "statement": "Diagnostics::concreteArgumentToOutputInterface, name, arg.type, paramType.type);",
          "context_before": [
            "                    else",
            "                        name.append(paramIndex, 10);",
            "",
            "                    getSink()->diagnose(",
            "                        context.loc,"
          ],
          "context_after": [
            "                        name,",
            "                        arg.type,",
            "                        paramType.type);",
            "                }",
            "                return {nullptr, nullptr};"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30078,
      "severity": "Error",
      "name": "coherentKeywordOnAPointer",
      "message": "cannot have a `globallycoherent T*` or a `coherent T*`, use explicit methods for coherent operations instead",
      "line": 850,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2417,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::coherentKeywordOnAPointer);",
          "context_before": [
            "    // Not allowed a `globallycoherent T*` or related",
            "    if (as<PtrType>(varDecl->type))",
            "        if (auto memoryQualifierSet = varDecl->findModifier<MemoryQualifierSetModifier>())",
            "            if (memoryQualifierSet->getMemoryQualifierBit() &",
            "                MemoryQualifierSetModifier::Flags::kCoherent)"
          ],
          "context_after": [
            "",
            "    // Check for static const variables without initializers",
            "    if (!varDecl->initExpr)",
            "    {",
            "        bool isStatic = false;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30079,
      "severity": "Error",
      "name": "cannotTakeConstantPointers",
      "message": "Not allowed to take the address of an immutable object",
      "line": 856,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3105,
          "statement": "Diagnostics::cannotTakeConstantPointers);",
          "context_before": [
            "                                            if (constantIntVal->getValue() ==",
            "                                                (int)KnownBuiltinDeclName::OperatorAddressOf)",
            "                                            {",
            "                                                getSink()->diagnose(",
            "                                                    argExpr,"
          ],
          "context_after": [
            "                                            }",
            "                                        }",
            "                                    }",
            "                                }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33180,
      "severity": "Error",
      "name": "cannotSpecializeGenericWithExistential",
      "message": "specializing '$0' with an existential type is not allowed. All generic arguments must be statically resolvable at compile time.",
      "line": 861,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-typeflow-specialize.cpp",
          "line": 4427,
          "statement": "Diagnostics::cannotSpecializeGenericWithExistential, as<IRSpecialize>(callee)->getBase());",
          "context_before": [
            "                    // In Slang 2025 and later, specializing a generic with multiple types is not",
            "                    // allowed, so we'll throw a diagnostic message.",
            "                    //",
            "                    sink->diagnose(",
            "                        inst->sourceLoc,"
          ],
          "context_after": [
            "                        as<IRSpecialize>(callee)->getBase());",
            "                    return false;",
            "                }",
            "                else",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30100,
      "severity": "Error",
      "name": "staticRefToNonStaticMember",
      "message": "type '$0' cannot be used to refer to non-static member '$1'",
      "line": 867,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 420,
          "statement": "Diagnostics::staticRefToNonStaticMember, typeType->getType(), declRef.getName());",
          "context_before": [
            "            expr->type = type;",
            "            if (getSink() && !isDeclUsableAsStaticMember(declRef.getDecl()))",
            "            {",
            "                getSink()->diagnose(",
            "                    loc,"
          ],
          "context_after": [
            "                    typeType->getType(),",
            "                    declRef.getName());",
            "                expr->type = m_astBuilder->getErrorType();",
            "            }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5627,
          "statement": "Diagnostics::staticRefToNonStaticMember, type, expr->name);",
          "context_before": [
            "                    else",
            "                    {",
            "                        // Otherwise, it is time to report an error.",
            "                        getSink()->diagnose(",
            "                            expr->loc,"
          ],
          "context_after": [
            "                            type,",
            "                            expr->name);",
            "                        hasErrors = true;",
            "                        return;",
            "                    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30101,
      "severity": "Error",
      "name": "cannotDereferenceType",
      "message": "cannot dereference type '$0', do you mean to use '.'?",
      "line": 872,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5886,
          "statement": "Diagnostics::cannotDereferenceType, expr->baseExpression->type);",
          "context_before": [
            "        // The user is trying to use the `->` operator on something that can't be",
            "        // dereferenced, so we should diagnose that.",
            "        if (!as<ErrorType>(expr->baseExpression->type))",
            "            getSink()->diagnose(",
            "                expr->memberOperatorLoc,"
          ],
          "context_after": [
            "                expr->baseExpression->type);",
            "    }",
            "",
            "    auto baseType = expr->baseExpression->type;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30102,
      "severity": "Error",
      "name": "staticRefToThis",
      "message": "static function cannot refer to non-static member `$0` via `this`",
      "line": 877,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 472,
          "statement": "getSink()->diagnose(loc, Diagnostics::staticRefToThis, declRef.getName());",
          "context_before": [
            "            // It's not valid to reference a non-static member with a static",
            "            // func using 'this'.",
            "            if (getSink() && m_parentFunc && m_parentFunc->hasModifier<HLSLStaticModifier>() &&",
            "                !isDeclUsableAsStaticMember(declRef.getDecl()) && as<ThisExpr>(baseExpr))",
            "            {"
          ],
          "context_after": [
            "                expr->type = m_astBuilder->getErrorType();",
            "            }",
            "",
            "            // When referring to a member through an expression,",
            "            // the result is only an l-value if both the base"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30200,
      "severity": "Error",
      "name": "redeclaration",
      "message": "declaration of '$0' conflicts with existing declaration",
      "line": 883,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9541,
          "statement": "getSink()->diagnose(newDecl, Diagnostics::redeclaration, newDecl->getName());",
          "context_before": [
            "    //   tell them apart at a use site.",
            "",
            "    // We will diagnose a redeclaration error at the new declaration,",
            "    // and point to the old declaration for context.",
            "    //"
          ],
          "context_after": [
            "    getSink()->diagnose(oldDecl, Diagnostics::seePreviousDeclarationOf, oldDecl->getName());",
            "    return SLANG_FAIL;",
            "}",
            "",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seePreviousDeclarationOf"
          ]
        }
      ]
    },
    {
      "id": 30201,
      "severity": "Error",
      "name": "functionRedefinition",
      "message": "function '$0' already has a body",
      "line": 884,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9451,
          "statement": "Diagnostics::functionRedefinition, newDecl->getName());",
          "context_before": [
            "                    // Redefinition",
            "                    if (!hasConflict)",
            "                    {",
            "                        getSink()->diagnose(",
            "                            newDecl,"
          ],
          "context_after": [
            "                            newDecl->getName());",
            "                    }",
            "",
            "                    auto prevDecl = *found;",
            "                    getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30202,
      "severity": "Error",
      "name": "functionRedeclarationWithDifferentReturnType",
      "message": "function '$0' declared to return '$1' was previously declared to return '$2'",
      "line": 885,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9375,
          "statement": "Diagnostics::functionRedeclarationWithDifferentReturnType, newDecl->getName(), resultType, prevResultType);",
          "context_before": [
            "    if (!resultType->equals(prevResultType))",
            "    {",
            "        // Bad redeclaration",
            "        getSink()->diagnose(",
            "            newDecl,"
          ],
          "context_after": [
            "            newDecl->getName(),",
            "            resultType,",
            "            prevResultType);",
            "        getSink()->diagnose(oldDecl, Diagnostics::seePreviousDeclarationOf, newDecl->getName());",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30300,
      "severity": "Error",
      "name": "isOperatorValueMustBeInterfaceType",
      "message": "'is'/'as' operator requires an interface-typed expression.",
      "line": 891,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4769,
          "statement": "getSink()->diagnose(expr, Diagnostics::isOperatorValueMustBeInterfaceType);",
          "context_before": [
            "    if (expr->witnessArg)",
            "    {",
            "        // For now we can only support the scenario where `expr->value` is an interface type.",
            "        if (!optionalWitness && !isInterfaceType(originalVal->type))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        return expr;",
            "    }",
            "    return expr;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4815,
          "statement": "getSink()->diagnose(expr, Diagnostics::isOperatorValueMustBeInterfaceType);",
          "context_before": [
            "    if (expr->witnessArg)",
            "    {",
            "        // For now we can only support the scenario where `expr->value` is an interface type.",
            "        if (!isInterfaceType(expr->value->type.type))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        expr->value = maybeOpenExistential(expr->value);",
            "        return expr;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30301,
      "severity": "Error",
      "name": "isOperatorCannotUseInterfaceAsRHS",
      "message": "cannot use 'is' operator with an interface type as the right-hand side without a corresponding optional constraint. Use a concrete type instead, or add an optional constraint for the interface type.",
      "line": 897,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4755,
          "statement": "getSink()->diagnose(expr, Diagnostics::isOperatorCannotUseInterfaceAsRHS);",
          "context_before": [
            "    // Check if the right-hand side type is an interface type. For 'is'",
            "    // statements, that's only allowed if it's related to an optional",
            "    // constraint.",
            "    if (isInterfaceType(expr->typeExpr.type) && !optionalWitness)",
            "    {"
          ],
          "context_after": [
            "        return expr;",
            "    }",
            "",
            "    // Otherwise, if the target type is a subtype of value->type, we need to grab the",
            "    // subtype witness for runtime checks."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30302,
      "severity": "Error",
      "name": "asOperatorCannotUseInterfaceAsRHS",
      "message": "cannot use 'as' operator with an interface type as the right-hand side. Use a concrete type instead. If you want to use an optional constraint, use an 'if (T is IInterface)' block instead.",
      "line": 905,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4785,
          "statement": "getSink()->diagnose(expr, Diagnostics::asOperatorCannotUseInterfaceAsRHS);",
          "context_before": [
            "    typeExpr = CheckProperType(typeExpr);",
            "",
            "    // Check if the right-hand side type is an interface type",
            "    if (isInterfaceType(typeExpr.type))",
            "    {"
          ],
          "context_after": [
            "        expr->type = m_astBuilder->getErrorType();",
            "        return expr;",
            "    }",
            "",
            "    expr->value = CheckTerm(expr->value);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33070,
      "severity": "Error",
      "name": "expectedFunction",
      "message": "expected a function, got '$0'",
      "line": 913,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 2763,
          "statement": "getSink()->diagnose(funcExpr->loc, Diagnostics::expectedFunction, funcExpr->type);",
          "context_before": [
            "            AddOverloadCandidate(context, candidate, baseCost + baseCost1);",
            "        }",
            "        else",
            "        {",
            "            // Unhandled case for the inner expr."
          ],
          "context_after": [
            "            funcExpr->type = this->getASTBuilder()->getErrorType();",
            "        }",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3195,
          "statement": "getSink()->diagnose(expr->functionExpr, Diagnostics::expectedFunction, funcExpr->type);",
          "context_before": [
            "        {",
            "            diagnoseAmbiguousReference(funcExpr);",
            "            return CreateErrorExpr(expr);",
            "        }",
            "    }"
          ],
          "context_after": [
            "    expr->type = QualType(m_astBuilder->getErrorType());",
            "    return expr;",
            "}",
            "",
            "void SemanticsVisitor::AddGenericOverloadCandidate("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3873,
          "statement": "Diagnostics::expectedFunction, funcExpr->type.type);",
          "context_before": [
            "        if (!baseFuncType)",
            "        {",
            "            resultDiffExpr->type = semantics->getASTBuilder()->getErrorType();",
            "            semantics->getSink()->diagnose(",
            "                funcExpr,"
          ],
          "context_after": [
            "                funcExpr->type.type);",
            "            return;",
            "        }",
            "        resultDiffExpr->type = semantics->getForwardDiffFuncType(baseFuncType);",
            "        if (auto declRefExpr = as<DeclRefExpr>(getInnerMostExprFromHigherOrderExpr(funcExpr)))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3914,
          "statement": "Diagnostics::expectedFunction, funcExpr->type.type);",
          "context_before": [
            "        if (!baseFuncType)",
            "        {",
            "            resultDiffExpr->type = semantics->getASTBuilder()->getErrorType();",
            "            semantics->getSink()->diagnose(",
            "                funcExpr,"
          ],
          "context_after": [
            "                funcExpr->type.type);",
            "            return;",
            "        }",
            "        resultDiffExpr->type = semantics->getBackwardDiffFuncType(baseFuncType);",
            "        if (auto declRefExpr = as<DeclRefExpr>(getInnerMostExprFromHigherOrderExpr(funcExpr)))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3964,
          "statement": "Diagnostics::expectedFunction, funcExpr->type.type);",
          "context_before": [
            "        if (!baseFuncType)",
            "        {",
            "            resultDiffExpr->type = semantics->getASTBuilder()->getErrorType();",
            "            semantics->getSink()->diagnose(",
            "                funcExpr,"
          ],
          "context_after": [
            "                funcExpr->type.type);",
            "            return;",
            "        }",
            "        resultDiffExpr->type = baseFuncType;",
            "        if (auto declRefExpr = as<DeclRefExpr>(getInnerMostExprFromHigherOrderExpr(funcExpr)))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33071,
      "severity": "Error",
      "name": "expectedAStringLiteral",
      "message": "expected a string literal",
      "line": 915,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 83,
          "statement": "getSink()->diagnose(expr, Diagnostics::expectedAStringLiteral);",
          "context_before": [
            "            *outVal = stringLitExpr->value;",
            "        }",
            "        return true;",
            "    }",
            ""
          ],
          "context_after": [
            "",
            "    return false;",
            "}",
            "",
            "bool SemanticsVisitor::checkCapabilityName(Expr* expr, CapabilityName& outCapabilityName)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1179,
          "statement": "getSink()->diagnose(attr->args[1], Diagnostics::expectedAStringLiteral);",
          "context_before": [
            "        {",
            "            requirePreludeAttr->prelude = getStringLiteralTokenValue(stringLitExpr->token);",
            "        }",
            "        else",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "        return attr;",
            "    }",
            "    else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33072,
      "severity": "Error",
      "name": "cannotHaveGenericDynInterface",
      "message": "dyn interfaces cannot be generic: '$0'.",
      "line": 918,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 117,
          "statement": "sink->diagnose(decl, Diagnostics::cannotHaveGenericDynInterface, decl);",
          "context_before": [
            "    }",
            "",
            "    // dyn interface cannot be generic",
            "    if (visitor->GetOuterGeneric(decl))",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "static void validateDynInterfaceUseWithInheritanceDecl(",
            "    SemanticsDeclVisitorBase* visitor,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33073,
      "severity": "Error",
      "name": "cannotHaveAssociatedTypeInDynInterface",
      "message": "dyn interfaces cannot have associatedType members.",
      "line": 919,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 69,
          "statement": "sink->diagnose(m, Diagnostics::cannotHaveAssociatedTypeInDynInterface);",
          "context_before": [
            "    // validate members inside `dyn interface`",
            "    for (auto m : decl->getDirectMemberDecls())",
            "    {",
            "        if (isAssociatedTypeDecl(m))",
            "        {"
          ],
          "context_after": [
            "            continue;",
            "        }",
            "        else if (auto genericDecl = as<GenericDecl>(m))",
            "        {",
            "            if (as<FuncDecl>(genericDecl->inner))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33074,
      "severity": "Error",
      "name": "cannotHaveGenericMethodInDynInterface",
      "message": "dyn interfaces cannot have generic methods.",
      "line": 924,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 76,
          "statement": "sink->diagnose(m, Diagnostics::cannotHaveGenericMethodInDynInterface);",
          "context_before": [
            "        }",
            "        else if (auto genericDecl = as<GenericDecl>(m))",
            "        {",
            "            if (as<FuncDecl>(genericDecl->inner))",
            "            {"
          ],
          "context_after": [
            "            }",
            "            continue;",
            "        }",
            "        else if (auto funcDecl = as<FuncDecl>(m))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33075,
      "severity": "Error",
      "name": "cannotHaveMutatingMethodInDynInterface",
      "message": "dyn interfaces cannot have [mutating] methods.",
      "line": 929,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 87,
          "statement": "sink->diagnose(m, Diagnostics::cannotHaveMutatingMethodInDynInterface);",
          "context_before": [
            "            visitor->ensureDecl(m, DeclCheckState::ModifiersChecked);",
            "            for (auto modifier : funcDecl->modifiers)",
            "            {",
            "                if (as<MutatingAttribute>(modifier))",
            "                {"
          ],
          "context_after": [
            "                }",
            "                else if (as<DifferentiableAttribute>(modifier))",
            "                {",
            "                    sink->diagnose(m, Diagnostics::cannotHaveDifferentiableMethodInDynInterface);",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33076,
      "severity": "Error",
      "name": "cannotHaveDifferentiableMethodInDynInterface",
      "message": "dyn interfaces cannot have [Differentiable] methods.",
      "line": 934,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 91,
          "statement": "sink->diagnose(m, Diagnostics::cannotHaveDifferentiableMethodInDynInterface);",
          "context_before": [
            "                {",
            "                    sink->diagnose(m, Diagnostics::cannotHaveMutatingMethodInDynInterface);",
            "                }",
            "                else if (as<DifferentiableAttribute>(modifier))",
            "                {"
          ],
          "context_after": [
            "                }",
            "            }",
            "            continue;",
            "        }",
            "        else if (auto inheritanceDecl = as<InheritanceDecl>(m))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33077,
      "severity": "Error",
      "name": "DynInterfaceCannotInheritNonDynInterface",
      "message": "dyn interface '$0' may only inherit 'dyn' interfaces. '$1' is not a dyn interface.",
      "line": 939,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 108,
          "statement": "Diagnostics::DynInterfaceCannotInheritNonDynInterface, decl, inheritedInterfaceDecl);",
          "context_before": [
            "",
            "            auto inheritedInterfaceDecl = inheritedInterfaceDeclRefType.getDecl();",
            "            if (!inheritedInterfaceDecl->hasModifier<DynModifier>())",
            "                sink->diagnose(",
            "                    m,"
          ],
          "context_after": [
            "                    decl,",
            "                    inheritedInterfaceDecl);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33078,
      "severity": "Error",
      "name": "cannotUseExtensionToMakeTypeConformToDynInterface",
      "message": "cannot use a extension to conform to a dyn interface '$0'.",
      "line": 944,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 142,
          "statement": "Diagnostics::cannotUseExtensionToMakeTypeConformToDynInterface, interfaceDecl);",
          "context_before": [
            "        if (auto extensionDeclParent = as<ExtensionDecl>(decl->parentDecl))",
            "        {",
            "            // not allowed to extend to conform to a 'dyn interface'",
            "            sink->diagnose(",
            "                extensionDeclParent,"
          ],
          "context_after": [
            "                interfaceDecl);",
            "        }",
            "        else if (visitor->GetOuterGeneric(decl->parentDecl))",
            "        {",
            "            sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33079,
      "severity": "Error",
      "name": "cannotHaveUnsizedMemberWhenInheritingDynInterface",
      "message": "cannot have unsized member '$0' when inheriting from dyn interface '$1'.",
      "line": 949,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 177,
          "statement": "Diagnostics::cannotHaveUnsizedMemberWhenInheritingDynInterface, varDecl, interfaceDecl);",
          "context_before": [
            "            bool isUnsized = varTypeTags & (int)TypeTag::Unsized;",
            "            bool isOpaque = varTypeTags & (int)TypeTag::Opaque;",
            "            if (isUnsized)",
            "                sink->diagnose(",
            "                    varDecl,"
          ],
          "context_after": [
            "                    varDecl,",
            "                    interfaceDecl);",
            "            if (isOpaque)",
            "                sink->diagnose(",
            "                    varDecl,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33080,
      "severity": "Error",
      "name": "cannotHaveOpaqueMemberWhenInheritingDynInterface",
      "message": "cannot have opaque member '$0' when inheriting from dyn interface '$1'.",
      "line": 954,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 183,
          "statement": "Diagnostics::cannotHaveOpaqueMemberWhenInheritingDynInterface, varDecl, interfaceDecl);",
          "context_before": [
            "                    varDecl,",
            "                    interfaceDecl);",
            "            if (isOpaque)",
            "                sink->diagnose(",
            "                    varDecl,"
          ],
          "context_after": [
            "                    varDecl,",
            "                    interfaceDecl);",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33081,
      "severity": "Error",
      "name": "cannotHaveNonCopyableMemberWhenInheritingDynInterface",
      "message": "cannot have non-copyable member '$0' when inheriting from dyn interface '$1'.",
      "line": 959,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 166,
          "statement": "Diagnostics::cannotHaveNonCopyableMemberWhenInheritingDynInterface, varDecl, interfaceDecl);",
          "context_before": [
            "",
            "            if (isNonCopyableType(varDecl->getType()))",
            "            {",
            "                sink->diagnose(",
            "                    varDecl,"
          ],
          "context_after": [
            "                    varDecl,",
            "                    interfaceDecl);",
            "            }",
            "",
            "            int varTypeTags = (int)visitor->getTypeTags(varDecl->getType());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 33082,
      "severity": "Error",
      "name": "cannotConformGenericToDynInterface",
      "message": "cannot conform generic type '$0' to dyn interface '$1'.",
      "line": 964,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 149,
          "statement": "Diagnostics::cannotConformGenericToDynInterface, decl->parentDecl, interfaceDecl);",
          "context_before": [
            "        }",
            "        else if (visitor->GetOuterGeneric(decl->parentDecl))",
            "        {",
            "            sink->diagnose(",
            "                decl,"
          ],
          "context_after": [
            "                decl->parentDecl,",
            "                interfaceDecl);",
            "        }",
            "    }",
            "    if (auto aggTypeDeclParent = as<AggTypeDecl>(decl->parentDecl))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30080,
      "severity": "Error",
      "name": "ambiguousConversion",
      "message": "more than one conversion exists from '$0' to '$1'",
      "line": 975,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1919,
          "statement": "sink->diagnose(fromExpr, Diagnostics::ambiguousConversion, fromType, toType);",
          "context_before": [
            "        //",
            "        if (outToExpr)",
            "        {",
            "            if (sink)",
            "            {"
          ],
          "context_after": [
            "                for (auto candidate : overloadContext.bestCandidates)",
            "                {",
            "                    sink->diagnose(",
            "                        candidate.item.declRef,",
            "                        Diagnostics::seeDeclarationOf,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30081,
      "severity": "Warning",
      "name": "unrecommendedImplicitConversion",
      "message": "implicit conversion from '$0' to '$1' is not recommended",
      "line": 976,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 2017,
          "statement": "Diagnostics::unrecommendedImplicitConversion, fromType, toType);",
          "context_before": [
            "                }",
            "                if (shouldEmitGeneralWarning && sink)",
            "                {",
            "                    sink->diagnose(",
            "                        fromExpr,"
          ],
          "context_after": [
            "                        fromType,",
            "                        toType);",
            "                }",
            "            }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30082,
      "severity": "Warning",
      "name": "implicitConversionToDouble",
      "message": " implicit float-to-double conversion may cause unexpected performance issues, use explicit cast if intended.",
      "line": 981,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 2030,
          "statement": "sink->diagnose(fromExpr, Diagnostics::implicitConversionToDouble);",
          "context_before": [
            "                auto builtinConversionKind = getImplicitConversionBuiltinKind(",
            "                    overloadContext.bestCandidate->item.declRef.getDecl());",
            "                if (builtinConversionKind == kBuiltinConversion_FloatToDouble)",
            "                {",
            "                    if (!as<FloatingPointLiteralExpr>(fromExpr))"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "        if (fromType.isLeftValue)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30090,
      "severity": "Error",
      "name": "tryClauseMustApplyToInvokeExpr",
      "message": "expression in a 'try' clause must be a call to a function or operator overload.",
      "line": 987,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4665,
          "statement": "getSink()->diagnose(expr, Diagnostics::tryClauseMustApplyToInvokeExpr);",
          "context_before": [
            "",
            "    auto parentFunc = this->m_parentFunc;",
            "    auto base = as<InvokeExpr>(expr->base);",
            "    if (!base)",
            "    {"
          ],
          "context_after": [
            "        return expr;",
            "    }",
            "",
            "    auto callee = as<DeclRefExpr>(base->functionExpr);",
            "    if (!callee)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30091,
      "severity": "Error",
      "name": "tryInvokeCalleeShouldThrow",
      "message": "'$0' called from a 'try' clause does not throw an error, make sure the callee is marked as 'throws'",
      "line": 992,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4682,
          "statement": "getSink()->diagnose(expr, Diagnostics::tryInvokeCalleeShouldThrow, callee->declRef);",
          "context_before": [
            "    Stmt* catchStmt = nullptr;",
            "    if (funcCallee)",
            "    {",
            "        if (funcCallee->errorType->equals(m_astBuilder->getBottomType()))",
            "        {"
          ],
          "context_after": [
            "            return expr;",
            "        }",
            "        catchStmt = findMatchingCatchStmt(funcCallee->errorType);",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30092,
      "severity": "Error",
      "name": "calleeOfTryCallMustBeFunc",
      "message": "callee in a 'try' clause must be a function",
      "line": 998,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4672,
          "statement": "getSink()->diagnose(expr, Diagnostics::calleeOfTryCallMustBeFunc);",
          "context_before": [
            "    }",
            "",
            "    auto callee = as<DeclRefExpr>(base->functionExpr);",
            "    if (!callee)",
            "    {"
          ],
          "context_after": [
            "        return expr;",
            "    }",
            "",
            "    auto funcCallee = as<FuncDecl>(callee->declRef.getDecl());",
            "    Stmt* catchStmt = nullptr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30093,
      "severity": "Error",
      "name": "uncaughtTryCallInNonThrowFunc",
      "message": "the current function or environment is not declared to throw any errors, but the 'try' clause is not caught",
      "line": 999,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4701,
          "statement": "getSink()->diagnose(expr, Diagnostics::uncaughtTryCallInNonThrowFunc);",
          "context_before": [
            "    if (!catchStmt)",
            "    {",
            "        // Uncaught try.",
            "        if (!parentFunc)",
            "        {"
          ],
          "context_after": [
            "            return expr;",
            "        }",
            "        if (parentFunc->errorType->equals(m_astBuilder->getBottomType()))",
            "        {",
            "            getSink()->diagnose(expr, Diagnostics::uncaughtTryCallInNonThrowFunc);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4706,
          "statement": "getSink()->diagnose(expr, Diagnostics::uncaughtTryCallInNonThrowFunc);",
          "context_before": [
            "            getSink()->diagnose(expr, Diagnostics::uncaughtTryCallInNonThrowFunc);",
            "            return expr;",
            "        }",
            "        if (parentFunc->errorType->equals(m_astBuilder->getBottomType()))",
            "        {"
          ],
          "context_after": [
            "            return expr;",
            "        }",
            "        if (funcCallee && !parentFunc->errorType->equals(funcCallee->errorType))",
            "        {",
            "            getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30094,
      "severity": "Error",
      "name": "mustUseTryClauseToCallAThrowFunc",
      "message": "the callee may throw an error, and therefore must be called within a 'try' clause",
      "line": 1005,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2985,
          "statement": "getSink()->diagnose(invoke, Diagnostics::mustUseTryClauseToCallAThrowFunc);",
          "context_before": [
            "            if (!funcType->getErrorType()->equals(m_astBuilder->getBottomType()))",
            "            {",
            "                // If the callee throws, make sure we are inside a try clause.",
            "                if (m_enclosingTryClauseType == TryClauseType::None)",
            "                {"
          ],
          "context_after": [
            "                }",
            "            }",
            "",
            "            auto funcDeclRefExpr = as<DeclRefExpr>(invoke->functionExpr);",
            "            FunctionDeclBase* funcDeclBase = nullptr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30095,
      "severity": "Error",
      "name": "errorTypeOfCalleeIncompatibleWithCaller",
      "message": "the error type `$1` of callee `$0` is not compatible with the caller's error type `$2`.",
      "line": 1010,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4713,
          "statement": "Diagnostics::errorTypeOfCalleeIncompatibleWithCaller, callee->declRef, funcCallee->errorType, parentFunc->errorType);",
          "context_before": [
            "        }",
            "        if (funcCallee && !parentFunc->errorType->equals(funcCallee->errorType))",
            "        {",
            "            getSink()->diagnose(",
            "                expr,"
          ],
          "context_after": [
            "                callee->declRef,",
            "                funcCallee->errorType,",
            "                parentFunc->errorType);",
            "            return expr;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30096,
      "severity": "Error",
      "name": "differentialTypeShouldServeAsItsOwnDifferentialType",
      "message": "cannot use type '$0' a `Differential` type. A differential type's differential must be itself. However, '$0.Differential' is '$1'.",
      "line": 1016,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3774,
          "statement": "Diagnostics::differentialTypeShouldServeAsItsOwnDifferentialType, differentialType, diffDiffType);",
          "context_before": [
            "        if (!differentialType->equals(diffDiffType))",
            "        {",
            "            SourceLoc sourceLoc = differentialType->getDeclRef().getDecl()->loc;",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                differentialType,",
            "                diffDiffType);",
            "            getSink()->diagnose(sourceLoc, Diagnostics::seeDefinitionOf, differentialType);",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDefinitionOf"
          ]
        }
      ]
    },
    {
      "id": 30097,
      "severity": "Error",
      "name": "functionNotMarkedAsDifferentiable",
      "message": "function '$0' is not marked as $1-differentiable.",
      "line": 1022,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3192,
          "statement": "Diagnostics::functionNotMarkedAsDifferentiable, funcDecl, \"forward\");",
          "context_before": [
            "                        if (requiredLevel == FunctionDifferentiableLevel::Forward &&",
            "                            !getShared()->isDifferentiableFunc(funcDecl))",
            "                        {",
            "                            getSink()->diagnose(",
            "                                funcDeclExpr,"
          ],
          "context_after": [
            "                                funcDecl,",
            "                                \"forward\");",
            "                        }",
            "                        if (requiredLevel == FunctionDifferentiableLevel::Backward &&",
            "                            !getShared()->isBackwardDifferentiableFunc(funcDecl))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3201,
          "statement": "Diagnostics::functionNotMarkedAsDifferentiable, funcDecl, \"backward\");",
          "context_before": [
            "                        if (requiredLevel == FunctionDifferentiableLevel::Backward &&",
            "                            !getShared()->isBackwardDifferentiableFunc(funcDecl))",
            "                        {",
            "                            getSink()->diagnose(",
            "                                funcDeclExpr,"
          ],
          "context_after": [
            "                                funcDecl,",
            "                                \"backward\");",
            "                        }",
            "                        if (!isEffectivelyStatic(funcDecl) && !isGlobalDecl(funcDecl))",
            "                        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30098,
      "severity": "Error",
      "name": "nonStaticMemberFunctionNotAllowedAsDiffOperand",
      "message": "non-static function reference '$0' is not allowed here.",
      "line": 1027,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3209,
          "statement": "Diagnostics::nonStaticMemberFunctionNotAllowedAsDiffOperand, funcDecl);",
          "context_before": [
            "                        }",
            "                        if (!isEffectivelyStatic(funcDecl) && !isGlobalDecl(funcDecl))",
            "                        {",
            "                            getSink()->diagnose(",
            "                                invoke->functionExpr,"
          ],
          "context_after": [
            "                                funcDecl);",
            "                        }",
            "                    }",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30099,
      "severity": "Error",
      "name": "sizeOfArgumentIsInvalid",
      "message": "argument to sizeof is invalid",
      "line": 1033,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4233,
          "statement": "getSink()->diagnose(sizeOfLikeExpr, Diagnostics::sizeOfArgumentIsInvalid);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        if (!_isSizeOfType(type))",
            "        {"
          ],
          "context_after": [
            "",
            "            sizeOfLikeExpr->type = m_astBuilder->getErrorType();",
            "            return sizeOfLikeExpr;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30083,
      "severity": "Error",
      "name": "countOfArgumentIsInvalid",
      "message": "argument to countof can only be a type pack or tuple",
      "line": 1034,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4223,
          "statement": "getSink()->diagnose(sizeOfLikeExpr, Diagnostics::countOfArgumentIsInvalid);",
          "context_before": [
            "",
            "    if (as<CountOfExpr>(sizeOfLikeExpr))",
            "    {",
            "        if (!_isCountOfType(type))",
            "        {"
          ],
          "context_after": [
            "",
            "            sizeOfLikeExpr->type = m_astBuilder->getErrorType();",
            "            return sizeOfLikeExpr;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30084,
      "severity": "Error",
      "name": "floatBitCastTypeMismatch",
      "message": "'$0' requires a $1 argument",
      "line": 1040,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4291,
          "statement": "Diagnostics::floatBitCastTypeMismatch, \"__floatAsInt\", \"half, float, or double\");",
          "context_before": [
            "",
            "    if (floatBaseType == BaseType::Void)",
            "    {",
            "        getSink()->diagnose(",
            "            expr,"
          ],
          "context_after": [
            "            \"__floatAsInt\",",
            "            \"half, float, or double\");",
            "        expr->type = m_astBuilder->getErrorType();",
            "        return expr;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30085,
      "severity": "Error",
      "name": "floatBitCastRequiresConstant",
      "message": "'__floatAsInt' requires a compile-time constant floating-point expression",
      "line": 1042,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4377,
          "statement": "getSink()->diagnose(expr, Diagnostics::floatBitCastRequiresConstant);",
          "context_before": [
            "        foldedExpr->value = resultValue;",
            "        return foldedExpr;",
            "    }",
            "",
            "    // Could not constant fold - emit error"
          ],
          "context_after": [
            "    expr->type = m_astBuilder->getErrorType();",
            "    return expr;",
            "}",
            "",
            "// Determines if we have a valid `AddressOf` target."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30101,
      "severity": "Error",
      "name": "readingFromWriteOnly",
      "message": "cannot read from writeonly, check modifiers.",
      "line": 1049,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2816,
          "statement": "getSink()->diagnose(expr, Diagnostics::readingFromWriteOnly);",
          "context_before": [
            "}",
            "",
            "Expr* SemanticsVisitor::checkAssignWithCheckedOperands(AssignExpr* expr)",
            "{",
            "    if (expr->right->type.isWriteOnly)"
          ],
          "context_after": [
            "",
            "    expr->left = maybeOpenRef(expr->left);",
            "    auto type = expr->left->type;",
            "    if (auto atomicType = as<AtomicType>(type))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2774,
          "statement": "getSink()->diagnose(initExpr, Diagnostics::readingFromWriteOnly);",
          "context_before": [
            "        // it to the type of the variable.",
            "        //",
            "        initExpr = subVisitor.CheckTerm(initExpr);",
            "",
            "        if (initExpr->type.isWriteOnly)"
          ],
          "context_after": [
            "",
            "        initExpr = coerce(CoercionSite::Initializer, varDecl->type.Ptr(), initExpr, getSink());",
            "        varDecl->initExpr = initExpr;",
            "",
            "        // We need to ensure that any variable doesn't introduce"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30102,
      "severity": "Error",
      "name": "differentiableMemberShouldHaveCorrespondingFieldInDiffType",
      "message": "differentiable member '$0' should have a corresponding field in '$1'. Use [DerivativeMember($1.<field-name>)] or mark as no_diff",
      "line": 1050,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3817,
          "statement": "Diagnostics::differentiableMemberShouldHaveCorrespondingFieldInDiffType, member->nameAndLoc.name, differentialType);",
          "context_before": [
            "            if (member->findModifier<DerivativeMemberAttribute>())",
            "                continue;",
            "            else if (!typeIsSelfDifferential)",
            "                getSink()->diagnose(",
            "                    member,"
          ],
          "context_after": [
            "                    member->nameAndLoc.name,",
            "                    differentialType);",
            "            else",
            "            {",
            "                // If the type is its own differential type, we can infer the differential"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30103,
      "severity": "Error",
      "name": "expectTypePackAfterEach",
      "message": "expected a type pack or a tuple after 'each'.",
      "line": 1057,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4937,
          "statement": "getSink()->diagnose(expr, Diagnostics::expectTypePackAfterEach);",
          "context_before": [
            "    }",
            "error:;",
            "    expr->type = m_astBuilder->getErrorType();",
            "    if (!as<ErrorType>(baseType))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return expr;",
            "}",
            "",
            "Expr* SemanticsExprVisitor::visitLambdaExpr(LambdaExpr* lambdaExpr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30104,
      "severity": "Error",
      "name": "eachExprMustBeInsideExpandExpr",
      "message": "'each' expression must be inside 'expand' expression.",
      "line": 1058,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4869,
          "statement": "getSink()->diagnose(expr, Diagnostics::eachExprMustBeInsideExpandExpr);",
          "context_before": [
            "",
            "Expr* SemanticsExprVisitor::visitEachExpr(EachExpr* expr)",
            "{",
            "    if (!m_parentExpandExpr)",
            "    {"
          ],
          "context_after": [
            "        expr->type = m_astBuilder->getErrorType();",
            "        return expr;",
            "    }",
            "",
            "    expr->baseExpr = CheckTerm(expr->baseExpr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30105,
      "severity": "Error",
      "name": "expandTermCapturesNoTypePacks",
      "message": "'expand' term captures no type packs. At least one type pack must be referenced via an 'each' term inside an 'expand' term.",
      "line": 1063,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4850,
          "statement": "getSink()->diagnose(expr, Diagnostics::expandTermCapturesNoTypePacks);",
          "context_before": [
            "        expr->type = m_astBuilder->getErrorType();",
            "        return expr;",
            "    }",
            "    if (subContext.getCapturedTypePacks()->getCount() == 0)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    List<Type*> capturedTypePacks;",
            "    for (auto capturedType : capturedTypePackSet)",
            "    {",
            "        capturedTypePacks.add(capturedType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30106,
      "severity": "Error",
      "name": "improperUseOfType",
      "message": "type '$0' cannot be used in this context.",
      "line": 1069,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 448,
          "statement": "getSink()->diagnose(typeExp.exp, Diagnostics::improperUseOfType, typeExp.type);",
          "context_before": [
            "    }",
            "",
            "    // A type pack is not a usable type other than for defining parameters.",
            "    if (!as<ParamDecl>(decl) && isTypePack(type))",
            "    {"
          ],
          "context_after": [
            "        result.type = m_astBuilder->getErrorType();",
            "        return result;",
            "    }",
            "    return result;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30107,
      "severity": "Error",
      "name": "parameterPackMustBeConst",
      "message": "a parameter pack must be declared as 'const'.",
      "line": 1070,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9643,
          "statement": "getSink()->diagnose(modifier, Diagnostics::parameterPackMustBeConst);",
          "context_before": [
            "                // to the `const` modifier at all (since that is not actually what is",
            "                // required), and should instead note that a parameter pack may only",
            "                // be declared as a pure input parameter to a function (`in` or",
            "                // `borrow`).",
            "                //"
          ],
          "context_after": [
            "            }",
            "            else if (as<ConstModifier>(modifier))",
            "            {",
            "                hasConstModifier = true;",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30108,
      "severity": "Error",
      "name": "breakInsideDefer",
      "message": "'break' must not appear inside a defer statement.",
      "line": 1072,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 215,
          "statement": "getSink()->diagnose(stmt, Diagnostics::breakInsideDefer);",
          "context_before": [
            "    //",
            "    if (targetOuterStmt)",
            "    {",
            "        if (FindOuterStmt<DeferStmt>(targetOuterStmt))",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        // We stash the ID of the target statement in the `break`",
            "        // statement so that they can be correlated later, during",
            "        // code generation."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30109,
      "severity": "Error",
      "name": "continueInsideDefer",
      "message": "'continue' must not appear inside a defer statement.",
      "line": 1073,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 237,
          "statement": "getSink()->diagnose(stmt, Diagnostics::continueInsideDefer);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        if (FindOuterStmt<DeferStmt>(targetOuterStmt))",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        // We stash the ID of the target statement in the `continue`",
            "        // statement so that they can be correlated later, during",
            "        // code generation."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30110,
      "severity": "Error",
      "name": "returnInsideDefer",
      "message": "'return' must not appear inside a defer statement.",
      "line": 1078,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 601,
          "statement": "getSink()->diagnose(stmt, Diagnostics::returnInsideDefer);",
          "context_before": [
            "        }",
            "    }",
            "",
            "    if (FindOuterStmt<DeferStmt>())",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsStmtVisitor::visitWhileStmt(WhileStmt* stmt)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30111,
      "severity": "Error",
      "name": "returnTypeMismatchInsideLambda",
      "message": "returned values must have the same type among all 'return' statements inside a lambda expression: returned '$0' here, but '$1' previously.",
      "line": 1079,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 593,
          "statement": "Diagnostics::returnTypeMismatchInsideLambda, returnType, m_parentLambdaDecl->funcDecl->returnType.type);",
          "context_before": [
            "            m_parentLambdaDecl->funcDecl->returnType.type = returnType;",
            "        if (!m_parentLambdaDecl->funcDecl->returnType.type->equals(returnType))",
            "        {",
            "            getSink()->diagnose(",
            "                stmt,"
          ],
          "context_after": [
            "                returnType,",
            "                m_parentLambdaDecl->funcDecl->returnType.type);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30112,
      "severity": "Error",
      "name": "nonCopyableTypeCapturedInLambda",
      "message": "cannot capture non-copyable type '$0' in a lambda expression.",
      "line": 1086,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3589,
          "statement": "Diagnostics::nonCopyableTypeCapturedInLambda, capturedVarDecl->type.type);",
          "context_before": [
            "        // Is captured value NonCopyable? If so, it needs to be an error.",
            "        if (isNonCopyableType(capturedVarDecl->type.type))",
            "        {",
            "            getSink()->diagnose(",
            "                exprIn,"
          ],
          "context_after": [
            "                capturedVarDecl->type.type);",
            "        }",
            "    }",
            "",
            "    // Return a VarExpr referencing the capturedVarDecl."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30113,
      "severity": "Error",
      "name": "uncaughtThrowInsideDefer",
      "message": "'throw' expressions require a matching 'catch' inside a defer statement.",
      "line": 1092,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 653,
          "statement": "getSink()->diagnose(stmt, Diagnostics::uncaughtThrowInsideDefer);",
          "context_before": [
            "        // similar reasons as 'return' - if you have two (or more) defers,",
            "        // both of which exit the outer scope, it's unclear which one gets",
            "        // called and when. Both can't fully run. That kind of goes against the",
            "        // point of 'defer', which is to _always_ run some code when exiting",
            "        // scopes."
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsStmtVisitor::visitCatchStmt(CatchStmt* stmt)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30114,
      "severity": "Error",
      "name": "uncaughtTryInsideDefer",
      "message": "'try' expressions require a matching 'catch' inside a defer statement.",
      "line": 1097,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4692,
          "statement": "getSink()->diagnose(expr, Diagnostics::uncaughtTryInsideDefer);",
          "context_before": [
            "",
            "    if (FindOuterStmt<DeferStmt>(catchStmt))",
            "    {",
            "        // 'try' may jump outside a defer statement, which isn't allowed for",
            "        // now."
          ],
          "context_after": [
            "        return expr;",
            "    }",
            "",
            "    if (!catchStmt)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30115,
      "severity": "Error",
      "name": "uncaughtThrowInNonThrowFunc",
      "message": "the current function or environment is not declared to throw any errors, but contains an uncaught 'throw' statement.",
      "line": 1102,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 629,
          "statement": "getSink()->diagnose(stmt, Diagnostics::uncaughtThrowInNonThrowFunc);",
          "context_before": [
            "    Stmt* catchStmt = findMatchingCatchStmt(stmt->expression->type);",
            "",
            "    auto parentFunc = getParentFunc();",
            "    if (!catchStmt && (!parentFunc || parentFunc->errorType->equals(m_astBuilder->getBottomType())))",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    if (!catchStmt && !stmt->expression->type->equals(m_astBuilder->getErrorType()))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30116,
      "severity": "Error",
      "name": "throwTypeIncompatibleWithErrorType",
      "message": "the type `$0` of `throw` is not compatible with function's error type `$1`.",
      "line": 1108,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 639,
          "statement": "Diagnostics::throwTypeIncompatibleWithErrorType, stmt->expression->type, parentFunc->errorType);",
          "context_before": [
            "    {",
            "        if (!parentFunc->errorType->equals(stmt->expression->type))",
            "        {",
            "            getSink()->diagnose(",
            "                stmt->expression,"
          ],
          "context_after": [
            "                stmt->expression->type,",
            "                parentFunc->errorType);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30117,
      "severity": "Error",
      "name": "forwardReferenceInGenericConstraint",
      "message": "generic constraint for parameter '$0' references type parameter '$1' before it is declared",
      "line": 1113,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3479,
          "statement": "Diagnostics::forwardReferenceInGenericConstraint, decl->sub.type, typeParam);",
          "context_before": [
            "                !declaredBeforeConstraint.contains(typeParam))",
            "            {",
            "                // Found a forward reference, report an error.",
            "                getSink()->diagnose(",
            "                    decl->sup.exp,"
          ],
          "context_after": [
            "                    decl->sub.type,",
            "                    typeParam);",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30500,
      "severity": "Error",
      "name": "includedFileMissingImplementing",
      "message": "missing 'implementing' declaration in the included source file '$0'.",
      "line": 1120,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11428,
          "statement": "Diagnostics::includedFileMissingImplementing, name);",
          "context_before": [
            "        return;",
            "    }",
            "",
            "    getSink()->diagnose(",
            "        decl->moduleNameAndLoc.loc,"
          ],
          "context_after": [
            "        name);",
            "}",
            "",
            "",
            "void SemanticsDeclScopeWiringVisitor::visitImplementingDecl(ImplementingDecl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30501,
      "severity": "Error",
      "name": "includedFileMissingImplementingDoYouMeanImport",
      "message": "missing 'implementing' declaration in the included source file '$0'. The file declares that it defines module '$1', do you mean 'import' instead?",
      "line": 1125,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11351,
          "statement": "Diagnostics::includedFileMissingImplementingDoYouMeanImport, name, moduleDeclaration->getName());",
          "context_before": [
            "    {",
            "        // We are trying to include a file that defines a module, the user could mean \"import\"",
            "        // instead.",
            "        getSink()->diagnose(",
            "            decl->moduleNameAndLoc.loc,"
          ],
          "context_after": [
            "            name,",
            "            moduleDeclaration->getName());",
            "        return;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30502,
      "severity": "Error",
      "name": "includedFileDoesNotImplementCurrentModule",
      "message": "the included source file is expected to implement module '$0', but it is implementing '$1' instead.",
      "line": 1131,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11416,
          "statement": "Diagnostics::includedFileDoesNotImplementCurrentModule, expectedModuleName, moduleName);",
          "context_before": [
            "            if (!moduleNameStr.getUnownedSlice().caseInsensitiveEquals(",
            "                    expectedModuleNameStr.getUnownedSlice()))",
            "            {",
            "                getSink()->diagnose(",
            "                    decl->moduleNameAndLoc.loc,"
          ],
          "context_after": [
            "                    expectedModuleName,",
            "                    moduleName);",
            "                return;",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30503,
      "severity": "Error",
      "name": "primaryModuleFileCannotStartWithImplementingDecl",
      "message": "a primary source file for a module cannot start with 'implementing'.",
      "line": 1137,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 4001,
          "statement": "Diagnostics::primaryModuleFileCannotStartWithImplementingDecl);",
          "context_before": [
            "            if (!getShared()->isInLanguageServer())",
            "            {",
            "                // A primary module file can't start with an \"implementing\" declaration.",
            "                getSink()->diagnose(",
            "                    firstDeclInModule,"
          ],
          "context_after": [
            "            }",
            "        }",
            "        else if (!as<ModuleDeclarationDecl>(firstDeclInModule))",
            "        {",
            "            // A primary module file must start with a `module` declaration."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30504,
      "severity": "Warning",
      "name": "primaryModuleFileMustStartWithModuleDecl",
      "message": "a primary source file for a module should start with 'module'.",
      "line": 1142,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 4009,
          "statement": "getSink()->diagnose(firstMember, Diagnostics::primaryModuleFileMustStartWithModuleDecl);",
          "context_before": [
            "        else if (!as<ModuleDeclarationDecl>(firstDeclInModule))",
            "        {",
            "            // A primary module file must start with a `module` declaration.",
            "            // TODO: this warning is disabled for now to free users from massive change for now.",
            "#if 0"
          ],
          "context_after": [
            "#endif",
            "        }",
            "    }",
            "",
            "    if (moduleDecl->findModifier<PublicModifier>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30505,
      "severity": "Error",
      "name": "implementingMustReferencePrimaryModuleFile",
      "message": "the source file referenced by 'implementing' must be a primary module file starting with a 'module' declaration.",
      "line": 1147,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11474,
          "statement": "Diagnostics::implementingMustReferencePrimaryModuleFile);",
          "context_before": [
            "    }",
            "    else if (as<ImplementingDecl>(firstDeclInFile))",
            "    {",
            "        getSink()->diagnose(",
            "            decl->moduleNameAndLoc.loc,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    if (auto moduleDecl = getModuleDecl(decl))",
            "        importFileDeclIntoScope(moduleDecl->ownedScope, fileDecl);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30506,
      "severity": "Warning",
      "name": "moduleImplementationHasFileExtension",
      "message": "implementing directive contains file extension in module name '$0'. Module names should not include extensions. The compiler will use '$1' as the module name.",
      "line": 1153,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11404,
          "statement": "Diagnostics::moduleImplementationHasFileExtension, moduleNameStr, normalizedName);",
          "context_before": [
            "                if (normalizedName.getUnownedSlice().caseInsensitiveEquals(",
            "                        expectedModuleNameStr.getUnownedSlice()))",
            "                {",
            "                    getSink()->diagnose(",
            "                        implementing->moduleNameAndLoc.loc,"
          ],
          "context_after": [
            "                        moduleNameStr,",
            "                        normalizedName);",
            "                    return;",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30600,
      "severity": "Error",
      "name": "declIsNotVisible",
      "message": "'$0' is not accessible from the current context.",
      "line": 1161,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 271,
          "statement": "getSink()->diagnose(context.loc, Diagnostics::declIsNotVisible, candidate.item.declRef);",
          "context_before": [
            "",
            "    if (!isDeclVisibleFromScope(candidate.item.declRef, context.sourceScope))",
            "    {",
            "        if (context.mode == OverloadResolveContext::Mode::ForReal)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        return false;",
            "    }",
            "",
            "    return true;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1072,
          "statement": "getSink()->diagnose(loc, Diagnostics::declIsNotVisible, lookupResult.item.declRef);",
          "context_before": [
            "{",
            "    outDiagnosed = false;",
            "    auto result = filterLookupResultByVisibility(lookupResult);",
            "    if (lookupResult.isValid() && !result.isValid())",
            "    {"
          ],
          "context_after": [
            "        outDiagnosed = true;",
            "",
            "        if (getShared()->isInLanguageServer())",
            "        {",
            "            // When in language server mode, return the unfiltered result so we can still"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30601,
      "severity": "Error",
      "name": "declCannotHaveHigherVisibility",
      "message": "'$0' cannot have a higher visibility than '$1'.",
      "line": 1162,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2112,
          "statement": "getSink()->diagnose(decl, Diagnostics::declCannotHaveHigherVisibility, decl, parentDecl);",
          "context_before": [
            "    if (!parentDecl)",
            "        return;",
            "    auto parentVisibility = getDeclVisibility(parentDecl);",
            "    if (thisVisibility > parentVisibility)",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void postProcessingOnModifiers(ASTBuilder* astBuilder, Modifiers& modifiers)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30602,
      "severity": "Error",
      "name": "satisfyingDeclCannotHaveLowerVisibility",
      "message": "'$0' is less visible than the interface requirement it satisfies.",
      "line": 1167,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30603,
      "severity": "Error",
      "name": "invalidUseOfPrivateVisibility",
      "message": "'$0' cannot have private visibility because it is not a member of a type.",
      "line": 1172,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1916,
          "statement": "Diagnostics::invalidUseOfPrivateVisibility, as<Decl>(syntaxNode));",
          "context_before": [
            "        {",
            "            if (isGlobalDecl(decl))",
            "            {",
            "                getSink()->diagnose(",
            "                    m,"
          ],
          "context_after": [
            "                    as<Decl>(syntaxNode));",
            "                return m;",
            "            }",
            "        }",
            "        if (as<NamespaceDeclBase>(syntaxNode))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1936,
          "statement": "Diagnostics::invalidUseOfPrivateVisibility, as<Decl>(syntaxNode));",
          "context_before": [
            "            // Interface requirements can't be private.",
            "            if (isInterfaceRequirement(decl))",
            "            {",
            "                getSink()->diagnose(",
            "                    m,"
          ],
          "context_after": [
            "                    as<Decl>(syntaxNode));",
            "            }",
            "        }",
            "    }",
            "    else if (as<InternalModifier>(m))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30604,
      "severity": "Error",
      "name": "useOfLessVisibleType",
      "message": "'$0' references less visible type '$1'.",
      "line": 1177,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2095,
          "statement": "getSink()->diagnose(decl, Diagnostics::useOfLessVisibleType, decl, type);",
          "context_before": [
            "        if (!type)",
            "            continue;",
            "        DeclVisibility typeVisibility = getTypeVisibility(type);",
            "        if (typeVisibility < thisVisibility)",
            "        {"
          ],
          "context_after": [
            "            break;",
            "        }",
            "    }",
            "",
            "    // Next, we check that the decl does not have higher visiblity than its parent."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36005,
      "severity": "Error",
      "name": "invalidVisibilityModifierOnTypeOfDecl",
      "message": "visibility modifier is not allowed on '$0'.",
      "line": 1178,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1925,
          "statement": "Diagnostics::invalidVisibilityModifierOnTypeOfDecl, syntaxNode->astNodeType);",
          "context_before": [
            "        }",
            "        if (as<NamespaceDeclBase>(syntaxNode))",
            "        {",
            "            getSink()->diagnose(",
            "                m,"
          ],
          "context_after": [
            "                syntaxNode->astNodeType);",
            "            return m;",
            "        }",
            "        else if (auto decl = as<Decl>(syntaxNode))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1947,
          "statement": "Diagnostics::invalidVisibilityModifierOnTypeOfDecl, syntaxNode->astNodeType);",
          "context_before": [
            "    {",
            "        if (as<NamespaceDeclBase>(syntaxNode))",
            "        {",
            "            getSink()->diagnose(",
            "                m,"
          ],
          "context_after": [
            "                syntaxNode->astNodeType);",
            "            return m;",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36100,
      "severity": "Error",
      "name": "conflictingCapabilityDueToUseOfDecl",
      "message": "'$0' requires capability '$1' that is conflicting with the '$2's current capability requirement '$3'.",
      "line": 1185,
      "param_count": 4,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14053,
          "statement": "Diagnostics::conflictingCapabilityDueToUseOfDecl, referencedDecl, nodeCaps, decl, oldCaps);",
          "context_before": [
            "            maybeDiagnose(",
            "                visitor->getSink(),",
            "                visitor->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                referenceLoc,"
          ],
          "context_after": [
            "                referencedDecl,",
            "                nodeCaps,",
            "                decl,",
            "                oldCaps);",
            "        }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36101,
      "severity": "Error",
      "name": "conflictingCapabilityDueToStatement",
      "message": "statement requires capability '$0' that is conflicting with the '$1's current capability requirement '$2'.",
      "line": 1191,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14066,
          "statement": "Diagnostics::conflictingCapabilityDueToStatement, nodeCaps, decl, oldCaps);",
          "context_before": [
            "            maybeDiagnose(",
            "                visitor->getSink(),",
            "                visitor->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                referenceLoc,"
          ],
          "context_after": [
            "                nodeCaps,",
            "                decl,",
            "                oldCaps);",
            "        }",
            "        else"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14226,
          "statement": "Diagnostics::conflictingCapabilityDueToStatement, targetCap, maybeRequireCapability, maybeRequireCapability->capabilitySet);",
          "context_before": [
            "                        maybeDiagnose(",
            "                            Base::getSink(),",
            "                            outerContext.getOptionSet(),",
            "                            DiagnosticCategory::Capability,",
            "                            stmt->targetCases[targetCaseIndex]->loc,"
          ],
          "context_after": [
            "                            targetCap,",
            "                            maybeRequireCapability,",
            "                            maybeRequireCapability->capabilitySet);",
            "                        handleParentDiagnosticFunc(DiagnosticCategory::Capability);",
            "                    }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14245,
          "statement": "Diagnostics::conflictingCapabilityDueToStatement, bodyCap, \"target_switch\", oldCap);",
          "context_before": [
            "                maybeDiagnose(",
            "                    Base::getSink(),",
            "                    outerContext.getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    targetCase->body->loc,"
          ],
          "context_after": [
            "                    bodyCap,",
            "                    \"target_switch\",",
            "                    oldCap);",
            "                handleParentDiagnosticFunc(DiagnosticCategory::Capability);",
            "            }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36102,
      "severity": "Error",
      "name": "conflictingCapabilityDueToStatementEnclosingFunc",
      "message": "statement requires capability '$0' that is conflicting with the current function's capability requirement '$1'.",
      "line": 1197,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14078,
          "statement": "Diagnostics::conflictingCapabilityDueToStatementEnclosingFunc, nodeCaps, oldCaps);",
          "context_before": [
            "            maybeDiagnose(",
            "                visitor->getSink(),",
            "                visitor->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                referenceLoc,"
          ],
          "context_after": [
            "                nodeCaps,",
            "                oldCaps);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36103,
      "severity": "Warning",
      "name": "missingCapabilityRequirementOnPublicDecl",
      "message": "public symbol '$0' is missing capability requirement declaration, the symbol is assumed to require inferred capabilities '$1'.",
      "line": 1203,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 36104,
      "severity": "Error",
      "name": "useOfUndeclaredCapability",
      "message": "'$0' uses undeclared capability '$1'",
      "line": 1209,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14541,
          "statement": "Diagnostics::useOfUndeclaredCapability, failedAvailableCapabilityConjunction, true);",
          "context_before": [
            "                CapabilitySet{funcDecl->inferredCapabilityRequirements},",
            "                failedAvailableCapabilityConjunction,",
            "                checkCapabilityResult);",
            "            diagnoseUndeclaredCapability(",
            "                funcDecl,"
          ],
          "context_after": [
            "                failedAvailableCapabilityConjunction,",
            "                true);",
            "",
            "            // declared capabilities must be a superset.",
            "            funcDecl->inferredCapabilityRequirements = frozenDeclaredCaps;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36104,
      "severity": "Error",
      "name": "useOfUndeclaredCapabilityOfInterfaceRequirement",
      "message": "'$0' uses capability '$1' that is incompatable with the interface requirement",
      "line": 1210,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14630,
          "statement": "Diagnostics::useOfUndeclaredCapabilityOfInterfaceRequirement, failedAvailableCapabilityConjunction, false);",
          "context_before": [
            "            if (checkCapabilityResult ==",
            "                CheckCapabilityRequirementResult::AvailableIsNotASuperSetToRequired)",
            "            {",
            "                diagnoseUndeclaredCapability(",
            "                    implDecl,"
          ],
          "context_after": [
            "                    failedAvailableCapabilityConjunction,",
            "                    false);",
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    getOptionSet(),"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36104,
      "severity": "Error",
      "name": "useOfUndeclaredCapabilityOfInheritanceDecl",
      "message": "'$0' uses capability '$1' that is incompatable with the supertype",
      "line": 1215,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14679,
          "statement": "Diagnostics::useOfUndeclaredCapabilityOfInheritanceDecl, failedAvailableCapabilityConjunction, false);",
          "context_before": [
            "    if (checkCapabilityResult ==",
            "        CheckCapabilityRequirementResult::AvailableIsNotASuperSetToRequired)",
            "    {",
            "        diagnoseUndeclaredCapability(",
            "            inheritanceParentDecl,"
          ],
          "context_after": [
            "            failedAvailableCapabilityConjunction,",
            "            false);",
            "        maybeDiagnose(",
            "            getSink(),",
            "            getOptionSet(),"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36105,
      "severity": "Error",
      "name": "unknownCapability",
      "message": "unknown capability name '$0'.",
      "line": 1220,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 3978,
          "statement": "Diagnostics::unknownCapability, capNameToken.getContent());",
          "context_before": [
            "        if (capName != CapabilityName::Invalid)",
            "            capNames.add(capName);",
            "        else",
            "            parser->sink->diagnose(",
            "                capNameToken,"
          ],
          "context_after": [
            "                capNameToken.getContent());",
            "        if (AdvanceIf(parser, \"+\") || AdvanceIf(parser, \",\"))",
            "            continue;",
            "        break;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 103,
          "statement": "getSink()->diagnose(expr, Diagnostics::unknownCapability, varExpr->name);",
          "context_before": [
            "            suggestions.scopeKind = CompletionSuggestions::ScopeKind::Capabilities;",
            "        }",
            "        outCapabilityName = findCapabilityName(varExpr->name->text.getUnownedSlice());",
            "        if (outCapabilityName == CapabilityName::Invalid)",
            "        {"
          ],
          "context_after": [
            "            return false;",
            "        }",
            "        return true;",
            "    }",
            "    getSink()->diagnose(expr, Diagnostics::expectCapability);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 705,
          "statement": "getSink()->diagnose(attr, Diagnostics::unknownCapability, capNameString);",
          "context_before": [
            "            return entryPointAttr;",
            "        }",
            "        else",
            "        {",
            "            // always diagnose this error since nothing can compile with an invalid capability"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "    }",
            "    else if (",
            "        (as<DomainAttribute>(attr)) || (as<OutputTopologyAttribute>(attr)) ||"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36106,
      "severity": "Error",
      "name": "expectCapability",
      "message": "expect a capability name.",
      "line": 1221,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 108,
          "statement": "getSink()->diagnose(expr, Diagnostics::expectCapability);",
          "context_before": [
            "            getSink()->diagnose(expr, Diagnostics::unknownCapability, varExpr->name);",
            "            return false;",
            "        }",
            "        return true;",
            "    }"
          ],
          "context_after": [
            "    return false;",
            "}",
            "",
            "void SemanticsVisitor::visitModifier(Modifier*)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36107,
      "severity": "Error",
      "name": "entryPointUsesUnavailableCapability",
      "message": "entrypoint '$0' uses features that are not available in '$2' stage for '$1' compilation target.",
      "line": 1222,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 997,
          "statement": "Diagnostics::entryPointUsesUnavailableCapability, entryPointFuncDecl, compileTarget, stageTarget);",
          "context_before": [
            "            maybeDiagnose(",
            "                sink,",
            "                linkage->m_optionSet,",
            "                DiagnosticCategory::Capability,",
            "                entryPointFuncDecl,"
          ],
          "context_after": [
            "                entryPointFuncDecl,",
            "                compileTarget,",
            "                stageTarget);",
            "",
            "            // Find out what is incompatible (ancestor missing a super set of 'target+stage')"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36108,
      "severity": "Error",
      "name": "declHasDependenciesNotCompatibleOnTarget",
      "message": "'$0' has dependencies that are not compatible on the required compilation target '$1'.",
      "line": 1228,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15144,
          "statement": "Diagnostics::declHasDependenciesNotCompatibleOnTarget, decl, outFailedAtom);",
          "context_before": [
            "            maybeDiagnose(",
            "                getSink(),",
            "                this->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                decl,"
          ],
          "context_after": [
            "                decl,",
            "                outFailedAtom);",
            "",
            "            // Anything defined on a non-failed target atom may be the culprit to why we fail",
            "            // having a target capability. Print out all possible culprits."
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36109,
      "severity": "Error",
      "name": "invalidTargetSwitchCase",
      "message": "'$0' cannot be used as a target_switch case.",
      "line": 1233,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 468,
          "statement": "Diagnostics::invalidTargetSwitchCase, capabilityNameToString((CapabilityName)caseStmt->capability));",
          "context_before": [
            "                caseStmt->capabilityToken.getContentLength() != 0 &&",
            "                (set.getCapabilityTargetSets().getCount() != 1 || set.isInvalid() || set.isEmpty()))",
            "            {",
            "                getSink()->diagnose(",
            "                    caseStmt->capabilityToken.loc,"
          ],
          "context_after": [
            "                    capabilityNameToString((CapabilityName)caseStmt->capability));",
            "            }",
            "        }",
            "",
            "        if (checkedStmt.contains(caseStmt->body))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36110,
      "severity": "Error",
      "name": "stageIsIncompatibleWithCapabilityDefinition",
      "message": "'$0' is defined for stage '$1', which is incompatible with the declared capability set '$2'.",
      "line": 1234,
      "param_count": 3,
      "call_sites": []
    },
    {
      "id": 36111,
      "severity": "Error",
      "name": "unexpectedCapability",
      "message": "'$0' resolves into a disallowed `$1` Capability.",
      "line": 1239,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1151,
          "statement": "Diagnostics::unexpectedCapability, attr, CapabilityName::Invalid);",
          "context_before": [
            "            maybeDiagnose(",
            "                getSink(),",
            "                this->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                attr,"
          ],
          "context_after": [
            "                attr,",
            "                CapabilityName::Invalid);",
            "    }",
            "    else if (auto requirePreludeAttr = as<RequirePreludeAttribute>(attr))",
            "    {"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36112,
      "severity": "Warning",
      "name": "entryPointAndProfileAreIncompatible",
      "message": "'$0' is defined for stage '$1', which is incompatible with the declared profile '$2'.",
      "line": 1240,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1105,
          "statement": "Diagnostics::entryPointAndProfileAreIncompatible, entryPointFuncDecl, entryPointStage, targetProfile.getName());",
          "context_before": [
            "                maybeDiagnose(",
            "                    sink,",
            "                    optionSet,",
            "                    DiagnosticCategory::Capability,",
            "                    entryPointAttr,"
          ],
          "context_after": [
            "                    entryPointFuncDecl,",
            "                    entryPointStage,",
            "                    targetProfile.getName());",
            "        }",
            "        if (entryPointProfileStage == Stage::Unknown)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36113,
      "severity": "Warning",
      "name": "usingInternalCapabilityName",
      "message": "'$0' resolves into a '_Internal' '_$1' Capability, use '$1' instead.",
      "line": 1245,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 669,
          "statement": "Diagnostics::usingInternalCapabilityName, attr, capName);",
          "context_before": [
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    this->getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    attr,"
          ],
          "context_after": [
            "                    attr,",
            "                    capName);",
            "",
            "            // Ensure this capability only defines 1 stage per target, else diagnose an error.",
            "            // This is a fatal error, do not allow toggling this error off."
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1139,
          "statement": "Diagnostics::usingInternalCapabilityName, attr, capName);",
          "context_before": [
            "                    maybeDiagnose(",
            "                        getSink(),",
            "                        this->getOptionSet(),",
            "                        DiagnosticCategory::Capability,",
            "                        attr,"
          ],
          "context_after": [
            "                        attr,",
            "                        capName);",
            "            }",
            "        }",
            "        requireCapAttr->capabilitySet = CapabilitySet(capabilityNames).freeze(getASTBuilder());"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36114,
      "severity": "Warning",
      "name": "incompatibleWithPrecompileLib",
      "message": "Precompiled library requires '$0', has `$1`, implicitly upgrading capabilities.",
      "line": 1250,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 36115,
      "severity": "Error",
      "name": "incompatibleWithPrecompileLibRestrictive",
      "message": "Precompiled library requires '$0', has `$1`.",
      "line": 1255,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 36116,
      "severity": "Error",
      "name": "capabilityHasMultipleStages",
      "message": "Capability '$0' is targeting stages '$1', only allowed to use 1 unique stage here.",
      "line": 1260,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 696,
          "statement": "Diagnostics::capabilityHasMultipleStages, capNameString, atomsToPrint);",
          "context_before": [
            "                atomsToPrint.reserve(stageToBeUsed.getCount());",
            "                for (auto i : stageToBeUsed)",
            "                    atomsToPrint.add(i);",
            "                getSink()->diagnose(",
            "                    attr,"
          ],
          "context_after": [
            "                    capNameString,",
            "                    atomsToPrint);",
            "            }",
            "            return entryPointAttr;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36117,
      "severity": "Error",
      "name": "declHasDependenciesNotCompatibleOnStage",
      "message": "'$0' requires support for stage '$1', but stage is unsupported.",
      "line": 1265,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15202,
          "statement": "Diagnostics::declHasDependenciesNotCompatibleOnStage, decl, formattedAtom);",
          "context_before": [
            "            maybeDiagnose(",
            "                getSink(),",
            "                this->getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                decl,"
          ],
          "context_after": [
            "                decl,",
            "                formattedAtom);",
            "        }",
            "        else",
            "        {"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36118,
      "severity": "Error",
      "name": "subTypeHasSubsetOfAbstractAtomsToSuperType",
      "message": "subtype '$0' must have the same target/stage support as the supertype; '$0' is missing '$1'",
      "line": 1270,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14698,
          "statement": "Diagnostics::subTypeHasSubsetOfAbstractAtomsToSuperType, inheritanceParentDecl, failedAvailableCapabilityConjunction);",
          "context_before": [
            "        maybeDiagnose(",
            "            getSink(),",
            "            getOptionSet(),",
            "            DiagnosticCategory::Capability,",
            "            inheritanceParentDecl,"
          ],
          "context_after": [
            "            inheritanceParentDecl,",
            "            failedAvailableCapabilityConjunction);",
            "        maybeDiagnose(",
            "            getSink(),",
            "            getOptionSet(),"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36119,
      "severity": "Error",
      "name": "requirmentHasSubsetOfAbstractAtomsToImplementation",
      "message": "requirement '$0' must have the same target/stage support as the implementation; '$0' is missing '$1'",
      "line": 1275,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14650,
          "statement": "Diagnostics::requirmentHasSubsetOfAbstractAtomsToImplementation, implDecl, failedAvailableCapabilityConjunction);",
          "context_before": [
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    implDecl,"
          ],
          "context_after": [
            "                    implDecl,",
            "                    failedAvailableCapabilityConjunction);",
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    getOptionSet(),"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 36120,
      "severity": "Error",
      "name": "targetSwitchCapCasesConflict",
      "message": "the capability for case '$0' is '$1', which is conflicts with previous case which requires '$2'.In target_switch, if two cases are belong to the same target, then one capability set has to be a subset of the other.",
      "line": 1282,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14324,
          "statement": "Diagnostics::targetSwitchCapCasesConflict, caseName,    // arg0 newSet,      // arg1 currentSet); // arg2",
          "context_before": [
            "            maybeDiagnose(",
            "                Base::getSink(),",
            "                outerContext.getOptionSet(),",
            "                DiagnosticCategory::Capability,",
            "                loc,"
          ],
          "context_after": [
            "                caseName,    // arg0",
            "                newSet,      // arg1",
            "                currentSet); // arg2",
            "        }",
            "    }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31000,
      "severity": "Warning",
      "name": "unknownAttributeName",
      "message": "unknown attribute '$0'",
      "line": 1292,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1212,
          "statement": "getSink()->diagnose(uncheckedAttr, Diagnostics::unknownAttributeName, attrName);",
          "context_before": [
            "    auto attrName = uncheckedAttr->getKeywordName();",
            "    auto attrDecl = lookUpAttributeDecl(attrName, uncheckedAttr->scope);",
            "",
            "    if (!attrDecl)",
            "    {"
          ],
          "context_after": [
            "        return uncheckedAttr;",
            "    }",
            "",
            "    if (!attrDecl->syntaxClass.isSubClassOf<Attribute>())",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31001,
      "severity": "Error",
      "name": "attributeArgumentCountMismatch",
      "message": "attribute '$0' expects $1 arguments ($2 provided)",
      "line": 1293,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 727,
          "statement": "Diagnostics::attributeArgumentCountMismatch, attr->keywordName, \"1...2\", argsCount);",
          "context_before": [
            "        const auto argsCount = opAttr->args.getCount();",
            "        if (argsCount < 1 || argsCount > 2)",
            "        {",
            "            sink->diagnose(",
            "                attr,"
          ],
          "context_after": [
            "                attr->keywordName,",
            "                \"1...2\",",
            "                argsCount);",
            "        }",
            "        else if (!as<IntegerLiteralExpr>(opAttr->args[0]))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1289,
          "statement": "Diagnostics::attributeArgumentCountMismatch, attrName, paramCount, argCount);",
          "context_before": [
            "",
            "    if (mismatch)",
            "    {",
            "        getSink()->diagnose(",
            "            attr,"
          ],
          "context_after": [
            "            attrName,",
            "            paramCount,",
            "            argCount);",
            "        return uncheckedAttr;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31002,
      "severity": "Error",
      "name": "attributeNotApplicable",
      "message": "attribute '$0' is not valid here",
      "line": 1298,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1083,
          "statement": "getSink()->diagnose(attr, Diagnostics::attributeNotApplicable, attr->getKeywordName());",
          "context_before": [
            "    else if (const auto derivativeMemberAttr = as<DerivativeMemberAttribute>(attr))",
            "    {",
            "        auto varDecl = as<VarDeclBase>(attrTarget);",
            "        if (!varDecl)",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "    }",
            "    else if (auto deprecatedAttr = as<DeprecatedAttribute>(attr))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1326,
          "statement": "getSink()->diagnose(attr, Diagnostics::attributeNotApplicable, attrName);",
          "context_before": [
            "        break;",
            "    };",
            "",
            "    if (!validTarget)",
            "    {"
          ],
          "context_after": [
            "        return uncheckedAttr;",
            "    }",
            "",
            "    // Now apply type-specific validation to the attribute.",
            "    if (!validateAttribute(attr, attrDecl, attrTarget))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1572,
          "statement": "Diagnostics::attributeNotApplicable, diffType, declRefExpr->type);",
          "context_before": [
            "        }",
            "        if (!varDecl->parentDecl)",
            "        {",
            "            getSink()->diagnose(",
            "                derivativeMemberAttr,"
          ],
          "context_after": [
            "                diffType,",
            "                declRefExpr->type);",
            "        }",
            "        if (auto memberExpr = as<StaticMemberExpr>(declRefExpr))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31003,
      "severity": "Error",
      "name": "badlyDefinedPatchConstantFunc",
      "message": "hull shader '$0' has has badly defined 'patchconstantfunc' attribute.",
      "line": 1300,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 738,
          "statement": "sink->diagnose(attr, Diagnostics::badlyDefinedPatchConstantFunc, entryPointName);",
          "context_before": [
            "",
            "        if (attr)",
            "        {",
            "            if (attr->args.getCount() != 1)",
            "            {"
          ],
          "context_after": [
            "                return;",
            "            }",
            "",
            "            Expr* expr = attr->args[0];",
            "            StringLiteralExpr* stringLit = as<StringLiteralExpr>(expr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 747,
          "statement": "sink->diagnose(expr, Diagnostics::badlyDefinedPatchConstantFunc, entryPointName);",
          "context_before": [
            "            Expr* expr = attr->args[0];",
            "            StringLiteralExpr* stringLit = as<StringLiteralExpr>(expr);",
            "",
            "            if (!stringLit)",
            "            {"
          ],
          "context_after": [
            "                return;",
            "            }",
            "",
            "            // We look up the patch-constant function by its name in the module",
            "            // scope of the translation unit that declared the HS entry point."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31004,
      "severity": "Error",
      "name": "expectedSingleIntArg",
      "message": "attribute '$0' expects a single int argument",
      "line": 1306,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 753,
          "statement": "getSink()->diagnose(attr, Diagnostics::expectedSingleIntArg, attr->keywordName);",
          "context_before": [
            "    else if (as<OutputControlPointsAttribute>(attr))",
            "    {",
            "        // Let it go thru iff single integral attribute",
            "        if (!hasIntArgs(attr, 1))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else if (auto attrUsageAttr = as<AttributeUsageAttribute>(attr))",
            "    {",
            "        uint32_t targetClassId = (uint32_t)UserDefinedAttributeTargets::None;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 785,
          "statement": "getSink()->diagnose(attr, Diagnostics::expectedSingleIntArg, attr->keywordName);",
          "context_before": [
            "            {",
            "                targetClassId = (uint32_t)(cInt->getValue());",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "                return nullptr;",
            "            }",
            "        }",
            "        if (!getAttributeTargetSyntaxClasses(attrUsageAttr->targetSyntaxClass, targetClassId))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31005,
      "severity": "Error",
      "name": "expectedSingleStringArg",
      "message": "attribute '$0' expects a single string argument",
      "line": 1307,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 716,
          "statement": "getSink()->diagnose(attr, Diagnostics::expectedSingleStringArg, attr->keywordName);",
          "context_before": [
            "        (as<PartitioningAttribute>(attr)) || (as<PatchConstantFuncAttribute>(attr)))",
            "    {",
            "        // Let it go thru iff single string attribute",
            "        if (!hasStringArgs(attr, 1))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else if (auto opAttr = as<SPIRVInstructionOpAttribute>(attr))",
            "    {",
            "        auto sink = getSink();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31006,
      "severity": "Error",
      "name": "attributeFunctionNotFound",
      "message": "Could not find function '$0' for attribute'$1'",
      "line": 1309,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 770,
          "statement": "Diagnostics::attributeFunctionNotFound, name, \"patchconstantfunc\");",
          "context_before": [
            "            DeclRef<FuncDecl> patchConstantFuncDeclRef = findFunctionDeclByName(module, name, sink);",
            "            if (!patchConstantFuncDeclRef)",
            "            {",
            "                sink->diagnose(",
            "                    expr,"
          ],
          "context_after": [
            "                    name,",
            "                    \"patchconstantfunc\");",
            "                return;",
            "            }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31007,
      "severity": "Error",
      "name": "attributeExpectedIntArg",
      "message": "attribute '$0' expects argument $1 to be int",
      "line": 1315,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 734,
          "statement": "sink->diagnose(attr, Diagnostics::attributeExpectedIntArg, attr->keywordName, 0);",
          "context_before": [
            "                \"1...2\",",
            "                argsCount);",
            "        }",
            "        else if (!as<IntegerLiteralExpr>(opAttr->args[0]))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else if (argsCount > 1 && !as<StringLiteralExpr>(opAttr->args[1]))",
            "        {",
            "            sink->diagnose(attr, Diagnostics::attributeExpectedStringArg, attr->keywordName, 1);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31008,
      "severity": "Error",
      "name": "attributeExpectedStringArg",
      "message": "attribute '$0' expects argument $1 to be string",
      "line": 1316,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 738,
          "statement": "sink->diagnose(attr, Diagnostics::attributeExpectedStringArg, attr->keywordName, 1);",
          "context_before": [
            "        {",
            "            sink->diagnose(attr, Diagnostics::attributeExpectedIntArg, attr->keywordName, 0);",
            "        }",
            "        else if (argsCount > 1 && !as<StringLiteralExpr>(opAttr->args[1]))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else if (as<MaxTessFactorAttribute>(attr))",
            "    {",
            "        if (!hasFloatArgs(attr, 1))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31009,
      "severity": "Error",
      "name": "expectedSingleFloatArg",
      "message": "attribute '$0' expects a single floating point argument",
      "line": 1322,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 745,
          "statement": "getSink()->diagnose(attr, Diagnostics::expectedSingleFloatArg, attr->keywordName);",
          "context_before": [
            "    }",
            "    else if (as<MaxTessFactorAttribute>(attr))",
            "    {",
            "        if (!hasFloatArgs(attr, 1))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else if (as<OutputControlPointsAttribute>(attr))",
            "    {",
            "        // Let it go thru iff single integral attribute"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31100,
      "severity": "Error",
      "name": "unknownStageName",
      "message": "unknown stage name '$0'",
      "line": 1328,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 449,
          "statement": "Diagnostics::unknownStageName, caseStmt->capabilityToken);",
          "context_before": [
            "        {",
            "            if (!isStage && caseStmt->capability != (int32_t)CapabilityName::Invalid)",
            "            {",
            "                getSink()->diagnose(",
            "                    caseStmt->capabilityToken.loc,"
          ],
          "context_after": [
            "                    caseStmt->capabilityToken);",
            "            }",
            "            caseStmt->capability = (int32_t)canonicalStage;",
            "        }",
            "        else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31101,
      "severity": "Error",
      "name": "unknownImageFormatName",
      "message": "unknown image format '$0'",
      "line": 1329,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 911,
          "statement": "getSink()->diagnose(attr->args[0], Diagnostics::unknownImageFormatName, formatName);",
          "context_before": [
            "",
            "        if (attr->keywordName->text.getUnownedSlice() == toSlice(\"image\"))",
            "        {",
            "            if (!findImageFormatByName(formatName.getUnownedSlice(), &format))",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        else",
            "        {",
            "            if (!findVkImageFormatByName(formatName.getUnownedSlice(), &format))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 918,
          "statement": "getSink()->diagnose(attr->args[0], Diagnostics::unknownImageFormatName, formatName);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            if (!findVkImageFormatByName(formatName.getUnownedSlice(), &format))",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        formatAttr->format = format;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31101,
      "severity": "Error",
      "name": "unknownDiagnosticName",
      "message": "unknown diagnostic '$0'",
      "line": 1330,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 937,
          "statement": "getSink()->diagnose(attr->args[0], Diagnostics::unknownDiagnosticName, diagnosticName);",
          "context_before": [
            "        }",
            "",
            "        auto diagnosticInfo = findDiagnosticByName(diagnosticName.getUnownedSlice());",
            "        if (!diagnosticInfo)",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        allowAttr->diagnostic = diagnosticInfo;",
            "    }",
            "    else if (auto dllImportAttr = as<DllImportAttribute>(attr))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.cpp",
          "line": 81,
          "statement": "outDiagnostic->diagnose(SourceLoc(), Diagnostics::unknownDiagnosticName, identifier);",
          "context_before": [
            "    // If it starts with a digit we assume it a number",
            "    if (identifier.getLength() > 0 && (CharUtil::isDigit(identifier[0]) || identifier[0] == '-'))",
            "    {",
            "        if (SLANG_FAILED(StringUtil::parseInt(identifier, diagnosticId)))",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "",
            "        // If we use numbers, we don't worry if we can't find a diagnostic",
            "        // and silently ignore. This was the previous behavior, and perhaps"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.cpp",
          "line": 96,
          "statement": "outDiagnostic->diagnose(SourceLoc(), Diagnostics::unknownDiagnosticName, identifier);",
          "context_before": [
            "    else",
            "    {",
            "        diagnostic = diagnosticsLookup->findDiagnosticByName(identifier);",
            "        if (!diagnostic)",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "        diagnosticId = diagnostic->id;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.cpp",
          "line": 109,
          "statement": "outDiagnostic->diagnose(SourceLoc(), Diagnostics::unknownDiagnosticName, identifier);",
          "context_before": [
            "        diagnostic->severity != originalSeverity)",
            "    {",
            "        // Strictly speaking the diagnostic name is known, but it's not the right severity",
            "        // to be converted from, so it is an 'unknown name' in the context of severity...",
            "        // Or perhaps we want another diagnostic"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    // Override the diagnostic severity in the sink",
            "    sink->overrideDiagnosticSeverity(int(diagnosticId), overrideSeverity, diagnostic);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31102,
      "severity": "Error",
      "name": "nonPositiveNumThreads",
      "message": "expected a positive integer in 'numthreads' attribute, got '$0'",
      "line": 1331,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 423,
          "statement": "Diagnostics::nonPositiveNumThreads, constIntVal->getValue());",
          "context_before": [
            "                {",
            "                    if (constIntVal->getValue() < 1)",
            "                    {",
            "                        getSink()->diagnose(",
            "                            attr,"
          ],
          "context_after": [
            "                            constIntVal->getValue());",
            "                        return nullptr;",
            "                    }",
            "                    if (intValue->getType() != m_astBuilder->getIntType())",
            "                    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2024,
          "statement": "Diagnostics::nonPositiveNumThreads, cintVal->getValue());",
          "context_before": [
            "                    }",
            "                    else if (cintVal->getValue() < 1)",
            "                    {",
            "                        getSink()->diagnose(",
            "                            attr,"
          ],
          "context_after": [
            "                            cintVal->getValue());",
            "                        return nullptr;",
            "                    }",
            "                }",
            "                attr->extents[i] = intValue;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31103,
      "severity": "Error",
      "name": "invalidWaveSize",
      "message": "expected a power of 2 between 4 and 128, inclusive, in 'WaveSize' attribute, got '$0'",
      "line": 1336,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 476,
          "statement": "Diagnostics::invalidWaveSize, constIntVal->getValue());",
          "context_before": [
            "                }",
            "                if (!isValidWaveSize)",
            "                {",
            "                    getSink()->diagnose(",
            "                        attr,"
          ],
          "context_after": [
            "                        constIntVal->getValue());",
            "                    return nullptr;",
            "                }",
            "            }",
            "            value = intValue;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31104,
      "severity": "Warning",
      "name": "explicitUniformLocation",
      "message": "Explicit binding of uniform locations is discouraged. Prefer 'ConstantBuffer<$0>' over 'uniform $0'",
      "line": 1341,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 4207,
          "statement": "Diagnostics::explicitUniformLocation, as<VarDecl>(varLayout->varDecl).getDecl()->getType());",
          "context_before": [
            "                needDefaultConstantBuffer = true;",
            "                if (varLayout->varDecl.getDecl()->hasModifier<GLSLBindingAttribute>() ||",
            "                    varLayout->varDecl.getDecl()->hasModifier<GLSLLocationAttribute>())",
            "                    sink->diagnose(",
            "                        varLayout->varDecl,"
          ],
          "context_after": [
            "                        as<VarDecl>(varLayout->varDecl).getDecl()->getType());",
            "                diagnoseGlobalUniform(",
            "                    &sharedContext,",
            "                    as<VarDeclBase>(varLayout->varDecl.getDecl()));",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31105,
      "severity": "Warning",
      "name": "imageFormatUnsupportedByBackend",
      "message": "Image format '$0' is not explicitly supported by the $1 backend, using supported format '$2' instead.",
      "line": 1347,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-glsl.cpp",
          "line": 660,
          "statement": "Diagnostics::imageFormatUnsupportedByBackend, formatInfo.name, \"GLSL\", \"unknown\");",
          "context_before": [
            "        const auto formatInfo = getImageFormatInfo(format);",
            "        if (!isImageFormatSupportedByGLSL(format))",
            "        {",
            "            getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                formatInfo.name,",
            "                \"GLSL\",",
            "                \"unknown\");",
            "            format = ImageFormat::unknown;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-wgsl.cpp",
          "line": 446,
          "statement": "Diagnostics::imageFormatUnsupportedByBackend, imageFormatInfo.name, \"WGSL\", \"rgba32float\");",
          "context_before": [
            "        return \"rgba32float\";",
            "    default:",
            "        const auto imageFormatInfo = getImageFormatInfo(imageFormat);",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            imageFormatInfo.name,",
            "            \"WGSL\",",
            "            \"rgba32float\");",
            "        return \"rgba32float\";",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 2765,
          "statement": "Diagnostics::imageFormatUnsupportedByBackend, imageFormatInfo.name, \"SPIRV\", \"unknown\");",
          "context_before": [
            "            return SpvImageFormatR64i;",
            "        default:",
            "            const auto imageFormatInfo = getImageFormatInfo(imageFormat);",
            "            m_sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                imageFormatInfo.name,",
            "                \"SPIRV\",",
            "                \"unknown\");",
            "            return SpvImageFormatUnknown;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31120,
      "severity": "Error",
      "name": "invalidAttributeTarget",
      "message": "invalid syntax target for user defined attribute",
      "line": 1355,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 791,
          "statement": "getSink()->diagnose(attr, Diagnostics::invalidAttributeTarget);",
          "context_before": [
            "                return nullptr;",
            "            }",
            "        }",
            "        if (!getAttributeTargetSyntaxClasses(attrUsageAttr->targetSyntaxClass, targetClassId))",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "",
            "        // Create or find the AttributeDecl that represents the attribute",
            "        // this struct defines."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31125,
      "severity": "Error",
      "name": "attributeUsageAttributeMustBeOnNonGenericStruct",
      "message": "[__AttributeUsage] can only be applied to non-generic struct definitions",
      "line": 1356,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 764,
          "statement": "Diagnostics::attributeUsageAttributeMustBeOnNonGenericStruct, attr->keywordName);",
          "context_before": [
            "        auto structDecl = as<StructDecl>(attrTarget);",
            "        if (!structDecl)",
            "        {",
            "            getSink()->diagnose(",
            "                attr,"
          ],
          "context_after": [
            "                attr->keywordName);",
            "            return nullptr;",
            "        }",
            "        if (findNextOuterGeneric(structDecl) != nullptr)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 772,
          "statement": "Diagnostics::attributeUsageAttributeMustBeOnNonGenericStruct, attr->keywordName);",
          "context_before": [
            "        }",
            "        if (findNextOuterGeneric(structDecl) != nullptr)",
            "        {",
            "            getSink()->diagnose(",
            "                attr,"
          ],
          "context_after": [
            "                attr->keywordName);",
            "            return nullptr;",
            "        }",
            "        if (attr->args.getCount() == 1)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31121,
      "severity": "Error",
      "name": "anyValueSizeExceedsLimit",
      "message": "'anyValueSize' cannot exceed $0",
      "line": 1361,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 511,
          "statement": "Diagnostics::anyValueSizeExceedsLimit, kMaxAnyValueSize);",
          "context_before": [
            "        const IRIntegerValue kMaxAnyValueSize = 0x7FFF;",
            "        if (value->getValue() > kMaxAnyValueSize)",
            "        {",
            "            getSink()->diagnose(",
            "                anyValueSizeAttr->loc,"
          ],
          "context_after": [
            "                kMaxAnyValueSize);",
            "            return nullptr;",
            "        }",
            "",
            "        anyValueSizeAttr->size = int32_t(value->getValue());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31122,
      "severity": "Error",
      "name": "associatedTypeNotAllowInComInterface",
      "message": "associatedtype not allowed in a [COM] interface",
      "line": 1363,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8083,
          "statement": "getSink()->diagnose(associatedType, Diagnostics::associatedTypeNotAllowInComInterface);",
          "context_before": [
            "    if (decl->findModifier<ComInterfaceAttribute>())",
            "    {",
            "        // `associatedtype` declaration is not allowed in a COM interface declaration.",
            "        for (auto associatedType : decl->getMembersOfType<AssocTypeDecl>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "}",
            "",
            "void SemanticsDeclBasesVisitor::visitStructDecl(StructDecl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31123,
      "severity": "Error",
      "name": "invalidGUID",
      "message": "'$0' is not a valid GUID",
      "line": 1368,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1067,
          "statement": "getSink()->diagnose(attr, Diagnostics::invalidGUID, guid);",
          "context_before": [
            "            {",
            "                continue;",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "                return nullptr;",
            "            }",
            "        }",
            "        comInterfaceAttr->guid = resultGUID.toString();",
            "        if (comInterfaceAttr->guid.getLength() != 32)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1074,
          "statement": "getSink()->diagnose(attr, Diagnostics::invalidGUID, guid);",
          "context_before": [
            "            }",
            "        }",
            "        comInterfaceAttr->guid = resultGUID.toString();",
            "        if (comInterfaceAttr->guid.getLength() != 32)",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "    }",
            "    else if (const auto derivativeMemberAttr = as<DerivativeMemberAttribute>(attr))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31124,
      "severity": "Error",
      "name": "structCannotImplementComInterface",
      "message": "a struct type cannot implement a [COM] interface",
      "line": 1369,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7652,
          "statement": "Diagnostics::structCannotImplementComInterface);",
          "context_before": [
            "                }",
            "                else if (const auto structDecl = as<StructDecl>(superTypeDecl))",
            "                {",
            "                    getSink()->diagnose(",
            "                        inheritanceDecl,"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "",
            "        // Don't check conformances for abstract types that"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31124,
      "severity": "Error",
      "name": "interfaceInheritingComMustBeCom",
      "message": "an interface type that inherits from a [COM] interface must itself be a [COM] interface",
      "line": 1374,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7645,
          "statement": "Diagnostics::interfaceInheritingComMustBeCom);",
          "context_before": [
            "                {",
            "                    if (!subInterfaceDecl->findModifier<ComInterfaceAttribute>())",
            "                    {",
            "                        getSink()->diagnose(",
            "                            inheritanceDecl,"
          ],
          "context_after": [
            "                    }",
            "                }",
            "                else if (const auto structDecl = as<StructDecl>(superTypeDecl))",
            "                {",
            "                    getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31130,
      "severity": "Error",
      "name": "derivativeMemberAttributeMustNameAMemberInExpectedDifferentialType",
      "message": "[DerivativeMember] must reference to a member in the associated differential type '$0'.",
      "line": 1380,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1590,
          "statement": "Diagnostics::derivativeMemberAttributeMustNameAMemberInExpectedDifferentialType, diffThisType);",
          "context_before": [
            "            }",
            "        }",
            "    }",
            "    getSink()->diagnose(",
            "        derivativeMemberAttr,"
          ],
          "context_after": [
            "        diffThisType);",
            "}",
            "",
            "Type* SemanticsVisitor::getDifferentialType(ASTBuilder* builder, Type* type, SourceLoc loc)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31131,
      "severity": "Error",
      "name": "invalidUseOfDerivativeMemberAttributeParentTypeIsNotDifferentiable",
      "message": "invalid use of [DerivativeMember], parent type is not differentiable.",
      "line": 1385,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1848,
          "statement": "Diagnostics::invalidUseOfDerivativeMemberAttributeParentTypeIsNotDifferentiable);",
          "context_before": [
            "    auto diffThisType = getDifferentialType(m_astBuilder, thisType, derivativeMemberAttr->loc);",
            "    if (!diffThisType)",
            "    {",
            "        getSink()->diagnose(",
            "            derivativeMemberAttr,"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsDeclHeaderVisitor::checkExtensionExternVarAttribute(",
            "    VarDeclBase* varDecl,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31132,
      "severity": "Error",
      "name": "derivativeMemberAttributeCanOnlyBeUsedOnMembers",
      "message": "[DerivativeMember] is allowed on members only.",
      "line": 1390,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1841,
          "statement": "Diagnostics::derivativeMemberAttributeCanOnlyBeUsedOnMembers);",
          "context_before": [
            "    auto thisType = calcThisType(makeDeclRef(varDecl->parentDecl));",
            "    if (!thisType)",
            "    {",
            "        getSink()->diagnose(",
            "            derivativeMemberAttr,"
          ],
          "context_after": [
            "    }",
            "    auto diffThisType = getDifferentialType(m_astBuilder, thisType, derivativeMemberAttr->loc);",
            "    if (!diffThisType)",
            "    {",
            "        getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31140,
      "severity": "Error",
      "name": "typeOfExternDeclMismatchesOriginalDefinition",
      "message": "type of `extern` decl '$0' differs from its original definition. expected '$1'.",
      "line": 1396,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1866,
          "statement": "Diagnostics::typeOfExternDeclMismatchesOriginalDefinition, varDecl, originalType);",
          "context_before": [
            "            auto extVarType = varDecl->type;",
            "            if (!extVarType.type || !extVarType.type->equals(originalType))",
            "            {",
            "                getSink()->diagnose(",
            "                    varDecl,"
          ],
          "context_after": [
            "                    varDecl,",
            "                    originalType);",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31141,
      "severity": "Error",
      "name": "definitionOfExternDeclMismatchesOriginalDefinition",
      "message": "`extern` decl '$0' is not consistent with its original definition.",
      "line": 1401,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1879,
          "statement": "Diagnostics::definitionOfExternDeclMismatchesOriginalDefinition, varDecl);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                varDecl,"
          ],
          "context_after": [
            "                varDecl);",
            "        }",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31142,
      "severity": "Error",
      "name": "ambiguousOriginalDefintionOfExternDecl",
      "message": "`extern` decl '$0' has ambiguous original definitions.",
      "line": 1406,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1819,
          "statement": "Diagnostics::ambiguousOriginalDefintionOfExternDecl, varDecl);",
          "context_before": [
            "                }",
            "                else if (filteredResult.isOverloaded())",
            "                {",
            "                    getSink()->diagnose(",
            "                        varDecl,"
          ],
          "context_after": [
            "                        varDecl);",
            "                }",
            "                else",
            "                {",
            "                    getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31143,
      "severity": "Error",
      "name": "missingOriginalDefintionOfExternDecl",
      "message": "no original definition found for `extern` decl '$0'.",
      "line": 1411,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1826,
          "statement": "Diagnostics::missingOriginalDefintionOfExternDecl, varDecl);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    getSink()->diagnose(",
            "                        varDecl,"
          ],
          "context_after": [
            "                        varDecl);",
            "                }",
            "            }",
            "            // The next part of the check is to make sure the type defined here is consistent with",
            "            // the original definition. Since we haven't checked the type of this decl yet, we defer"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31145,
      "severity": "Error",
      "name": "invalidCustomDerivative",
      "message": "invalid custom derivative attribute.",
      "line": 1417,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 31146,
      "severity": "Error",
      "name": "declAlreadyHasAttribute",
      "message": "'$0' already has attribute '[$1]'.",
      "line": 1418,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13279,
          "statement": "Diagnostics::declAlreadyHasAttribute, calleeDeclRef, getDerivativeAttrName<TDerivativeAttr>());",
          "context_before": [
            "    if (auto existingModifier = _findModifier<TDerivativeAttr>(calleeFunc))",
            "    {",
            "        // The primal function already has a `[*Derivative]` attribute, this is invalid.",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "            calleeDeclRef,",
            "            getDerivativeAttrName<TDerivativeAttr>());",
            "        visitor->getSink()->diagnose(",
            "            existingModifier->loc,",
            "            Diagnostics::seeDeclarationOf,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31147,
      "severity": "Error",
      "name": "cannotResolveOriginalFunctionForDerivative",
      "message": "cannot resolve the original function for the the custom derivative.",
      "line": 1419,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13182,
          "statement": "Diagnostics::cannotResolveOriginalFunctionForDerivative);",
          "context_before": [
            "",
            "    if (!checkedHigherOrderFuncExpr)",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "    List<Expr*> imaginaryArgs =",
            "        getImaginaryArgsToFunc(astBuilder, funcDecl, derivativeOfAttr->loc).args;",
            "    auto invokeExpr ="
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13212,
          "statement": "Diagnostics::cannotResolveOriginalFunctionForDerivative);",
          "context_before": [
            "",
            "    if (!calleeDeclRefExpr)",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    calleeDeclRefExpr->loc = higherOrderFuncExpr->loc;",
            "    if (derivativeOfAttr->args.getCount() > 0)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13248,
          "statement": "Diagnostics::cannotResolveOriginalFunctionForDerivative);",
          "context_before": [
            "",
            "    if (!calleeFunc)",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // For now, if calleeFunc or funcDecl is nested inside some generic aggregate,",
            "    // they must be the same generic decl. For example, using B<T>.f() as the original function"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31148,
      "severity": "Error",
      "name": "cannotResolveDerivativeFunction",
      "message": "cannot resolve the custom derivative function",
      "line": 1424,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12708,
          "statement": "visitor->getSink()->diagnose(attr, Diagnostics::cannotResolveDerivativeFunction);",
          "context_before": [
            "    {",
            "        if (declRefExpr->declRef)",
            "            visitor->ensureDecl(declRefExpr->declRef, DeclCheckState::TypesFullyResolved);",
            "        else",
            "        {"
          ],
          "context_after": [
            "            return;",
            "        }",
            "    }",
            "    else if (auto overloadedExpr = as<OverloadedExpr>(checkedFuncExpr))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12733,
          "statement": "visitor->getSink()->diagnose(attr, Diagnostics::cannotResolveDerivativeFunction);",
          "context_before": [
            "            }",
            "        }",
            "    }",
            "    else",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // If left value is true, then convert the",
            "    // inner type to an BorrowInOutParamType."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31149,
      "severity": "Error",
      "name": "customDerivativeSignatureMismatchAtPosition",
      "message": "invalid custom derivative. parameter type mismatch at position $0. expected '$1', got '$2'",
      "line": 1429,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12809,
          "statement": "Diagnostics::customDerivativeSignatureMismatchAtPosition, ii, qualTypeToString(argList[ii]->type), funcType->getParamTypeWithModeWrapper(ii)->toString());",
          "context_before": [
            "                        ctx.getASTBuilder()->getErrorType()) ||",
            "                    funcType->getParamPassingMode(ii) != paramDirections[ii])",
            "                {",
            "                    visitor->getSink()->diagnose(",
            "                        attr,"
          ],
          "context_after": [
            "                        ii,",
            "                        qualTypeToString(argList[ii]->type),",
            "                        funcType->getParamTypeWithModeWrapper(ii)->toString());",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31150,
      "severity": "Error",
      "name": "customDerivativeSignatureMismatch",
      "message": "invalid custom derivative. could not resolve function with expected signature '$0'",
      "line": 1434,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12888,
          "statement": "Diagnostics::customDerivativeSignatureMismatch);",
          "context_before": [
            "                        derivativeNextGeneric,",
            "                        &specializedDecl))",
            "                {",
            "                    visitor->getSink()->diagnose(",
            "                        attr,"
          ],
          "context_after": [
            "                    return;",
            "                }",
            "",
            "                calleeDeclRef->declRef = substituteDeclRef(",
            "                    SubstitutionSet(specializedDecl),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12927,
          "statement": "Diagnostics::customDerivativeSignatureMismatch, builder.produceString());",
          "context_before": [
            "    }",
            "    builder << \")\";",
            "",
            "    visitor->getSink()->diagnose(",
            "        attr,"
          ],
          "context_after": [
            "        builder.produceString());",
            "}",
            "",
            "template<typename TDerivativeAttr>",
            "const char* getDerivativeAttrName()"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31151,
      "severity": "Error",
      "name": "cannotResolveGenericArgumentForDerivativeFunction",
      "message": "The generic arguments to the derivative function cannot be deduced from the parameter list of the original function. Consider using [ForwardDerivative], [BackwardDerivative] or [PrimalSubstitute] attributes on the primal function with explicit generic arguments to associate it with a generic derivative function. Note that [ForwardDerivativeOf], [BackwardDerivativeOf], and [PrimalSubstituteOf] attributes are not supported when the generic arguments to the derivatives cannot be automatically deduced.",
      "line": 1439,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12784,
          "statement": "Diagnostics::cannotResolveGenericArgumentForDerivativeFunction);",
          "context_before": [
            "                // generic arguments from imaginary argument list.",
            "                // In this case we issue a diagnostic to ask the user to explicitly provide the",
            "                // arguments.",
            "                visitor->getSink()->diagnose(",
            "                    attr,"
          ],
          "context_after": [
            "                return;",
            "            }",
            "            if (isInterfaceRequirement(calleeDeclRef->declRef.getDecl()))",
            "            {",
            "                visitor->getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12870,
          "statement": "Diagnostics::cannotResolveGenericArgumentForDerivativeFunction);",
          "context_before": [
            "            if ((!originalNextGeneric) != (!derivativeNextGeneric))",
            "            {",
            "                // Diagnostic for when one is generic and the other is not.",
            "                visitor->getSink()->diagnose(",
            "                    attr,"
          ],
          "context_after": [
            "                return;",
            "            }",
            "",
            "            if (originalNextGeneric != derivativeNextGeneric)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13239,
          "statement": "Diagnostics::cannotResolveGenericArgumentForDerivativeFunction);",
          "context_before": [
            "                // generic decl, the most likely cause is a failure of generic argument",
            "                // inference.",
            "                //",
            "                visitor->getSink()->diagnose(",
            "                    derivativeOfAttr,"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "",
            "    if (!calleeFunc)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31152,
      "severity": "Error",
      "name": "cannotAssociateInterfaceRequirementWithDerivative",
      "message": "cannot associate an interface requirement with a derivative.",
      "line": 1451,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12637,
          "statement": "Diagnostics::cannotAssociateInterfaceRequirementWithDerivative);",
          "context_before": [
            "{",
            "    if (isInterfaceRequirement(funcDecl))",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            attr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    SemanticsContext::ExprLocalScope scope;",
            "    auto ctx = visitor->withExprLocalScope(&scope);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13263,
          "statement": "Diagnostics::cannotAssociateInterfaceRequirementWithDerivative);",
          "context_before": [
            "",
            "    if (isInterfaceRequirement(calleeFunc))",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "    if (isInterfaceRequirement(funcDecl))",
            "    {",
            "        visitor->getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31153,
      "severity": "Error",
      "name": "cannotUseInterfaceRequirementAsDerivative",
      "message": "cannot use an interface requirement as a derivative.",
      "line": 1456,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12791,
          "statement": "Diagnostics::cannotUseInterfaceRequirementAsDerivative);",
          "context_before": [
            "            }",
            "            if (isInterfaceRequirement(calleeDeclRef->declRef.getDecl()))",
            "            {",
            "                visitor->getSink()->diagnose(",
            "                    attr,"
          ],
          "context_after": [
            "                return;",
            "            }",
            "            if (funcType->getParamCount() != argList.getCount())",
            "            {",
            "                goto error;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13270,
          "statement": "Diagnostics::cannotUseInterfaceRequirementAsDerivative);",
          "context_before": [
            "    }",
            "    if (isInterfaceRequirement(funcDecl))",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            derivativeOfAttr,"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    if (auto existingModifier = _findModifier<TDerivativeAttr>(calleeFunc))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31154,
      "severity": "Error",
      "name": "customDerivativeSignatureThisParamMismatch",
      "message": "custom derivative does not match expected signature on `this`. Both original and derivative function must have the same `this` type.",
      "line": 1461,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12851,
          "statement": "Diagnostics::customDerivativeSignatureThisParamMismatch);",
          "context_before": [
            "                if (funcThisType &&",
            "                    !areTypesCompatibile(visitor, funcThisType, derivativeFuncThisType))",
            "                {",
            "                    visitor->getSink()->diagnose(",
            "                        attr,"
          ],
          "context_after": [
            "                    return;",
            "                }",
            "            }",
            "",
            "            // If the two decls are under different generic contexts, we'll need to check that"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31155,
      "severity": "Error",
      "name": "customDerivativeNotAllowedForMemberFunctionsOfDifferentiableType",
      "message": "custom derivative is not allowed for non-static member functions of a differentiable type.",
      "line": 1467,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 31156,
      "severity": "Error",
      "name": "customDerivativeExpectedStatic",
      "message": "expected a static definition for the custom derivative.",
      "line": 1472,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 12825,
          "statement": "visitor->getSink()->diagnose(attr, Diagnostics::customDerivativeExpectedStatic);",
          "context_before": [
            "",
            "            bool derivativeFuncIsStatic = isEffectivelyStatic(calleeDeclRef->declRef.getDecl());",
            "",
            "            if (expectStaticFunc && !derivativeFuncIsStatic)",
            "            {"
          ],
          "context_after": [
            "                return;",
            "            }",
            "",
            "            if (!derivativeFuncIsStatic)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31157,
      "severity": "Error",
      "name": "overloadedFuncUsedWithDerivativeOfAttributes",
      "message": "cannot resolve overloaded functions for derivative-of attributes.",
      "line": 1477,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13203,
          "statement": "Diagnostics::overloadedFuncUsedWithDerivativeOfAttributes);",
          "context_before": [
            "            calleeDeclRefExpr = as<DeclRefExpr>(resolvedFuncExpr->baseFunction);",
            "            if (!calleeDeclRef && as<OverloadedExpr>(resolvedFuncExpr->baseFunction))",
            "            {",
            "                visitor->getSink()->diagnose(",
            "                    derivativeOfAttr,"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "",
            "    if (!calleeDeclRefExpr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31158,
      "severity": "Error",
      "name": "primalSubstituteTargetMustHaveHigherDifferentiabilityLevel",
      "message": "primal substitute function for differentiable method must also be differentiable. Use [Differentiable] or [TreatAsDifferentiable] (for empty derivatives)",
      "line": 1482,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13392,
          "statement": "Diagnostics::primalSubstituteTargetMustHaveHigherDifferentiabilityLevel, declRefExpr->declRef.getDecl(), funcDecl);",
          "context_before": [
            "            auto currDiffLevel = visitor->getShared()->getFuncDifferentiableLevel(funcDecl);",
            "            if (targetDiffLevel < currDiffLevel)",
            "            {",
            "                visitor->getSink()->diagnose(",
            "                    attr->loc,"
          ],
          "context_after": [
            "                    declRefExpr->declRef.getDecl(),",
            "                    funcDecl);",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31159,
      "severity": "Warning",
      "name": "noDerivativeOnNonDifferentiableThisType",
      "message": "There is no derivative calculated for member '$0' because the parent struct is not differentiable. If this is intended, consider using [NoDiffThis] on the function '$1' to suppress this warning. Alternatively, users can mark the parent struct as [Differentiable] to propagate derivatives.",
      "line": 1488,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1747,
          "statement": "Diagnostics::noDerivativeOnNonDifferentiableThisType, memberExpr->declRef.getDecl(), this->m_parentFunc);",
          "context_before": [
            "                return;",
            "            }",
            "",
            "            getSink()->diagnose(",
            "                memberExpr->loc,"
          ],
          "context_after": [
            "                memberExpr->declRef.getDecl(),",
            "                this->m_parentFunc);",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31160,
      "severity": "Error",
      "name": "invalidAddressOf",
      "message": "'__getAddress' only supports groupshared variables and members of groupshared/device memory.",
      "line": 1497,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4537,
          "statement": "getSink()->diagnose(expr, Diagnostics::invalidAddressOf);",
          "context_before": [
            "    // Only allow known expressions.",
            "    expr->type =",
            "        getValidTypeForAddressOf(this, m_astBuilder, expr->arg, getType(m_astBuilder, expr->arg));",
            "    if (!expr->type)",
            "    {"
          ],
          "context_after": [
            "        expr->type = m_astBuilder->getErrorType();",
            "    }",
            "    return expr;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31200,
      "severity": "Warning",
      "name": "deprecatedUsage",
      "message": "$0 has been deprecated: $1",
      "line": 1502,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 331,
          "statement": "Diagnostics::deprecatedUsage, declRef.getName(), deprecatedAttr->message);",
          "context_before": [
            "    }",
            "    if (auto deprecatedAttr = declRef.getDecl()->findModifier<DeprecatedAttribute>())",
            "    {",
            "        getSink()->diagnose(",
            "            loc,"
          ],
          "context_after": [
            "            declRef.getName(),",
            "            deprecatedAttr->message);",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31201,
      "severity": "Error",
      "name": "modifierNotAllowed",
      "message": "modifier '$0' is not allowed here.",
      "line": 1503,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1716,
          "statement": "getSink()->diagnose(m, Diagnostics::modifierNotAllowed, m);",
          "context_before": [
            "            isGLSLInput = true;",
            "        if (!isModifierAllowedOnDecl(isGLSLInput, m->astNodeType, decl))",
            "        {",
            "            if (!ignoreUnallowedModifier)",
            "            {"
          ],
          "context_after": [
            "                return nullptr;",
            "            }",
            "            return m;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31202,
      "severity": "Error",
      "name": "duplicateModifier",
      "message": "modifier '$0' is redundant or conflicting with existing modifier '$1'",
      "line": 1504,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2190,
          "statement": "Diagnostics::duplicateModifier, modifier, existingModifier);",
          "context_before": [
            "        {",
            "            if (mapExclusiveGroupToModifier.tryGetValue(conflictGroup, existingModifier))",
            "            {",
            "                getSink()->diagnose(",
            "                    modifier->loc,"
          ],
          "context_after": [
            "                    modifier,",
            "                    existingModifier);",
            "            }",
            "            mapExclusiveGroupToModifier[conflictGroup] = modifier;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31203,
      "severity": "Error",
      "name": "cannotExportIncompleteType",
      "message": "cannot export incomplete type '$0'",
      "line": 1509,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10047,
          "statement": "getSink()->diagnose(aggTypeDecl->loc, Diagnostics::cannotExportIncompleteType, aggTypeDecl);",
          "context_before": [
            "",
            "void SemanticsDeclBodyVisitor::visitAggTypeDecl(AggTypeDecl* aggTypeDecl)",
            "{",
            "    if (aggTypeDecl->hasTag(TypeTag::Incomplete) && aggTypeDecl->hasModifier<HLSLExportModifier>())",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    auto structDecl = as<StructDecl>(aggTypeDecl);",
            "    if (!structDecl)",
            "        return;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31206,
      "severity": "Error",
      "name": "memoryQualifierNotAllowedOnANonImageTypeParameter",
      "message": "modifier $0 is not allowed on a non image type parameter.",
      "line": 1510,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9675,
          "statement": "Diagnostics::memoryQualifierNotAllowedOnANonImageTypeParameter, mod);",
          "context_before": [
            "        if (!MemoryQualifierSet)",
            "            return;",
            "        for (auto mod : MemoryQualifierSet->getModifiers())",
            "            getSink()->diagnose(",
            "                paramDecl,"
          ],
          "context_after": [
            "                mod);",
            "    }",
            "}",
            "",
            "// This checks that the declaration is marked as \"out\" and changes the hlsl"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31208,
      "severity": "Error",
      "name": "requireInputDecoratedVarForParameter",
      "message": "$0 expects for argument $1 a type which is a shader input (`in`) variable.",
      "line": 1515,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 4335,
          "statement": "Diagnostics::requireInputDecoratedVarForParameter, decl, glslRequireShaderInputParameter->parameterNumber);",
          "context_before": [
            "            if (!irArgs[glslRequireShaderInputParameter->parameterNumber]",
            "                     ->findDecoration<IRGlobalInputDecoration>())",
            "            {",
            "                this->context->getSink()->diagnose(",
            "                    expr,"
          ],
          "context_after": [
            "                    decl,",
            "                    glslRequireShaderInputParameter->parameterNumber);",
            "            }",
            "            return;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31210,
      "severity": "Error",
      "name": "derivativeGroupQuadMustBeMultiple2ForXYThreads",
      "message": "compute derivative group quad requires thread dispatch count of X and Y to each be at a multiple of 2",
      "line": 1520,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-util.cpp",
          "line": 2425,
          "statement": "sink->diagnose(errorLoc, Diagnostics::derivativeGroupQuadMustBeMultiple2ForXYThreads);",
          "context_before": [
            "        z = numThreadsDecor->getZ()->getValue();",
            "",
            "    if (quadAttr)",
            "    {",
            "        if (x % 2 != 0 || y % 2 != 0)"
          ],
          "context_after": [
            "    }",
            "    else if (linearAttr)",
            "    {",
            "        if ((x * y * z) % 4 != 0)",
            "            sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31211,
      "severity": "Error",
      "name": "derivativeGroupLinearMustBeMultiple4ForTotalThreadCount",
      "message": "compute derivative group linear requires total thread dispatch count to be at a multiple of 4",
      "line": 1526,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-util.cpp",
          "line": 2432,
          "statement": "Diagnostics::derivativeGroupLinearMustBeMultiple4ForTotalThreadCount);",
          "context_before": [
            "    else if (linearAttr)",
            "    {",
            "        if ((x * y * z) % 4 != 0)",
            "            sink->diagnose(",
            "                errorLoc,"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "int getIRVectorElementSize(IRType* type)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31212,
      "severity": "Error",
      "name": "onlyOneOfDerivativeGroupLinearOrQuadCanBeSet",
      "message": "cannot set compute derivative group linear and compute derivative group quad at the same time",
      "line": 1531,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-util.cpp",
          "line": 2409,
          "statement": "sink->diagnose(errorLoc, Diagnostics::onlyOneOfDerivativeGroupLinearOrQuadCanBeSet);",
          "context_before": [
            "    if (!numThreadsDecor)",
            "        return;",
            "",
            "    if (quadAttr && linearAttr)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    IRIntegerValue x = 1;",
            "    IRIntegerValue y = 1;",
            "    IRIntegerValue z = 1;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31213,
      "severity": "Error",
      "name": "cudaKernelMustReturnVoid",
      "message": "return type of a CUDA kernel function cannot be non-void.",
      "line": 1536,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10355,
          "statement": "getSink()->diagnose(decl, Diagnostics::cudaKernelMustReturnVoid);",
          "context_before": [
            "    // If this method is intended to be a CUDA kernel, verify that the return type is void.",
            "    if (decl->findModifier<CudaKernelAttribute>())",
            "    {",
            "        if (decl->returnType.type && !decl->returnType.type->equals(m_astBuilder->getVoidType()))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    checkInterfaceRequirement(decl);",
            "    checkVisibility(decl);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31214,
      "severity": "Error",
      "name": "differentiableKernelEntryPointCannotHaveDifferentiableParams",
      "message": "differentiable kernel entry point cannot have differentiable parameters. Consider using DiffTensorView to pass differentiable data, or marking this parameter with 'no_diff'",
      "line": 1541,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13423,
          "statement": "Diagnostics::differentiableKernelEntryPointCannotHaveDifferentiableParams);",
          "context_before": [
            "            {",
            "                if (!paramDecl->hasModifier<NoDiffModifier>())",
            "                {",
            "                    visitor->getSink()->diagnose(",
            "                        paramDecl,"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31215,
      "severity": "Error",
      "name": "cannotUseUnsizedTypeInConstantBuffer",
      "message": "cannot use unsized type '$0' in a constant buffer.",
      "line": 1547,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2988,
          "statement": "Diagnostics::cannotUseUnsizedTypeInConstantBuffer, trailingArrayType);",
          "context_before": [
            "                getTrailingUnsizedArrayElement(elementType, varDecl, trailingArrayType);",
            "            if (trailingArrayField && !isOpaqueHandleType(trailingArrayType->getElementType()))",
            "            {",
            "                getSink()->diagnose(",
            "                    trailingArrayField->loc,"
          ],
          "context_after": [
            "                    trailingArrayType);",
            "                getSink()->diagnose(varDecl->loc, Diagnostics::seeConstantBufferDefinition);",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeConstantBufferDefinition"
          ]
        }
      ]
    },
    {
      "id": 31216,
      "severity": "Error",
      "name": "unrecognizedGLSLLayoutQualifier",
      "message": "GLSL layout qualifier is unrecognized",
      "line": 1552,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1660,
          "statement": "getSink()->diagnose(uncheckedAttr, Diagnostics::unrecognizedGLSLLayoutQualifier);",
          "context_before": [
            "    CASE(UncheckedGLSLHitObjectAttributesAttribute, VulkanHitObjectAttributesAttribute)",
            "    CASE(UncheckedGLSLCallablePayloadAttribute, VulkanCallablePayloadAttribute)",
            "    CASE(UncheckedGLSLCallablePayloadInAttribute, VulkanCallablePayloadInAttribute)",
            "    else",
            "    {"
          ],
          "context_after": [
            "    }",
            "#undef CASE",
            "",
            "    if (attr)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31217,
      "severity": "Error",
      "name": "unrecognizedGLSLLayoutQualifierOrRequiresAssignment",
      "message": "GLSL layout qualifier is unrecognized or requires assignment",
      "line": 1553,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 9466,
          "statement": "Diagnostics::unrecognizedGLSLLayoutQualifierOrRequiresAssignment);",
          "context_before": [
            "",
            "            if (as<GLSLUnparsedLayoutModifier>(modifier))",
            "            {",
            "                parser->diagnose(",
            "                    modifier,"
          ],
          "context_after": [
            "            }",
            "",
            "            listBuilder.add(modifier);",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31218,
      "severity": "Error",
      "name": "specializationConstantMustBeScalar",
      "message": "specialization constant must be a scalar.",
      "line": 1558,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13461,
          "statement": "getSink()->diagnose(modifier, Diagnostics::specializationConstantMustBeScalar);",
          "context_before": [
            "        {",
            "            // Specialization constant.",
            "            // Check that type is basic type.",
            "            if (!as<BasicExpressionType>(varDecl->getType()) && !as<ErrorType>(varDecl->getType()))",
            "            {"
          ],
          "context_after": [
            "            }",
            "            hasSpecConstAttr = true;",
            "        }",
            "        else if (as<PushConstantAttribute>(modifier))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31219,
      "severity": "Error",
      "name": "pushOrSpecializationConstantCannotBeStatic",
      "message": "push or specialization constants cannot be 'static'.",
      "line": 1563,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13485,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::pushOrSpecializationConstantCannotBeStatic);",
          "context_before": [
            "    }",
            "    if (hasSpecConstAttr || hasPushConstAttr)",
            "    {",
            "        if (varDecl->findModifier<HLSLStaticModifier>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "}",
            "",
            "void SemanticsDeclAttributesVisitor::checkHLSLRegisterSemantic("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31220,
      "severity": "Error",
      "name": "variableCannotBePushAndSpecializationConstant",
      "message": "'$0' cannot be a push constant and a specialization constant at the same time",
      "line": 1568,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13478,
          "statement": "Diagnostics::variableCannotBePushAndSpecializationConstant, varDecl->getName());",
          "context_before": [
            "    }",
            "    if (hasSpecConstAttr && hasPushConstAttr)",
            "    {",
            "        getSink()->diagnose(",
            "            varDecl,"
          ],
          "context_after": [
            "            varDecl->getName());",
            "    }",
            "    if (hasSpecConstAttr || hasPushConstAttr)",
            "    {",
            "        if (varDecl->findModifier<HLSLStaticModifier>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31221,
      "severity": "Error",
      "name": "invalidHLSLRegisterName",
      "message": "invalid HLSL register name '$0'.",
      "line": 1573,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13499,
          "statement": "Diagnostics::invalidHLSLRegisterName, registerSemantic->registerName);",
          "context_before": [
            "    auto registerName = registerSemantic->registerName.getContent();",
            "    if (registerName.getLength() < 1)",
            "    {",
            "        getSink()->diagnose(",
            "            registerSemantic->registerName.getLoc(),"
          ],
          "context_after": [
            "            registerSemantic->registerName);",
            "        return;",
            "    }",
            "",
            "    // Check to make sure the HLSL semantic register name is consistent with the resource type."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31222,
      "severity": "Error",
      "name": "invalidHLSLRegisterNameForType",
      "message": "invalid HLSL register name '$0' for type '$1'.",
      "line": 1574,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13569,
          "statement": "Diagnostics::invalidHLSLRegisterNameForType, registerName, varType);",
          "context_before": [
            "    }",
            "    if (!isValid)",
            "    {",
            "        getSink()->diagnose(",
            "            registerSemantic->registerName.getLoc(),"
          ],
          "context_after": [
            "            registerName,",
            "            varType);",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31223,
      "severity": "Error",
      "name": "ExternAndExportVarDeclMustBeConst",
      "message": "extern and export variables must be static const: '$0'",
      "line": 1579,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 238,
          "statement": "Diagnostics::ExternAndExportVarDeclMustBeConst, decl->getName());",
          "context_before": [
            "                hasSpecializationConstant = true;",
            "        }",
            "        if (hasExportOrExtern && hasConst != hasStatic)",
            "            getSink()->diagnose(",
            "                decl,"
          ],
          "context_after": [
            "                decl->getName());",
            "",
            "",
            "        // Global const or uniform variables with initializers must be static",
            "        // In HLSL, const global variables without static are uniform parameters"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31224,
      "severity": "Error",
      "name": "constGlobalVarWithInitRequiresStatic",
      "message": "global const variable with initializer must be declared static: '$0'",
      "line": 1585,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 256,
          "statement": "Diagnostics::constGlobalVarWithInitRequiresStatic, decl->getName());",
          "context_before": [
            "            auto moduleDecl = getModuleDecl(decl);",
            "            if (!moduleDecl || !moduleDecl->hasModifier<GLSLModuleModifier>())",
            "            {",
            "                getSink()->diagnose(",
            "                    decl,"
          ],
          "context_after": [
            "                    decl->getName());",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31225,
      "severity": "Error",
      "name": "staticConstVariableRequiresInitializer",
      "message": "static const variable '$0' must have an initializer",
      "line": 1591,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2444,
          "statement": "Diagnostics::staticConstVariableRequiresInitializer, varDecl);",
          "context_before": [
            "            // Don't error for interface member variables",
            "            !isExtern && !as<InterfaceDecl>(varDecl->parentDecl))",
            "        {",
            "            getSink()->diagnose(",
            "                varDecl,"
          ],
          "context_after": [
            "                varDecl);",
            "        }",
            "    }",
            "",
            "    checkVisibility(varDecl);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 32000,
      "severity": "Error",
      "name": "invalidEnumTagType",
      "message": "invalid tag type for 'enum': '$0'",
      "line": 1599,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8382,
          "statement": "getSink()->diagnose(loc, Diagnostics::invalidEnumTagType, type);",
          "context_before": [
            "        return;",
            "",
            "    // By default, don't allow other types to be used",
            "    // as an `enum` tag type.",
            "    //"
          ],
          "context_after": [
            "}",
            "",
            "bool SemanticsVisitor::_hasExplicitConstructor(StructDecl* structDecl, bool checkBaseType)",
            "{",
            "    if (!structDecl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 32003,
      "severity": "Error",
      "name": "unexpectedEnumTagExpr",
      "message": "unexpected form for 'enum' tag value expression",
      "line": 1600,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8657,
          "statement": "getSink()->diagnose(explicitTagValExpr, Diagnostics::unexpectedEnumTagExpr);",
          "context_before": [
            "                    defaultTag = constIntVal->getValue();",
            "                }",
            "                else",
            "                {",
            "                    // TODO: need to handle other possibilities here"
          ],
          "context_after": [
            "                }",
            "            }",
            "            else",
            "            {",
            "                // If this happens, then the explicit tag value expression"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30300,
      "severity": "Error",
      "name": "assocTypeInInterfaceOnly",
      "message": "'associatedtype' can only be defined in an 'interface'.",
      "line": 1603,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8768,
          "statement": "getSink()->diagnose(decl, Slang::Diagnostics::assocTypeInInterfaceOnly);",
          "context_before": [
            "void SemanticsDeclHeaderVisitor::visitAssocTypeDecl(AssocTypeDecl* decl)",
            "{",
            "    // assoctype only allowed in an interface",
            "    auto interfaceDecl = as<InterfaceDecl>(decl->parentDecl);",
            "    if (!interfaceDecl)"
          ],
          "context_after": [
            "    checkVisibility(decl);",
            "}",
            "",
            "SemanticsContext SemanticsDeclBodyVisitor::registerDifferentiableTypesForFunc(",
            "    FunctionDeclBase* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30301,
      "severity": "Error",
      "name": "globalGenParamInGlobalScopeOnly",
      "message": "'type_param' can only be defined global scope.",
      "line": 1608,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8760,
          "statement": "getSink()->diagnose(decl, Slang::Diagnostics::globalGenParamInGlobalScopeOnly);",
          "context_before": [
            "void SemanticsDeclHeaderVisitor::visitGlobalGenericParamDecl(GlobalGenericParamDecl* decl)",
            "{",
            "    // global generic param only allowed in global scope",
            "    auto program = as<ModuleDecl>(decl->parentDecl);",
            "    if (!program)"
          ],
          "context_after": [
            "}",
            "",
            "void SemanticsDeclHeaderVisitor::visitAssocTypeDecl(AssocTypeDecl* decl)",
            "{",
            "    // assoctype only allowed in an interface"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30302,
      "severity": "Error",
      "name": "staticConstRequirementMustBeIntOrBool",
      "message": "'static const' requirement can only have int or bool type.",
      "line": 1613,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2346,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::staticConstRequirementMustBeIntOrBool);",
          "context_before": [
            "            case BaseType::UInt:",
            "            case BaseType::UInt64:",
            "            case BaseType::UIntPtr:",
            "                break;",
            "            default:"
          ],
          "context_after": [
            "                break;",
            "            }",
            "        }",
            "        if (!varDecl->findModifier<HLSLStaticModifier>() || !varDecl->findModifier<ConstModifier>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30303,
      "severity": "Error",
      "name": "valueRequirementMustBeCompileTimeConst",
      "message": "requirement in the form of a simple value must be declared as 'static const'.",
      "line": 1618,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2352,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::valueRequirementMustBeCompileTimeConst);",
          "context_before": [
            "                break;",
            "            }",
            "        }",
            "        if (!varDecl->findModifier<HLSLStaticModifier>() || !varDecl->findModifier<ConstModifier>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    // Check modifiers that can't be checked earlier during modifier checking stage.",
            "    if (auto derivativeMemberAttr = varDecl->findModifier<DerivativeMemberAttribute>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30310,
      "severity": "Error",
      "name": "typeIsNotDifferentiable",
      "message": "type '$0' is not differentiable.",
      "line": 1623,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1834,
          "statement": "getSink()->diagnose(derivativeMemberAttr, Diagnostics::typeIsNotDifferentiable, memberType);",
          "context_before": [
            "{",
            "    auto memberType = checkProperType(getLinkage(), varDecl->type, getSink());",
            "    auto diffType = getDifferentialType(m_astBuilder, memberType, varDecl->loc);",
            "    if (as<ErrorType>(diffType))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    auto thisType = calcThisType(makeDeclRef(varDecl->parentDecl));",
            "    if (!thisType)",
            "    {",
            "        getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30311,
      "severity": "Error",
      "name": "nonMethodInterfaceRequirementCannotHaveBody",
      "message": "non-method interface requirement cannot have a body.",
      "line": 1625,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10300,
          "statement": "getSink()->diagnose(decl, Diagnostics::nonMethodInterfaceRequirementCannotHaveBody);",
          "context_before": [
            "    {",
            "        if (auto funcBase = as<FunctionDeclBase>(decl))",
            "        {",
            "            if (!as<FuncDecl>(decl) && funcBase->body != nullptr)",
            "            {"
          ],
          "context_after": [
            "                return;",
            "            }",
            "        }",
            "        // Interface requirement cannot be `override`.",
            "        if (decl->hasModifier<OverrideModifier>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30312,
      "severity": "Error",
      "name": "interfaceRequirementCannotBeOverride",
      "message": "interface requirement cannot override a base declaration.",
      "line": 1630,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10307,
          "statement": "getSink()->diagnose(decl, Diagnostics::interfaceRequirementCannotBeOverride);",
          "context_before": [
            "            }",
            "        }",
            "        // Interface requirement cannot be `override`.",
            "        if (decl->hasModifier<OverrideModifier>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "}",
            "",
            "bool doesTypeHaveNoDiffModifier(Type* type)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30400,
      "severity": "Error",
      "name": "cannotDefinePtrTypeToManagedResource",
      "message": "pointer to a managed resource is invalid, use `NativeRef<T>` instead",
      "line": 1637,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 401,
          "statement": "getSink()->diagnose(typeExp.exp, Diagnostics::cannotDefinePtrTypeToManagedResource);",
          "context_before": [
            "    // We don't allow pointers to managed types.",
            "    if (auto ptrType = as<PtrType>(result))",
            "    {",
            "        if (isManagedType(ptrType->getValueType()))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    *outProperType = result;",
            "    return true;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30500,
      "severity": "Warning",
      "name": "forLoopSideEffectChangingDifferentVar",
      "message": "the for loop initializes and checks variable '$0' but the side effect expression is modifying '$1'.",
      "line": 1644,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 843,
          "statement": "Diagnostics::forLoopSideEffectChangingDifferentVar, initialVar, varExpr->declRef);",
          "context_before": [
            "            // If the user writes something like `for (int i = 0; i < 5; j++)`,",
            "            // it is most likely a bug, so we issue a warning.",
            "            if (predicateVar == initialVar)",
            "                getSink()->diagnose(",
            "                    varExpr,"
          ],
          "context_after": [
            "                    initialVar,",
            "                    varExpr->declRef);",
            "            return;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30501,
      "severity": "Warning",
      "name": "forLoopPredicateCheckingDifferentVar",
      "message": "the for loop initializes and modifies variable '$0' but the predicate expression is checking '$1'.",
      "line": 1650,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 874,
          "statement": "Diagnostics::forLoopPredicateCheckingDifferentVar, initialVar, predicateVar);",
          "context_before": [
            "    if (predicateVar.getDecl() != initialVar.getDecl())",
            "    {",
            "        if (predicateVar)",
            "            getSink()->diagnose(",
            "                stmt->predicateExpression,"
          ],
          "context_after": [
            "                initialVar,",
            "                predicateVar);",
            "        return;",
            "    }",
            "    if (!stepSize)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30502,
      "severity": "Warning",
      "name": "forLoopChangingIterationVariableInOppsoiteDirection",
      "message": "the for loop is modifiying variable '$0' in the opposite direction from loop exit condition.",
      "line": 1656,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 888,
          "statement": "Diagnostics::forLoopChangingIterationVariableInOppsoiteDirection, initialVar);",
          "context_before": [
            "        if (sideEffectFuncOp == kIROp_Add && compareOp == kIROp_Greater ||",
            "            sideEffectFuncOp == kIROp_Sub && compareOp == kIROp_Less)",
            "        {",
            "            getSink()->diagnose(",
            "                stmt->sideEffectExpression,"
          ],
          "context_after": [
            "                initialVar);",
            "            return;",
            "        }",
            "    }",
            "    else if (stepSize->getValue() < 0)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 900,
          "statement": "Diagnostics::forLoopChangingIterationVariableInOppsoiteDirection, initialVar);",
          "context_before": [
            "        if (sideEffectFuncOp == kIROp_Add && compareOp == kIROp_Less ||",
            "            sideEffectFuncOp == kIROp_Sub && compareOp == kIROp_Greater)",
            "        {",
            "            getSink()->diagnose(",
            "                stmt->sideEffectExpression,"
          ],
          "context_after": [
            "                initialVar);",
            "            return;",
            "        }",
            "    }",
            "    else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30503,
      "severity": "Warning",
      "name": "forLoopNotModifyingIterationVariable",
      "message": "the for loop is not modifiying variable '$0' because the step size evaluates to 0.",
      "line": 1661,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 909,
          "statement": "Diagnostics::forLoopNotModifyingIterationVariable, initialVar);",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        getSink()->diagnose(",
            "            stmt->sideEffectExpression,"
          ],
          "context_after": [
            "            initialVar);",
            "        return;",
            "    }",
            "",
            "    if (!initialLitVal || !finalVal)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30504,
      "severity": "Warning",
      "name": "forLoopTerminatesInFewerIterationsThanMaxIters",
      "message": "the for loop is statically determined to terminate within $0 iterations, which is less than what [MaxIters] specifies.",
      "line": 1666,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 6921,
          "statement": "Diagnostics::forLoopTerminatesInFewerIterationsThanMaxIters, inferredMaxIters->value);",
          "context_before": [
            "                {",
            "                    if (inferredMaxIters->value < constIntVal->getValue())",
            "                    {",
            "                        context->getSink()->diagnose(",
            "                            maxIters,"
          ],
          "context_after": [
            "                            inferredMaxIters->value);",
            "                    }",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30505,
      "severity": "Warning",
      "name": "loopRunsForZeroIterations",
      "message": "the loop runs for 0 iterations and will be removed.",
      "line": 1672,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 942,
          "statement": "getSink()->diagnose(stmt, Diagnostics::loopRunsForZeroIterations);",
          "context_before": [
            "            iterations = 0;",
            "        break;",
            "    }",
            "    if (iterations == 0)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    // Note: the inferred max iterations may not be valid if the loop body",
            "    // also modifies the induction variable.",
            "    // We detect this case during lower-to-ir and will remove the `InferredMaxItersAttribute`"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30510,
      "severity": "Error",
      "name": "loopInDiffFuncRequireUnrollOrMaxIters",
      "message": "loops inside a differentiable function need to provide either '[MaxIters(n)]' or '[ForceUnroll]' attribute.",
      "line": 1677,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-differentiability.cpp",
          "line": 642,
          "statement": "sink->diagnose(loop->sourceLoc, Diagnostics::loopInDiffFuncRequireUnrollOrMaxIters);",
          "context_before": [
            "            {",
            "                // We are good.",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        // Make sure all stores of differentiable values are into addresses that can hold",
            "        // derivatives. If we are assigning a value to a non-differentiable location, we need to"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30600,
      "severity": "Error",
      "name": "switchMultipleDefault",
      "message": "multiple 'default' cases not allowed within a 'switch' statement",
      "line": 1685,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 380,
          "statement": "sink->diagnose(sStmt, Diagnostics::switchMultipleDefault);",
          "context_before": [
            "        else if (as<DefaultStmt>(sStmt))",
            "        {",
            "            // check that there is at most one `default` clause",
            "            if (hasDefaultStmt)",
            "            {"
          ],
          "context_after": [
            "                return;",
            "            }",
            "            hasDefaultStmt = true;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30601,
      "severity": "Error",
      "name": "switchDuplicateCases",
      "message": "duplicate cases not allowed within a 'switch' statement",
      "line": 1690,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 370,
          "statement": "sink->diagnose(sStmt, Diagnostics::switchDuplicateCases);",
          "context_before": [
            "            {",
            "                // exprVal contains the constant folded expr, that is checked for",
            "                // uniqueness within the scope of the switch statement.",
            "                if (!caseStmtVals.add(caseStmt->exprVal))",
            "                {"
          ],
          "context_after": [
            "                    return;",
            "                }",
            "            }",
            "        }",
            "        else if (as<DefaultStmt>(sStmt))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31000,
      "severity": "Warning",
      "name": "linkTimeConstantArraySize",
      "message": "Link-time constant sized arrays are a work in progress feature, some aspects of the reflection API may not work",
      "line": 1697,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10449,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::linkTimeConstantArraySize);",
          "context_before": [
            "        return;",
            "    }",
            "",
            "    if (elementCount->isLinkTimeVal())",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsVisitor::validateArrayElementTypeForVariable(VarDeclBase* varDecl)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Fatal",
      "name": "cyclicReference",
      "message": "cyclic reference '$0'.",
      "line": 1705,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 1504,
          "statement": "getSink()->diagnose(decl, Diagnostics::cyclicReference, decl);",
          "context_before": [
            "        //",
            "        // TODO: we should ideally be tracking a \"chain\" of declarations",
            "        // being checked on the stack, so that we can report the full",
            "        // chain that leads from this declaration back to itself.",
            "        //"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // If we should skip the checking, return now.",
            "    // A common case to skip checking is for the function bodies when we are in"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "cyclicReferenceInInheritance",
      "message": "cyclic reference in inheritance graph '$0'.",
      "line": 1706,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-inheritance.cpp",
          "line": 790,
          "statement": "getSink()->diagnose(baseDecl, Diagnostics::cyclicReferenceInInheritance, baseDecl);",
          "context_before": [
            "        if (!foundFacet.getImpl())",
            "        {",
            "            if (!bases.isEmpty())",
            "            {",
            "                auto baseDecl = (*bases.begin())->facetImpl.origin.declRef.getDecl();"
          ],
          "context_after": [
            "            }",
            "            return;",
            "        }",
            "",
            "        // At this point we definitely have a facet we'd like to"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "localVariableUsedBeforeDeclared",
      "message": "local variable '$0' is being used before its declaration.",
      "line": 1712,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "variableUsedInItsOwnDefinition",
      "message": "the initial-value expression for variable '$0' depends on the value of the variable itself",
      "line": 1717,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2200,
          "statement": "getSink()->diagnose(decl, Diagnostics::variableUsedInItsOwnDefinition, decl);",
          "context_before": [
            "    //",
            "    for (auto info = circularityInfo; info; info = info->next)",
            "    {",
            "        if (decl == info->decl)",
            "        {"
          ],
          "context_after": [
            "            return true;",
            "        }",
            "    }",
            "",
            "    return false;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39901,
      "severity": "Fatal",
      "name": "cannotProcessInclude",
      "message": "internal compiler error: cannot process '__include' in the current semantic checking context.",
      "line": 1722,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11321,
          "statement": "getSink()->diagnose(decl->moduleNameAndLoc.loc, Diagnostics::cannotProcessInclude);",
          "context_before": [
            "void SemanticsDeclHeaderVisitor::visitIncludeDecl(IncludeDecl* decl)",
            "{",
            "    auto name = decl->moduleNameAndLoc.name;",
            "",
            "    if (!getShared()->getTranslationUnitRequest())"
          ],
          "context_after": [
            "",
            "    auto parentModule = getModule(decl);",
            "    auto moduleDecl = parentModule->getModuleDecl();",
            "",
            "    auto [fileDecl, isNew] = getLinkage()->findAndIncludeFile("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11445,
          "statement": "getSink()->diagnose(decl->moduleNameAndLoc.loc, Diagnostics::cannotProcessInclude);",
          "context_before": [
            "    // we are in a language server context.",
            "",
            "    auto name = decl->moduleNameAndLoc.name;",
            "",
            "    if (!getShared()->getTranslationUnitRequest())"
          ],
          "context_after": [
            "",
            "    auto [fileDecl, isNew] = getLinkage()->findAndIncludeFile(",
            "        getModule(decl),",
            "        getShared()->getTranslationUnitRequest(),",
            "        name,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30400,
      "severity": "Error",
      "name": "genericTypeNeedsArgs",
      "message": "generic type '$0' used without argument",
      "line": 1729,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 315,
          "statement": "diagSink->diagnose(typeExp.exp, Diagnostics::genericTypeNeedsArgs, typeExp);",
          "context_before": [
            "                }",
            "                else",
            "                {",
            "                    if (diagSink)",
            "                    {"
          ],
          "context_after": [
            "                        *outProperType = m_astBuilder->getErrorType();",
            "                    }",
            "                    return false;",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 325,
          "statement": "diagSink->diagnose(typeExp.exp, Diagnostics::genericTypeNeedsArgs, typeExp);",
          "context_before": [
            "            }",
            "            else if (auto typePack = as<GenericTypePackParamDecl>(member))",
            "            {",
            "                if (diagSink)",
            "                {"
          ],
          "context_after": [
            "                    *outProperType = m_astBuilder->getErrorType();",
            "                }",
            "                return false;",
            "            }",
            "            else if (auto valParam = as<GenericValueParamDecl>(member))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 359,
          "statement": "diagSink->diagnose(typeExp.exp, Diagnostics::genericTypeNeedsArgs, typeExp);",
          "context_before": [
            "            if (!genericParam)",
            "                return false;",
            "            auto genericTypeParamDecl = as<GenericTypeParamDecl>(genericParam.getDecl());",
            "            if (!genericTypeParamDecl)",
            "            {"
          ],
          "context_after": [
            "                return false;",
            "            }",
            "            auto defaultType = CheckProperType(genericTypeParamDecl->initType);",
            "            if (!defaultType)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 365,
          "statement": "diagSink->diagnose(typeExp.exp, Diagnostics::genericTypeNeedsArgs, typeExp);",
          "context_before": [
            "                return false;",
            "            }",
            "            auto defaultType = CheckProperType(genericTypeParamDecl->initType);",
            "            if (!defaultType)",
            "            {"
          ],
          "context_after": [
            "                return false;",
            "            }",
            "            auto witness = tryGetSubtypeWitness(defaultType, CheckProperType(constraintParam->sup));",
            "            if (!witness)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30401,
      "severity": "Error",
      "name": "invalidTypeForConstraint",
      "message": "type '$0' cannot be used as a constraint.",
      "line": 1730,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3529,
          "statement": "Diagnostics::invalidTypeForConstraint, decl->sup);",
          "context_before": [
            "            validateGenericConstraintSubType(decl, decl->sub, getSink());",
            "            if (!isValidGenericConstraintType(decl->sup) && !as<ErrorType>(decl->sup.type))",
            "            {",
            "                getSink()->diagnose(",
            "                    decl->sup.exp,"
          ],
          "context_after": [
            "                    decl->sup);",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30402,
      "severity": "Error",
      "name": "invalidConstraintSubType",
      "message": "type '$0' is not a valid left hand side of a type constraint.",
      "line": 1731,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3317,
          "statement": "sink->diagnose(type.exp, Diagnostics::invalidConstraintSubType, type);",
          "context_before": [
            "            {",
            "                sink->diagnose(type.exp, Diagnostics::invalidEqualityConstraintSubType, type);",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "    };",
            "    // Validate that the sub type of a constraint is in valid form.",
            "    //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30403,
      "severity": "Error",
      "name": "requiredConstraintIsNotChecked",
      "message": "the constraint providing '$0' is optional and must be checked with an 'is' statement before usage.",
      "line": 1736,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1167,
          "statement": "Diagnostics::requiredConstraintIsNotChecked, lookupResult.item.declRef);",
          "context_before": [
            "    auto result = filterLookupResultByCheckedOptional(lookupResult);",
            "    if (lookupResult.isValid() && !result.isValid())",
            "    {",
            "        getSink()->diagnose(",
            "            loc,"
          ],
          "context_after": [
            "            lookupResult.item.declRef);",
            "        outDiagnosed = true;",
            "",
            "        if (getShared()->isInLanguageServer())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30404,
      "severity": "Error",
      "name": "invalidEqualityConstraintSupType",
      "message": "type '$0' is not a proper type to use in a generic equality constraint.",
      "line": 1742,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3518,
          "statement": "Diagnostics::invalidEqualityConstraintSupType, decl->sup);",
          "context_before": [
            "            checkGenericTypeEqualityConstraintSubType(decl);",
            "            if (!isProperConstraineeType(decl->sup) && !as<ErrorType>(decl->sup.type))",
            "            {",
            "                getSink()->diagnose(",
            "                    decl->sup.exp,"
          ],
          "context_after": [
            "                    decl->sup);",
            "            }",
            "        }",
            "        else",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30405,
      "severity": "Error",
      "name": "noValidEqualityConstraintSubType",
      "message": "generic equality constraint requires at least one operand to be dependant on the generic declaration",
      "line": 1747,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3553,
          "statement": "getSink()->diagnose(decl, Diagnostics::noValidEqualityConstraintSubType);",
          "context_before": [
            "        {",
            "            return int(supOk) - int(subOk);",
            "        }",
            "        else if (!(subOk || supOk))",
            "        {"
          ],
          "context_after": [
            "            // Re-run the validation to emit the diagnostic this time",
            "            validateGenericConstraintSubType(decl, decl->sub, getSink());",
            "            validateGenericConstraintSubType(decl, decl->sup, getSink());",
            "            return -1;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30407,
      "severity": "Warning",
      "name": "failedEqualityConstraintCanonicalOrder",
      "message": "failed to resolve canonical order of generic equality constraint.",
      "line": 1758,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3595,
          "statement": "getSink()->diagnose(decl, Diagnostics::failedEqualityConstraintCanonicalOrder);",
          "context_before": [
            "        Swap(decl->sub, decl->sup);",
            "    }",
            "    else if (cmp == 0 && decl->sub != decl->sup)",
            "    {",
            "        // The comparison was not fully handled for this case."
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsDeclHeaderVisitor::visitGenericTypeParamDecl(GenericTypeParamDecl* decl)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30500,
      "severity": "Error",
      "name": "tooManyInitializers",
      "message": "too many initializers (expected $0, got $1)",
      "line": 1765,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 992,
          "statement": "Diagnostics::tooManyInitializers, argIndex, argCount);",
          "context_before": [
            "    {",
            "        if (outToExpr)",
            "        {",
            "            getSink()->diagnose(",
            "                fromInitializerListExpr,"
          ],
          "context_after": [
            "                argIndex,",
            "                argCount);",
            "        }",
            "    }",
            "    if (outToExpr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30501,
      "severity": "Error",
      "name": "cannotUseInitializerListForArrayOfUnknownSize",
      "message": "cannot use initializer list for array of statically unknown size '$0'",
      "line": 1766,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 30502,
      "severity": "Error",
      "name": "cannotUseInitializerListForVectorOfUnknownSize",
      "message": "cannot use initializer list for vector of statically unknown size '$0'",
      "line": 1771,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 590,
          "statement": "Diagnostics::cannotUseInitializerListForVectorOfUnknownSize, toElementCount);",
          "context_before": [
            "            //",
            "            if (outToExpr)",
            "            {",
            "                getSink()->diagnose(",
            "                    fromInitializerListExpr,"
          ],
          "context_after": [
            "                    toElementCount);",
            "            }",
            "            return false;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30503,
      "severity": "Error",
      "name": "cannotUseInitializerListForMatrixOfUnknownSize",
      "message": "cannot use initializer list for matrix of statically unknown size '$0' rows",
      "line": 1776,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 786,
          "statement": "Diagnostics::cannotUseInitializerListForMatrixOfUnknownSize, toMatrixType->getRowCount());",
          "context_before": [
            "            //",
            "            if (outToExpr)",
            "            {",
            "                getSink()->diagnose(",
            "                    fromInitializerListExpr,"
          ],
          "context_after": [
            "                    toMatrixType->getRowCount());",
            "            }",
            "            return false;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30504,
      "severity": "Error",
      "name": "cannotUseInitializerListForType",
      "message": "cannot use initializer list for type '$0'",
      "line": 1781,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 463,
          "statement": "Diagnostics::cannotUseInitializerListForType, toType);",
          "context_before": [
            "        bool isArrayType = as<ArrayExpressionType>(toType) != nullptr;",
            "        if (!isCStyle && !isArrayType)",
            "        {",
            "            diagnoseOnce(",
            "                fromInitializerListExpr->loc,"
          ],
          "context_after": [
            "                toType);",
            "        }",
            "",
            "        return false;",
            "    }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 900,
          "statement": "Diagnostics::cannotUseInitializerListForType, inToType);",
          "context_before": [
            "        //",
            "        if (outToExpr)",
            "        {",
            "            getSink()->diagnose(",
            "                fromInitializerListExpr,"
          ],
          "context_after": [
            "                inToType);",
            "        }",
            "        return false;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30505,
      "severity": "Error",
      "name": "cannotUseInitializerListForCoopVectorOfUnknownSize",
      "message": "cannot use initializer list for CoopVector of statically unknown size '$0'",
      "line": 1786,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 634,
          "statement": "Diagnostics::cannotUseInitializerListForCoopVectorOfUnknownSize, toElementCount);",
          "context_before": [
            "            //",
            "            if (outToExpr)",
            "            {",
            "                getSink()->diagnose(",
            "                    fromInitializerListExpr,"
          ],
          "context_after": [
            "                    toElementCount);",
            "            }",
            "            return false;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30506,
      "severity": "Warning",
      "name": "interfaceDefaultInitializer",
      "message": "initializing an interface variable with defaults is deprecated and may cause unexpected behavior. Please provide a compatible initializer or leave the variable uninitialized",
      "line": 1791,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 5474,
          "statement": "context->getSink()->diagnose(expr, Diagnostics::interfaceDefaultInitializer);",
          "context_before": [
            "            // unspecified behavior, so we'll warn about it here.",
            "            if (auto declRefType = as<DeclRefType>(type))",
            "            {",
            "                if (auto interfaceDeclRef = declRefType->getDeclRef().as<InterfaceDecl>())",
            "                {"
          ],
          "context_after": [
            "                }",
            "            }",
            "",
            "            return getDefaultVal(type.type);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30620,
      "severity": "Error",
      "name": "varWithoutTypeMustHaveInitializer",
      "message": "a variable declaration without an initial-value expression must be given an explicit type",
      "line": 1799,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2185,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::varWithoutTypeMustHaveInitializer);",
          "context_before": [
            "                {",
            "                    getSink()->diagnose(varDecl, Diagnostics::genericValueParameterMustHaveType);",
            "                }",
            "                else",
            "                {"
          ],
          "context_after": [
            "                }",
            "                varDecl->type.type = m_astBuilder->getErrorType();",
            "            }",
            "        }",
            "        else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30621,
      "severity": "Error",
      "name": "paramWithoutTypeMustHaveInitializer",
      "message": "a parameter declaration without an initial-value expression must be given an explicit type",
      "line": 1804,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9625,
          "statement": "getSink()->diagnose(paramDecl, Diagnostics::paramWithoutTypeMustHaveInitializer);",
          "context_before": [
            "        deriveVarTypeFromInitExpr(paramDecl);",
            "    }",
            "",
            "    if (!paramDecl->type && !as<AttributeDecl>(getParentDecl(paramDecl)))",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    if (isTypePack(paramDecl->type.type))",
            "    {",
            "        // For now, we only allow parameter packs to be `const`."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30622,
      "severity": "Error",
      "name": "ambiguousDefaultInitializerForType",
      "message": "more than one default initializer was found for type '$0'",
      "line": 1809,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2852,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::ambiguousDefaultInitializerForType, type);",
          "context_before": [
            "            {",
            "                getShared()->cacheImplicitCastMethod(key, ImplicitCastMethod{});",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        else if (overloadContext.bestCandidate)",
            "        {",
            "            // If we are in the single-candidate case, then we again"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30623,
      "severity": "Error",
      "name": "cannotHaveInitializer",
      "message": "'$0' cannot have an initializer because it is $1",
      "line": 1814,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2622,
          "statement": "sink->diagnose(varDecl, Diagnostics::cannotHaveInitializer, varDecl, \"groupshared\");",
          "context_before": [
            "{",
            "    // find groupshared modifier",
            "    if (varDecl->findModifier<HLSLGroupSharedModifier>())",
            "    {",
            "        if (sink && varDecl->initExpr)"
          ],
          "context_after": [
            "        return false;",
            "    }",
            "",
            "    if (as<InterfaceDecl>(varDecl->parentDecl))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2631,
          "statement": "Diagnostics::cannotHaveInitializer, varDecl, \"an interface requirement\");",
          "context_before": [
            "    if (as<InterfaceDecl>(varDecl->parentDecl))",
            "    {",
            "        if (sink && varDecl->initExpr)",
            "            sink->diagnose(",
            "                varDecl,"
          ],
          "context_after": [
            "                varDecl,",
            "                \"an interface requirement\");",
            "        return false;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30623,
      "severity": "Error",
      "name": "genericValueParameterMustHaveType",
      "message": "a generic value parameter must be given an explicit type",
      "line": 1815,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2181,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::genericValueParameterMustHaveType);",
          "context_before": [
            "        {",
            "            if (!varDecl->type.type)",
            "            {",
            "                if (as<GenericValueParamDecl>(varDecl))",
            "                {"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    getSink()->diagnose(varDecl, Diagnostics::varWithoutTypeMustHaveInitializer);",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30624,
      "severity": "Error",
      "name": "genericValueParameterTypeNotSupported",
      "message": "generic value parameter type '$0' is not supported; only integer and enum types are allowed",
      "line": 1820,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3618,
          "statement": "Diagnostics::genericValueParameterTypeNotSupported, decl->type.type);",
          "context_before": [
            "    {",
            "        if (!isValidCompileTimeConstantType(decl->type.type))",
            "        {",
            "            getSink()->diagnose(",
            "                decl,"
          ],
          "context_after": [
            "                decl->type.type);",
            "        }",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30700,
      "severity": "Error",
      "name": "outputParameterCannotHaveDefaultValue",
      "message": "an 'out' or 'inout' parameter cannot have a default-value expression",
      "line": 1827,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9779,
          "statement": "getSink()->diagnose(initExpr, Diagnostics::outputParameterCannotHaveDefaultValue);",
          "context_before": [
            "        // Note: the `InOutModifier` class inherits from `OutModifier`,",
            "        // so we only need to check for the base case.",
            "        //",
            "        if (paramDecl->findModifier<OutModifier>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "}",
            "",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30701,
      "severity": "Error",
      "name": "systemValueSemanticInvalidType",
      "message": "type '$0' is not valid for system value semantic '$1'; expected '$2'",
      "line": 1832,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 279,
          "statement": "Diagnostics::systemValueSemanticInvalidType, unwrapConditionalType(type), baseName, validTypesStr);",
          "context_before": [
            "",
            "        diagnoseCapabilityErrors(",
            "            sink,",
            "            visitor->getOptionSet(),",
            "            loc,"
          ],
          "context_after": [
            "            unwrapConditionalType(type),",
            "            baseName,",
            "            validTypesStr);",
            "    }",
            "}"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30702,
      "severity": "Error",
      "name": "systemValueSemanticInvalidDirection",
      "message": "system value semantic '$0' cannot be used as $1 in '$2' shader stage",
      "line": 1837,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 259,
          "statement": "Diagnostics::systemValueSemanticInvalidDirection, baseName, directionStr, stageStr);",
          "context_before": [
            "        // No accessor defined for this stage+direction combination",
            "        diagnoseCapabilityErrors(",
            "            sink,",
            "            visitor->getOptionSet(),",
            "            loc,"
          ],
          "context_after": [
            "            baseName,",
            "            directionStr,",
            "            stageStr);",
            "    }",
            "    else if (!foundMatchingAccessor)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30810,
      "severity": "Error",
      "name": "baseOfInterfaceMustBeInterface",
      "message": "interface '$0' cannot inherit from non-interface type '$1'",
      "line": 1844,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8048,
          "statement": "Diagnostics::baseOfInterfaceMustBeInterface, decl, baseType);",
          "context_before": [
            "        auto baseDeclRefType = as<DeclRefType>(baseType);",
            "        if (!baseDeclRefType)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8060,
          "statement": "Diagnostics::baseOfInterfaceMustBeInterface, decl, baseType);",
          "context_before": [
            "        auto baseInterfaceDeclRef = baseDeclRef.as<InterfaceDecl>();",
            "        if (!baseInterfaceDeclRef)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30811,
      "severity": "Error",
      "name": "baseOfStructMustBeInterface",
      "message": "struct '$0' cannot inherit from non-interface type '$1'",
      "line": 1849,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8118,
          "statement": "Diagnostics::baseOfStructMustBeInterface, decl, baseType);",
          "context_before": [
            "        auto baseDeclRefType = as<DeclRefType>(baseType);",
            "        if (!baseDeclRefType)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8137,
          "statement": "Diagnostics::baseOfStructMustBeInterface, decl, baseType);",
          "context_before": [
            "                // In Slang 2026, we no longer allow structs to inherit from other structs.",
            "                if (isSlang2026OrLater(this))",
            "                {",
            "                    getSink()->diagnose(",
            "                        inheritanceDecl,"
          ],
          "context_after": [
            "                        decl,",
            "                        baseType);",
            "                }",
            "                else",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8172,
          "statement": "Diagnostics::baseOfStructMustBeInterface, decl, baseType);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30812,
      "severity": "Error",
      "name": "baseOfEnumMustBeIntegerOrInterface",
      "message": "enum '$0' cannot inherit from type '$1' that is neither an interface not a builtin integer type",
      "line": 1854,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8456,
          "statement": "Diagnostics::baseOfEnumMustBeIntegerOrInterface, decl, baseType);",
          "context_before": [
            "        auto baseDeclRefType = as<DeclRefType>(baseType);",
            "        if (!baseDeclRefType)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8503,
          "statement": "Diagnostics::baseOfEnumMustBeIntegerOrInterface, decl, baseType);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30813,
      "severity": "Error",
      "name": "baseOfExtensionMustBeInterface",
      "message": "extension cannot inherit from non-interface type '$1'",
      "line": 1860,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10687,
          "statement": "Diagnostics::baseOfExtensionMustBeInterface, decl, baseType);",
          "context_before": [
            "        auto baseDeclRefType = as<DeclRefType>(baseType);",
            "        if (!baseDeclRefType)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10699,
          "statement": "Diagnostics::baseOfExtensionMustBeInterface, decl, baseType);",
          "context_before": [
            "        auto baseInterfaceDeclRef = baseDeclRef.as<InterfaceDecl>();",
            "        if (!baseInterfaceDeclRef)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30814,
      "severity": "Error",
      "name": "baseOfClassMustBeClassOrInterface",
      "message": "class '$0' cannot inherit from type '$1' that is neither a class nor an interface",
      "line": 1865,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8240,
          "statement": "Diagnostics::baseOfClassMustBeClassOrInterface, decl, baseType);",
          "context_before": [
            "        auto baseDeclRefType = as<DeclRefType>(baseType);",
            "        if (!baseDeclRefType)",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8274,
          "statement": "Diagnostics::baseOfClassMustBeClassOrInterface, decl, baseType);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                decl,",
            "                baseType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30815,
      "severity": "Error",
      "name": "circularityInExtension",
      "message": "circular extension is not allowed.",
      "line": 1870,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-inheritance.cpp",
          "line": 69,
          "statement": "getSink()->diagnose(decl, Diagnostics::circularityInExtension, decl);",
          "context_before": [
            "{",
            "    for (auto info = circularityInfo; info; info = info->next)",
            "    {",
            "        if (decl == info->decl)",
            "        {"
          ],
          "context_after": [
            "            return true;",
            "        }",
            "    }",
            "",
            "    return false;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30816,
      "severity": "Warning",
      "name": "inheritanceUnstable",
      "message": "support for inheritance is unstable and will be removed in future language versions, consider using composition instead.",
      "line": 1871,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8146,
          "statement": "getSink()->diagnose(inheritanceDecl, Diagnostics::inheritanceUnstable);",
          "context_before": [
            "                else",
            "                {",
            "                    // For legacy langauge versions, we still allow struct inheritance to avoid",
            "                    // breaking existing code, but we will emit a warning to inform the user",
            "                    // that this feature is unstable and may be removed in the future."
          ],
          "context_after": [
            "                }",
            "            }",
            "",
            "            // To simplify the task of reading and maintaining code,",
            "            // we require that when a `struct` inherits from another"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30820,
      "severity": "Error",
      "name": "baseStructMustBeListedFirst",
      "message": "a struct type may only inherit from one other struct type, and that type must appear first in the list of bases",
      "line": 1877,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8163,
          "statement": "Diagnostics::baseStructMustBeListedFirst, decl, baseType);",
          "context_before": [
            "            //",
            "            if (inheritanceClauseIndex != 0)",
            "            {",
            "                getSink()->diagnose(",
            "                    inheritanceDecl,"
          ],
          "context_after": [
            "                    decl,",
            "                    baseType);",
            "            }",
            "        }",
            "        else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30821,
      "severity": "Error",
      "name": "tagTypeMustBeListedFirst",
      "message": "an unum type may only have a single tag type, and that type must be listed first in the list of bases",
      "line": 1883,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8482,
          "statement": "Diagnostics::tagTypeMustBeListedFirst, decl, baseType);",
          "context_before": [
            "            //",
            "            if (inheritanceClauseIndex != 0)",
            "            {",
            "                getSink()->diagnose(",
            "                    inheritanceDecl,"
          ],
          "context_after": [
            "                    decl,",
            "                    baseType);",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30822,
      "severity": "Error",
      "name": "baseClassMustBeListedFirst",
      "message": "a class type may only inherit from one other class type, and that type must appear first in the list of bases",
      "line": 1889,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8265,
          "statement": "Diagnostics::baseClassMustBeListedFirst, decl, baseType);",
          "context_before": [
            "            //",
            "            if (inheritanceClauseIndex != 0)",
            "            {",
            "                getSink()->diagnose(",
            "                    inheritanceDecl,"
          ],
          "context_after": [
            "                    decl,",
            "                    baseType);",
            "            }",
            "        }",
            "        else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30830,
      "severity": "Error",
      "name": "cannotInheritFromExplicitlySealedDeclarationInAnotherModule",
      "message": "cannot inherit from type '$0' marked 'sealed' in module '$1'",
      "line": 1896,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7984,
          "statement": "Diagnostics::cannotInheritFromExplicitlySealedDeclarationInAnotherModule, baseType, moduleWithBaseType->getModuleDecl()->getName());",
          "context_before": [
            "        // then it explicitly does *not* allow inheritance from other",
            "        // modules.",
            "        //",
            "        getSink()->diagnose(",
            "            inheritanceDecl,"
          ],
          "context_after": [
            "            baseType,",
            "            moduleWithBaseType->getModuleDecl()->getName());",
            "        return;",
            "    }",
            "    else if (baseDecl->hasModifier<OpenAttribute>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30831,
      "severity": "Error",
      "name": "cannotInheritFromImplicitlySealedDeclarationInAnotherModule",
      "message": "cannot inherit from type '$0' in module '$1' because it is implicitly 'sealed'; mark the base type 'open' to allow inheritance across modules",
      "line": 1901,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8012,
          "statement": "Diagnostics::cannotInheritFromImplicitlySealedDeclarationInAnotherModule, baseType, moduleWithBaseType->getModuleDecl()->getName());",
          "context_before": [
            "        // For any non-interface type, if the declaration didn't specify",
            "        // `[open]` or `[sealed]` then we assume `[sealed]` is the default.",
            "        //",
            "        getSink()->diagnose(",
            "            inheritanceDecl,"
          ],
          "context_after": [
            "            baseType,",
            "            moduleWithBaseType->getModuleDecl()->getName());",
            "        return;",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30832,
      "severity": "Error",
      "name": "invalidTypeForInheritance",
      "message": "type '$0' cannot be used for inheritance",
      "line": 1907,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7604,
          "statement": "getSink()->diagnose(inheritanceDecl, Diagnostics::invalidTypeForInheritance, superType);",
          "context_before": [
            "            return true;",
            "        }",
            "    }",
            "    if (!as<ErrorType>(superType))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return false;",
            "}",
            "",
            "static bool _doesTypeDeclHaveDefinition(ContainerDecl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30850,
      "severity": "Error",
      "name": "invalidExtensionOnType",
      "message": "type '$0' cannot be extended. `extension` can only be used to extend a nominal type.",
      "line": 1909,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10564,
          "statement": "Diagnostics::invalidExtensionOnType, decl->targetType);",
          "context_before": [
            "error:;",
            "    if (!as<ErrorType>(decl->targetType.type))",
            "    {",
            "        getSink()->diagnose(",
            "            decl->targetType.exp,"
          ],
          "context_after": [
            "            decl->targetType);",
            "    }",
            "}",
            "",
            "void SemanticsDeclBasesVisitor::_validateExtensionDeclMembers(ExtensionDecl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30851,
      "severity": "Error",
      "name": "invalidMemberTypeInExtension",
      "message": "$0 cannot be a part of an `extension`",
      "line": 1914,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10586,
          "statement": "getSink()->diagnose(ctor, Diagnostics::invalidMemberTypeInExtension, ctor->astNodeType);",
          "context_before": [
            "        //",
            "        // The underlying rationale",
            "",
            "        if (!ctor->body || ctor->getDirectMemberDeclCount() != 0)",
            "            continue;"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsDeclBasesVisitor::_validateExtensionDeclGenericParams(ExtensionDecl* decl)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30852,
      "severity": "Error",
      "name": "invalidExtensionOnInterface",
      "message": "cannot extend interface type '$0'. consider using a generic extension: `extension<T:$0> T {...}`.",
      "line": 1915,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10522,
          "statement": "Diagnostics::invalidExtensionOnInterface, decl->targetType);",
          "context_before": [
            "        // Attach our extension to that type as a candidate...",
            "        if (targetDeclRefType->getDeclRef().as<InterfaceDecl>())",
            "        {",
            "            getSink()->diagnose(",
            "                decl->targetType.exp,"
          ],
          "context_after": [
            "                decl->targetType);",
            "            return;",
            "        }",
            "        else if (auto aggTypeDeclRef = targetDeclRefType->getDeclRef().as<AggTypeDecl>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30853,
      "severity": "Error",
      "name": "missingOverride",
      "message": "missing 'override' keyword for methods that overrides the default implementation in the interface.",
      "line": 1921,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 5475,
          "statement": "getSink()->diagnose(memberDecl, Diagnostics::missingOverride);",
          "context_before": [
            "    {",
            "        // If the required member has a default implementation,",
            "        // we need to make sure the member we found is marked as 'override'.",
            "        if (!memberDecl->hasModifier<OverrideModifier>())",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    auto overridingModifier = m_astBuilder->create<IsOverridingModifier>();",
            "    overridingModifier->overridedDecl = requiredMemberDeclRef.getDecl();",
            "    addModifier(memberDecl, overridingModifier);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30854,
      "severity": "Error",
      "name": "overrideModifierNotOverridingBaseDecl",
      "message": "'$0' marked as 'override' is not overriding any base declarations.",
      "line": 1927,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7853,
          "statement": "Diagnostics::overrideModifierNotOverridingBaseDecl, innerMember);",
          "context_before": [
            "            }",
            "            if (hasOverride && !isOverriding)",
            "            {",
            "                getSink()->diagnose(",
            "                    innerMember,"
          ],
          "context_after": [
            "                    innerMember);",
            "",
            "                if (getShared()->isInLanguageServer() &&",
            "                    member->getName() == getShared()->getSession()->getCompletionRequestTokenName())",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30855,
      "severity": "Error",
      "name": "unreferencedGenericParamInExtension",
      "message": "generic parameter '$0' is not referenced by extension target type '$1'.",
      "line": 1932,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10628,
          "statement": "Diagnostics::unreferencedGenericParamInExtension, member->getName(), decl->targetType);",
          "context_before": [
            "                bool referencedByConstraint = genericParamsReferencedByConstraints.contains(member);",
            "                if (!referencedByTargetType && !referencedByConstraint)",
            "                {",
            "                    getSink()->diagnose(",
            "                        member,"
          ],
          "context_after": [
            "                        member->getName(),",
            "                        decl->targetType);",
            "                }",
            "                else if (!referencedByTargetType && !isFromCoreModule(decl))",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30856,
      "severity": "Warning",
      "name": "genericParamInExtensionNotReferencedByTargetType",
      "message": "the extension is non-standard and may not work as intended because the generic parameter '$0' is not referenced by extension target type '$1'.",
      "line": 1937,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10636,
          "statement": "Diagnostics::genericParamInExtensionNotReferencedByTargetType, member->getName(), decl->targetType);",
          "context_before": [
            "                }",
            "                else if (!referencedByTargetType && !isFromCoreModule(decl))",
            "                {",
            "                    getSink()->diagnose(",
            "                        member,"
          ],
          "context_after": [
            "                        member->getName(),",
            "                        decl->targetType);",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30900,
      "severity": "Error",
      "name": "multiDimensionalArrayNotSupported",
      "message": "multi-dimensional array is not supported.",
      "line": 1944,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2675,
          "statement": "getSink()->diagnose(subscriptExpr, Diagnostics::multiDimensionalArrayNotSupported);",
          "context_before": [
            "                }",
            "            }",
            "        }",
            "        else if (subscriptExpr->indexExprs.getCount() != 0)",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        auto elementType = CoerceToUsableType(TypeExp(baseExpr, baseTypeType->getType()), nullptr);",
            "        auto arrayType = getArrayType(m_astBuilder, elementType, elementCount);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 30901,
      "severity": "Error",
      "name": "subscriptMustHaveReturnType",
      "message": "__subscript declaration must have a return type specified after '->'",
      "line": 1949,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 4145,
          "statement": "parser->diagnose(decl->loc, Diagnostics::subscriptMustHaveReturnType);",
          "context_before": [
            "            {",
            "                decl->returnType = parser->ParseTypeExp();",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "                decl->returnType.exp = parser->astBuilder->create<IncompleteExpr>();",
            "            }",
            "",
            "            auto funcScope = parser->currentScope;",
            "            parser->PopScope();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31100,
      "severity": "Error",
      "name": "accessorMustBeInsideSubscriptOrProperty",
      "message": "an accessor declaration is only allowed inside a subscript or property declaration",
      "line": 1958,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10927,
          "statement": "getSink()->diagnose(decl, Diagnostics::accessorMustBeInsideSubscriptOrProperty);",
          "context_before": [
            "    else if (as<PropertyDecl>(parentDecl))",
            "    {",
            "    }",
            "    else",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsDeclHeaderVisitor::visitAccessorDecl(AccessorDecl* decl)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31101,
      "severity": "Error",
      "name": "nonSetAccessorMustNotHaveParams",
      "message": "accessors other than 'set' must not have parameters",
      "line": 1964,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10945,
          "statement": "getSink()->diagnose(decl, Diagnostics::nonSetAccessorMustNotHaveParams);",
          "context_before": [
            "    // Accessors (other than setters) don't support",
            "    // parameters.",
            "    //",
            "    if (decl->getParameters().getCount() != 0)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    // By default, the return type of an accessor is treated as",
            "    // the type of the abstract storage location being accessed.",
            "    //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31102,
      "severity": "Error",
      "name": "setAccessorMayNotHaveMoreThanOneParam",
      "message": "a 'set' accessor may not have more than one parameter",
      "line": 1969,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11000,
          "statement": "getSink()->diagnose(params[1], Diagnostics::setAccessorMayNotHaveMoreThanOneParam);",
          "context_before": [
            "        if (params.getCount() > 1)",
            "        {",
            "            // If the user declared more than one explicit",
            "            // parameter, then that is an error.",
            "            //"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else",
            "    {",
            "        // If the user didn't declare any explicit parameters,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31102,
      "severity": "Error",
      "name": "setAccessorParamWrongType",
      "message": "'set' parameter '$0' has type '$1' which does not match the expected type '$2'",
      "line": 1974,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 11049,
          "statement": "Diagnostics::setAccessorParamWrongType, newValueParam, actualType, newValueType);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                newValueParam,"
          ],
          "context_after": [
            "                newValueParam,",
            "                actualType,",
            "                newValueType);",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31300,
      "severity": "Error",
      "name": "bitFieldTooWide",
      "message": "bit-field size ($0) exceeds the width of its type $1 ($2)",
      "line": 1981,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13928,
          "statement": "Diagnostics::bitFieldTooWide, thisFieldWidth, t, thisFieldTypeWidth);",
          "context_before": [
            "        SLANG_ASSERT(thisFieldTypeWidth != 0);",
            "        if (thisFieldWidth > thisFieldTypeWidth)",
            "        {",
            "            getSink()->diagnose(",
            "                v->loc,"
          ],
          "context_after": [
            "                thisFieldWidth,",
            "                t,",
            "                thisFieldTypeWidth);",
            "            // Not much we can do with this field, just ignore it",
            "            continue;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 31301,
      "severity": "Error",
      "name": "bitFieldNonIntegral",
      "message": "bit-field type ($0) must be an integral type",
      "line": 1986,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13909,
          "statement": "getSink()->diagnose(v->loc, Diagnostics::bitFieldNonIntegral, t);",
          "context_before": [
            "        const auto t = v->type.type->getCanonicalType();",
            "        SLANG_ASSERT(t);",
            "        const auto b = as<BasicExpressionType>(t);",
            "        if (!b)",
            "        {"
          ],
          "context_after": [
            "            continue;",
            "        }",
            "        const auto baseType = b->getBaseType();",
            "        const bool isIntegerType = isIntegerBaseType(baseType);",
            "        if (!isIntegerType)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13916,
          "statement": "getSink()->diagnose(v->loc, Diagnostics::bitFieldNonIntegral, t);",
          "context_before": [
            "        }",
            "        const auto baseType = b->getBaseType();",
            "        const bool isIntegerType = isIntegerBaseType(baseType);",
            "        if (!isIntegerType)",
            "        {"
          ],
          "context_after": [
            "            continue;",
            "        }",
            "",
            "        // The bit width of this member, and the member type width",
            "        const auto thisFieldWidth = bfm->width;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedIntegerConstantWrongType",
      "message": "expected integer constant (found: '$0')",
      "line": 1990,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedIntegerConstantNotConstant",
      "message": "expression does not evaluate to a compile-time constant",
      "line": 1995,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-early-raytracing-intrinsic-simplification.cpp",
          "line": 48,
          "statement": "sink->diagnose(payloadVariable, Diagnostics::expectedIntegerConstantNotConstant);",
          "context_before": [
            "                varLayoutPointsTo = m_RayLocationToCallables.tryGetValue(intLitValue);",
            "            }",
            "        }",
            "        else",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        IRInst* resultVariable;",
            "        if (!varLayoutPointsTo)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2545,
          "statement": "sink->diagnose(expr, Diagnostics::expectedIntegerConstantNotConstant);",
          "context_before": [
            "        return nullptr;",
            "",
            "    auto result = tryFoldIntegerConstantExpression(expr, kind, nullptr);",
            "    if (!result && sink)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return result;",
            "}",
            "",
            "IntVal* SemanticsVisitor::CheckIntegerConstantExpression("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2572,
          "statement": "getSink()->diagnose(expr, Diagnostics::expectedIntegerConstantNotConstant);",
          "context_before": [
            "        return nullptr;",
            "",
            "    auto result = tryConstantFoldExpr(expr, kind, nullptr);",
            "    if (!result)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return result;",
            "}",
            "",
            "Expr* SemanticsVisitor::CheckSimpleSubscriptExpr(IndexExpr* subscriptExpr, Type* elementType)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 8666,
          "statement": "Diagnostics::expectedIntegerConstantNotConstant);",
          "context_before": [
            "            {",
            "                // If this happens, then the explicit tag value expression",
            "                // doesn't seem to be a constant after all.",
            "                getSink()->diagnose(",
            "                    explicitTagValExpr,"
          ],
          "context_after": [
            "            }",
            "        }",
            "        else",
            "        {",
            "            // This tag has no initializer, so it should use"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedIntegerConstantNotLiteral",
      "message": "could not extract value from integer constant",
      "line": 2000,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 42,
          "statement": "getSink()->diagnose(expr->loc, Diagnostics::expectedIntegerConstantNotLiteral);",
          "context_before": [
            "        return nullptr;",
            "",
            "    auto constIntVal = as<ConstantIntVal>(intVal);",
            "    if (!constIntVal)",
            "    {"
          ],
          "context_after": [
            "        return nullptr;",
            "    }",
            "    return constIntVal;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 60,
          "statement": "getSink()->diagnose(expr->loc, Diagnostics::expectedIntegerConstantNotLiteral);",
          "context_before": [
            "        return nullptr;",
            "",
            "    auto constIntVal = as<ConstantIntVal>(intVal);",
            "    if (!constIntVal)",
            "    {"
          ],
          "context_after": [
            "        return nullptr;",
            "    }",
            "    return constIntVal;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedRayTracingPayloadObjectAtLocationButMissing",
      "message": "raytracing payload expected at location $0 but it is missing",
      "line": 2006,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-early-raytracing-intrinsic-simplification.cpp",
          "line": 59,
          "statement": "Diagnostics::expectedRayTracingPayloadObjectAtLocationButMissing, intLitValue);",
          "context_before": [
            "            // if somehow the location tied variable is missing and an error was not thrown by the",
            "            // compiler",
            "            resultVariable = builder.getIntValue(builder.getIntType(), 0);",
            "            sink->diagnose(",
            "                payloadVariable,"
          ],
          "context_after": [
            "                intLitValue);",
            "        }",
            "        else",
            "        {",
            "            resultVariable = *varLayoutPointsTo;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "noApplicableOverloadForNameWithArgs",
      "message": "no overload for '$0' applicable to arguments of type $1",
      "line": 2012,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 2958,
          "statement": "Diagnostics::noApplicableOverloadForNameWithArgs, funcName, argsList);",
          "context_before": [
            "",
            "            if (funcName)",
            "            {",
            "                getSink()->diagnose(",
            "                    expr,"
          ],
          "context_after": [
            "                    funcName,",
            "                    argsList);",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "noApplicableWithArgs",
      "message": "no overload applicable to arguments of type $0",
      "line": 2017,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 2964,
          "statement": "getSink()->diagnose(expr, Diagnostics::noApplicableWithArgs, argsList);",
          "context_before": [
            "                    funcName,",
            "                    argsList);",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        else",
            "        {",
            "            // There were multiple applicable candidates, so we need to report them."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "ambiguousOverloadForNameWithArgs",
      "message": "ambiguous call to '$0' with arguments of type $1",
      "line": 2019,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3023,
          "statement": "Diagnostics::ambiguousOverloadForNameWithArgs, funcName, argsList);",
          "context_before": [
            "                // Use old diagnostic system",
            "                if (funcName)",
            "                {",
            "                    getSink()->diagnose(",
            "                        expr,"
          ],
          "context_after": [
            "                        funcName,",
            "                        argsList);",
            "                }",
            "                else",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "ambiguousOverloadWithArgs",
      "message": "ambiguous call to overloaded operation with arguments of type $0",
      "line": 2024,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3029,
          "statement": "getSink()->diagnose(expr, Diagnostics::ambiguousOverloadWithArgs, argsList);",
          "context_before": [
            "                        funcName,",
            "                        argsList);",
            "                }",
            "                else",
            "                {"
          ],
          "context_after": [
            "                }",
            "",
            "                {",
            "                    Index candidateCount = context.bestCandidates.getCount();",
            "                    Index maxCandidatesToPrint = 10; // don't show too many candidates at once..."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "caseOutsideSwitch",
      "message": "'case' not allowed outside of a 'switch' statement",
      "line": 2035,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 406,
          "statement": "getSink()->diagnose(stmt, Diagnostics::caseOutsideSwitch);",
          "context_before": [
            "void SemanticsStmtVisitor::visitCaseStmt(CaseStmt* stmt)",
            "{",
            "    auto switchStmt = FindOuterStmt<SwitchStmt>();",
            "    if (!switchStmt)",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // Check that the type for the `case` is consistent with the type for the `switch`.",
            "    auto expr = CheckExpr(stmt->expr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 492,
          "statement": "getSink()->diagnose(stmt, Diagnostics::caseOutsideSwitch);",
          "context_before": [
            "        getShared()->getLinkage()->contentAssistInfo.completionSuggestions.scopeKind =",
            "            CompletionSuggestions::ScopeKind::Capabilities;",
            "    }",
            "    if (!switchStmt)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    else",
            "    {",
            "        stmt->targetOuterStmtID = switchStmt->uniqueID;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "defaultOutsideSwitch",
      "message": "'default' not allowed outside of a 'switch' statement",
      "line": 2036,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-stmt.cpp",
          "line": 514,
          "statement": "getSink()->diagnose(stmt, Diagnostics::defaultOutsideSwitch);",
          "context_before": [
            "void SemanticsStmtVisitor::visitDefaultStmt(DefaultStmt* stmt)",
            "{",
            "    auto switchStmt = FindOuterStmt<SwitchStmt>();",
            "    if (!switchStmt)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    else",
            "    {",
            "        // We stash the ID of the target statement in the `case`",
            "        // statement so that they can be correlated later, during"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedAGeneric",
      "message": "expected a generic when using '<...>' (found: '$0')",
      "line": 2042,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3343,
          "statement": "getSink()->diagnose(genericAppExpr, Diagnostics::expectedAGeneric, baseExpr->type);",
          "context_before": [
            "        return CompleteOverloadCandidate(context, *context.bestCandidate);",
            "    }",
            "    else",
            "    {",
            "        // Nothing at all was found that we could even consider invoking"
          ],
          "context_after": [
            "        return CreateErrorExpr(genericAppExpr);",
            "    }",
            "}",
            "",
            "} // namespace Slang"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "genericArgumentInferenceFailed",
      "message": "could not specialize generic for arguments of type $0",
      "line": 2044,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 1159,
          "statement": "getSink()->diagnose(context.loc, Diagnostics::genericArgumentInferenceFailed, callString);",
          "context_before": [
            "{",
            "    // special case for generic argument inference failure",
            "    if (candidate.status == OverloadCandidate::Status::GenericArgumentInferenceFailed)",
            "    {",
            "        String callString = getCallSignatureString(context);"
          ],
          "context_after": [
            "",
            "        String declString = ASTPrinter::getDeclSignatureString(candidate.item, m_astBuilder);",
            "        getSink()->diagnose(candidate.item.declRef, Diagnostics::genericSignatureTried, declString);",
            "        goto error;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "genericSignatureTried"
          ]
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "ambiguousReference",
      "message": "ambiguous reference to '$0'",
      "line": 2050,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1244,
          "statement": "Diagnostics::ambiguousReference, declCandidate->declRef);",
          "context_before": [
            "                                      : nullptr;",
            "            if (auto declCandidate = as<DeclRefExpr>(firstCandidate))",
            "            {",
            "                sink->diagnose(",
            "                    fromExpr->loc,"
          ],
          "context_after": [
            "                    declCandidate->declRef);",
            "            }",
            "            else",
            "            {",
            "                sink->diagnose(fromExpr->loc, Diagnostics::ambiguousExpression);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 5313,
          "statement": "Diagnostics::ambiguousReference, param);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            context->getSink()->diagnose(",
            "                param->firstUse->getUser(),"
          ],
          "context_after": [
            "                param);",
            "        }",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1900,
          "statement": "Diagnostics::ambiguousReference, targetIntrinsic->scrutinee.name);",
          "context_before": [
            "                }",
            "                if (scrutineeResults.isOverloaded())",
            "                {",
            "                    getSink()->diagnose(",
            "                        targetIntrinsic->scrutinee.loc,"
          ],
          "context_after": [
            "                        targetIntrinsic->scrutinee.name);",
            "                }",
            "                targetIntrinsic->scrutineeDeclRef = scrutineeResults.item.declRef;",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1278,
          "statement": "Diagnostics::ambiguousReference, lookupResult.items[0].declRef.getName());",
          "context_before": [
            "    OverloadedExpr* overloadedExpr,",
            "    LookupResult const& lookupResult)",
            "{",
            "    getSink()->diagnose(",
            "        overloadedExpr,"
          ],
          "context_after": [
            "        lookupResult.items[0].declRef.getName());",
            "",
            "    for (auto item : lookupResult.items)",
            "    {",
            "        String declString = ASTPrinter::getDeclSignatureString(item, m_astBuilder);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "ambiguousExpression",
      "message": "ambiguous reference",
      "line": 2051,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1249,
          "statement": "sink->diagnose(fromExpr->loc, Diagnostics::ambiguousExpression);",
          "context_before": [
            "                    Diagnostics::ambiguousReference,",
            "                    declCandidate->declRef);",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        return false;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1296,
          "statement": "getSink()->diagnose(expr, Diagnostics::ambiguousExpression);",
          "context_before": [
            "    {",
            "        diagnoseAmbiguousReference(overloadedExpr, overloadedExpr->lookupResult2);",
            "    }",
            "    else",
            "    {"
          ],
          "context_after": [
            "    }",
            "    expr->type = m_astBuilder->getErrorType();",
            "}",
            "",
            "Expr* SemanticsVisitor::_resolveOverloadedExprImpl("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "declarationDidntDeclareAnything",
      "message": "declaration does not declare anything",
      "line": 2053,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 3034,
          "statement": "parser->sink->diagnose(startPosition, Diagnostics::declarationDidntDeclareAnything);",
          "context_before": [
            "        // that might not be an error.",
            "",
            "        auto result = declGroupBuilder.getResult();",
            "        if (!result)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        return result;",
            "    }",
            "",
            "    // It is possible that we have a plain `struct`, `enum`,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedPrefixOperator",
      "message": "function called as prefix operator was not declared `__prefix`",
      "line": 2055,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 232,
          "statement": "getSink()->diagnose(context.loc, Diagnostics::expectedPrefixOperator);",
          "context_before": [
            "        if (decl->hasModifier<PrefixModifier>())",
            "            return true;",
            "",
            "        if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "        {"
          ],
          "context_after": [
            "            getSink()->diagnose(decl, Diagnostics::seeDefinitionOf, decl->getName());",
            "        }",
            "",
            "        return false;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDefinitionOf"
          ]
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "expectedPostfixOperator",
      "message": "function called as postfix operator was not declared `__postfix`",
      "line": 2060,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 245,
          "statement": "getSink()->diagnose(context.loc, Diagnostics::expectedPostfixOperator);",
          "context_before": [
            "        if (decl->hasModifier<PostfixModifier>())",
            "            return true;",
            "",
            "        if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "        {"
          ],
          "context_after": [
            "            getSink()->diagnose(decl, Diagnostics::seeDefinitionOf, decl->getName());",
            "        }",
            "",
            "        return false;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "seeDefinitionOf"
          ]
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "notEnoughArguments",
      "message": "not enough arguments to call (got $0, expected $1)",
      "line": 2066,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 187,
          "statement": "Diagnostics::notEnoughArguments, argCount, paramCounts.required);",
          "context_before": [
            "    {",
            "        if (argCount < paramCounts.required)",
            "        {",
            "            getSink()->diagnose(",
            "                context.loc,"
          ],
          "context_after": [
            "                argCount,",
            "                paramCounts.required);",
            "        }",
            "        else",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 823,
          "statement": "getSink()->diagnose(attr, Diagnostics::notEnoughArguments, attr->args.getCount(), 1);",
          "context_before": [
            "    }",
            "    else if (auto forceUnrollAttr = as<ForceUnrollAttribute>(attr))",
            "    {",
            "        if (forceUnrollAttr->args.getCount() < 1)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        auto cint = checkConstantIntVal(attr->args[0]);",
            "        if (cint)",
            "            forceUnrollAttr->maxIterations = (int32_t)cint->getValue();",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 833,
          "statement": "getSink()->diagnose(attr, Diagnostics::notEnoughArguments, attr->args.getCount(), 1);",
          "context_before": [
            "    }",
            "    else if (auto maxItersAttrs = as<MaxItersAttribute>(attr))",
            "    {",
            "        if (attr->args.getCount() < 1)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            maxItersAttrs->value = checkLinkTimeConstantIntVal(attr->args[0]);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 883,
          "statement": "Diagnostics::notEnoughArguments, attr->args.getCount(), params.getCount());",
          "context_before": [
            "        }",
            "        else if (params.getCount() > attr->args.getCount())",
            "        {",
            "            getSink()->diagnose(",
            "                attr,"
          ],
          "context_after": [
            "                attr->args.getCount(),",
            "                params.getCount());",
            "        }",
            "    }",
            "    else if (auto diffAttr = as<BackwardDifferentiableAttribute>(attr))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1164,
          "statement": "getSink()->diagnose(attr, Diagnostics::notEnoughArguments, attr->args.getCount(), 2);",
          "context_before": [
            "            getSink()->diagnose(attr, Diagnostics::tooManyArguments, attr->args.getCount(), 0);",
            "            return nullptr;",
            "        }",
            "        else if (attr->args.getCount() < 2)",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "        CapabilityName capName;",
            "        if (!checkCapabilityName(attr->args[0], capName))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2584,
          "statement": "Diagnostics::notEnoughArguments, subscriptExpr->indexExprs.getCount(), 1);",
          "context_before": [
            "    auto baseExpr = subscriptExpr->baseExpression;",
            "    if (subscriptExpr->indexExprs.getCount() < 1)",
            "    {",
            "        getSink()->diagnose(",
            "            subscriptExpr,"
          ],
          "context_after": [
            "            subscriptExpr->indexExprs.getCount(),",
            "            1);",
            "        return CreateErrorExpr(subscriptExpr);",
            "    }",
            "    else if (subscriptExpr->indexExprs.getCount() > 1)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "tooManyArguments",
      "message": "too many arguments to call (got $0, expected $1)",
      "line": 2067,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 196,
          "statement": "Diagnostics::tooManyArguments, argCount, paramCounts.allowed);",
          "context_before": [
            "        else",
            "        {",
            "            SLANG_ASSERT(argCount > paramCounts.allowed);",
            "            getSink()->diagnose(",
            "                context.loc,"
          ],
          "context_after": [
            "                argCount,",
            "                paramCounts.allowed);",
            "        }",
            "",
            "        // Add a note showing the candidate signature for context"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 875,
          "statement": "Diagnostics::tooManyArguments, attr->args.getCount(), params.getCount());",
          "context_before": [
            "        }",
            "        if (params.getCount() < attr->args.getCount())",
            "        {",
            "            getSink()->diagnose(",
            "                attr,"
          ],
          "context_after": [
            "                attr->args.getCount(),",
            "                params.getCount());",
            "        }",
            "        else if (params.getCount() > attr->args.getCount())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1159,
          "statement": "getSink()->diagnose(attr, Diagnostics::tooManyArguments, attr->args.getCount(), 0);",
          "context_before": [
            "    }",
            "    else if (auto requirePreludeAttr = as<RequirePreludeAttribute>(attr))",
            "    {",
            "        if (attr->args.getCount() > 2)",
            "        {"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "        else if (attr->args.getCount() < 2)",
            "        {",
            "            getSink()->diagnose(attr, Diagnostics::notEnoughArguments, attr->args.getCount(), 2);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1195,
          "statement": "getSink()->diagnose(attr, Diagnostics::tooManyArguments, attr->args.getCount(), 0);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            // We should be special-casing the checking of any attribute",
            "            // with a non-zero number of arguments."
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "    }",
            "",
            "    return attr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2593,
          "statement": "Diagnostics::tooManyArguments, subscriptExpr->indexExprs.getCount(), 1);",
          "context_before": [
            "    }",
            "    else if (subscriptExpr->indexExprs.getCount() > 1)",
            "    {",
            "        getSink()->diagnose(",
            "            subscriptExpr,"
          ],
          "context_after": [
            "            subscriptExpr->indexExprs.getCount(),",
            "            1);",
            "        return CreateErrorExpr(subscriptExpr);",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "invalidIntegerLiteralSuffix",
      "message": "invalid suffix '$0' on integer literal",
      "line": 2069,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7910,
          "statement": "parser->sink->diagnose(token, Diagnostics::invalidIntegerLiteralSuffix, suffix);",
          "context_before": [
            "                    }",
            "                }",
            "",
            "                if (unknownCount)",
            "                {"
          ],
          "context_after": [
            "                    suffixBaseType = BaseType::Int;",
            "                }",
            "                // `u` or `ul` suffix -> `uint`",
            "                else if (uCount == 1 && (lCount <= 1) && zCount == 0)",
            "                {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7944,
          "statement": "parser->sink->diagnose(token, Diagnostics::invalidIntegerLiteralSuffix, suffix);",
          "context_before": [
            "                    suffixBaseType = BaseType::UIntPtr;",
            "                }",
            "                // TODO: do we need suffixes for smaller integer types?",
            "                else",
            "                {"
          ],
          "context_after": [
            "                    suffixBaseType = BaseType::Int;",
            "                }",
            "            }",
            "            else if (!hasOverflowed)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "invalidFloatingPointLiteralSuffix",
      "message": "invalid suffix '$0' on floating-point literal",
      "line": 2070,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8024,
          "statement": "Diagnostics::invalidFloatingPointLiteralSuffix, suffix);",
          "context_before": [
            "",
            "                if (unknownCount)",
            "                {",
            "                    parser->sink->diagnose(",
            "                        token,"
          ],
          "context_after": [
            "                        suffix);",
            "                    suffixBaseType = BaseType::Float;",
            "                }",
            "                // `f` suffix -> `float`",
            "                if (fCount == 1 && !lCount && !hCount)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8048,
          "statement": "Diagnostics::invalidFloatingPointLiteralSuffix, suffix);",
          "context_before": [
            "                // TODO: are there other suffixes we need to handle?",
            "                else",
            "                {",
            "                    parser->sink->diagnose(",
            "                        token,"
          ],
          "context_after": [
            "                        suffix);",
            "                    suffixBaseType = BaseType::Float;",
            "                }",
            "            }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Warning",
      "name": "integerLiteralTooLarge",
      "message": "integer literal is too large to be represented in a signed integer type, interpreting as unsigned",
      "line": 2075,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7460,
          "statement": "sink->diagnose(*token, Diagnostics::integerLiteralTooLarge);",
          "context_before": [
            "        // sign will be properly parsed and the value will still be properly stored as a",
            "        // negative INT64_MIN.",
            "",
            "        // Decimal integer is too large to be represented as signed.",
            "        // Output warning that it is represented as unsigned instead."
          ],
          "context_after": [
            "    }",
            "",
            "    return baseType;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Warning",
      "name": "integerLiteralTruncated",
      "message": "integer literal '$0' too large for type '$1' truncated to '$2'",
      "line": 2082,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 7397,
          "statement": "Diagnostics::integerLiteralTruncated, token->getContent(), BaseTypeInfo::asText(baseType), truncatedValue);",
          "context_before": [
            "        if ((!(maskedValue == 0 || maskedValue == mask)) && sink && token)",
            "        {",
            "            // Output a warning that number has been altered",
            "            sink->diagnose(",
            "                *token,"
          ],
          "context_after": [
            "                token->getContent(),",
            "                BaseTypeInfo::asText(baseType),",
            "                truncatedValue);",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Warning",
      "name": "floatLiteralUnrepresentable",
      "message": "$0 literal '$1' unrepresentable, converted to '$2'",
      "line": 2087,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8088,
          "statement": "Diagnostics::floatLiteralUnrepresentable, BaseTypeInfo::asText(suffixBaseType), token.getContent(), fixedValue);",
          "context_before": [
            "                }",
            "            case FloatFixKind::Unrepresentable:",
            "                {",
            "                    parser->sink->diagnose(",
            "                        token,"
          ],
          "context_after": [
            "                        BaseTypeInfo::asText(suffixBaseType),",
            "                        token.getContent(),",
            "                        fixedValue);",
            "                    break;",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Warning",
      "name": "floatLiteralTooSmall",
      "message": "'$1' is smaller than the smallest representable value for type $0, converted to '$2'",
      "line": 2092,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 8078,
          "statement": "Diagnostics::floatLiteralTooSmall, BaseTypeInfo::asText(suffixBaseType), token.getContent(), fixedValue);",
          "context_before": [
            "                }",
            "            case FloatFixKind::Zeroed:",
            "                {",
            "                    parser->sink->diagnose(",
            "                        token,"
          ],
          "context_after": [
            "                        BaseTypeInfo::asText(suffixBaseType),",
            "                        token.getContent(),",
            "                        fixedValue);",
            "                    break;",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "unableToFindSymbolInModule",
      "message": "unable to find the mangled symbol '$0' in module '$1'",
      "line": 2098,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "matrixColumnOrRowCountIsOne",
      "message": "matrices with 1 column or row are not supported by the current code generation target",
      "line": 2104,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 629,
          "statement": "sink->diagnose(matrixType->sourceLoc, Diagnostics::matrixColumnOrRowCountIsOne);",
          "context_before": [
            "                auto rowCount = as<IRIntLit>(matrixType->getRowCount());",
            "",
            "                if ((rowCount && (rowCount->getValue() == 1)) ||",
            "                    (colCount && (colCount->getValue() == 1)))",
            "                {"
          ],
          "context_after": [
            "                }",
            "            }",
            "",
            "            // Matrix element type validation removed to allow integer/bool matrices",
            "            // which will be lowered to arrays of vectors on targets that don't support them"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38000,
      "severity": "Error",
      "name": "entryPointFunctionNotFound",
      "message": "no function found matching entry point name '$0'",
      "line": 2112,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 581,
          "statement": "sink->diagnose(translationUnitSyntax, Diagnostics::entryPointFunctionNotFound, name);",
          "context_before": [
            "    }",
            "",
            "    if (!entryPointFuncDeclRef)",
            "    {",
            "        auto translationUnitSyntax = translationUnit->getModuleDecl();"
          ],
          "context_after": [
            "    }",
            "    return entryPointFuncDeclRef;",
            "}",
            "",
            "// Is a entry pointer parmaeter of `type` always a uniform parameter?"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 4072,
          "statement": "Diagnostics::entryPointFunctionNotFound, entryPoint.name);",
          "context_before": [
            "            Int entryPointID = entryPoint.entryPointID;",
            "            if (entryPointID == -1)",
            "            {",
            "                m_sink->diagnose(",
            "                    SourceLoc(),"
          ],
          "context_after": [
            "                    entryPoint.name);",
            "                continue;",
            "            }",
            "            auto entryPointReq = m_requestImpl->getFrontEndReq()->getEntryPointReqs()[entryPointID];",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38001,
      "severity": "Error",
      "name": "ambiguousEntryPoint",
      "message": "more than one function matches entry point name '$0'",
      "line": 2117,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 38003,
      "severity": "Error",
      "name": "entryPointSymbolNotAFunction",
      "message": "entry point '$0' must be declared as a function",
      "line": 2122,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 38004,
      "severity": "Error",
      "name": "entryPointTypeParameterNotFound",
      "message": "no type found matching entry-point type parameter name '$0'",
      "line": 2128,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 38005,
      "severity": "Error",
      "name": "expectedTypeForSpecializationArg",
      "message": "expected a type as argument for specialization parameter '$0'",
      "line": 2133,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1768,
          "statement": "Diagnostics::expectedTypeForSpecializationArg, genericTypeParamDecl);",
          "context_before": [
            "                Type* argType = as<Type>(arg.val);",
            "                if (!argType)",
            "                {",
            "                    sink->diagnose(",
            "                        param.loc,"
          ],
          "context_after": [
            "                        genericTypeParamDecl);",
            "                    argType = getLinkage()->getASTBuilder()->getErrorType();",
            "                }",
            "",
            "                // TODO: There is a serious flaw to this checking logic if we ever have cases where"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1871,
          "statement": "Diagnostics::expectedTypeForSpecializationArg, interfaceType);",
          "context_before": [
            "                Type* argType = as<Type>(arg.val);",
            "                if (!argType)",
            "                {",
            "                    sink->diagnose(",
            "                        param.loc,"
          ],
          "context_after": [
            "                        interfaceType);",
            "                    argType = getLinkage()->getASTBuilder()->getErrorType();",
            "                }",
            "",
            "                auto witness = visitor.isSubtype(argType, interfaceType, IsSubTypeOptions::None);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38006,
      "severity": "Warning",
      "name": "specifiedStageDoesntMatchAttribute",
      "message": "entry point '$0' being compiled for the '$1' stage has a '[shader(...)]' attribute that specifies the '$2' stage",
      "line": 2139,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1119,
          "statement": "Diagnostics::specifiedStageDoesntMatchAttribute, entryPointFuncDecl->getName(), entryPointProfileStage, entryPointStage);",
          "context_before": [
            "            maybeDiagnose(",
            "                sink,",
            "                optionSet,",
            "                DiagnosticCategory::Capability,",
            "                entryPointFuncDecl,"
          ],
          "context_after": [
            "                entryPointFuncDecl->getName(),",
            "                entryPointProfileStage,",
            "                entryPointStage);",
            "        entryPointProfile.additionalCapabilities.add(CapabilitySet{entryPointAttr->capabilitySet});",
            "        return true;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38007,
      "severity": "Error",
      "name": "entryPointHasNoStage",
      "message": "no stage specified for entry point '$0'; use either a '[shader(\\\"name\\\")]' function attribute or the '-stage <name>' command-line option to specify a stage",
      "line": 2145,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 724,
          "statement": "sink->diagnose(entryPointFuncDecl, Diagnostics::entryPointHasNoStage, entryPointName);",
          "context_before": [
            "    // Every entry point needs to have a stage specified either via",
            "    // command-line/API options, or via an explicit `[shader(\"...\")]` attribute.",
            "    //",
            "    if (stage == Stage::Unknown)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    if (stage == Stage::Hull)",
            "    {",
            "        // TODO: We could consider *always* checking any `[patchconsantfunc(\"...\")]`"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38008,
      "severity": "Error",
      "name": "specializationParameterOfNameNotSpecialized",
      "message": "no specialization argument was provided for specialization parameter '$0'",
      "line": 2152,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 693,
          "statement": "Diagnostics::specializationParameterOfNameNotSpecialized, decl);",
          "context_before": [
            "            auto specializationParam = program->getSpecializationParam(ii);",
            "            if (auto decl = as<Decl>(specializationParam.object))",
            "            {",
            "                sink->diagnose(",
            "                    specializationParam.loc,"
          ],
          "context_after": [
            "                    decl);",
            "            }",
            "            else if (auto type = as<Type>(specializationParam.object))",
            "            {",
            "                sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 700,
          "statement": "Diagnostics::specializationParameterOfNameNotSpecialized, type);",
          "context_before": [
            "            }",
            "            else if (auto type = as<Type>(specializationParam.object))",
            "            {",
            "                sink->diagnose(",
            "                    specializationParam.loc,"
          ],
          "context_after": [
            "                    type);",
            "            }",
            "            else",
            "            {",
            "                sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38008,
      "severity": "Error",
      "name": "specializationParameterNotSpecialized",
      "message": "no specialization argument was provided for specialization parameter",
      "line": 2157,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 707,
          "statement": "Diagnostics::specializationParameterNotSpecialized);",
          "context_before": [
            "            }",
            "            else",
            "            {",
            "                sink->diagnose(",
            "                    specializationParam.loc,"
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        return;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38009,
      "severity": "Error",
      "name": "expectedValueOfTypeForSpecializationArg",
      "message": "expected a constant value of type '$0' as argument for specialization parameter '$1'",
      "line": 2163,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1909,
          "statement": "Diagnostics::expectedValueOfTypeForSpecializationArg, paramDecl->getType(), paramDecl);",
          "context_before": [
            "                IntVal* intVal = as<IntVal>(arg.val);",
            "                if (!intVal)",
            "                {",
            "                    sink->diagnose(",
            "                        param.loc,"
          ],
          "context_after": [
            "                        paramDecl->getType(),",
            "                        paramDecl);",
            "                    intVal =",
            "                        getLinkage()->getASTBuilder()->getIntVal(m_astBuilder->getIntType(), 0);",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38010,
      "severity": "Warning",
      "name": "unhandledModOnEntryPointParameter",
      "message": "$0 on parameter '$1' is unsupported on entry point parameters and will be ignored",
      "line": 2169,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 949,
          "statement": "Diagnostics::unhandledModOnEntryPointParameter, \"attribute '[[vk::binding(...)]]'\", param->getName());",
          "context_before": [
            "    {",
            "        if (param->findModifier<GLSLBindingAttribute>())",
            "        {",
            "            sink->diagnose(",
            "                param,"
          ],
          "context_after": [
            "                \"attribute '[[vk::binding(...)]]'\",",
            "                param->getName());",
            "        }",
            "        if (param->findModifier<PushConstantAttribute>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 957,
          "statement": "Diagnostics::unhandledModOnEntryPointParameter, \"attribute '[[vk::push_constant]]'\", param->getName());",
          "context_before": [
            "        }",
            "        if (param->findModifier<PushConstantAttribute>())",
            "        {",
            "            sink->diagnose(",
            "                param,"
          ],
          "context_after": [
            "                \"attribute '[[vk::push_constant]]'\",",
            "                param->getName());",
            "        }",
            "        if (param->findModifier<HLSLRegisterSemantic>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 965,
          "statement": "Diagnostics::unhandledModOnEntryPointParameter, \"keyword 'register'\", param->getName());",
          "context_before": [
            "        }",
            "        if (param->findModifier<HLSLRegisterSemantic>())",
            "        {",
            "            sink->diagnose(",
            "                param,"
          ],
          "context_after": [
            "                \"keyword 'register'\",",
            "                param->getName());",
            "        }",
            "        if (param->findModifier<HLSLPackOffsetSemantic>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 973,
          "statement": "Diagnostics::unhandledModOnEntryPointParameter, \"keyword 'packoffset'\", param->getName());",
          "context_before": [
            "        }",
            "        if (param->findModifier<HLSLPackOffsetSemantic>())",
            "        {",
            "            sink->diagnose(",
            "                param,"
          ],
          "context_after": [
            "                \"keyword 'packoffset'\",",
            "                param->getName());",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38011,
      "severity": "Error",
      "name": "entryPointCannotReturnResourceType",
      "message": "entry point '$0' cannot return type '$1' that contains resource types",
      "line": 2175,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 713,
          "statement": "Diagnostics::entryPointCannotReturnResourceType, entryPointName, returnType);",
          "context_before": [
            "",
            "        if (hasResourceOrUnsizedTypes)",
            "        {",
            "            sink->diagnose(",
            "                entryPointFuncDecl,"
          ],
          "context_after": [
            "                entryPointName,",
            "                returnType);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38100,
      "severity": "Error",
      "name": "typeDoesntImplementInterfaceRequirement",
      "message": "type '$0' does not provide required interface member '$1'",
      "line": 2181,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1601,
          "statement": "Diagnostics::typeDoesntImplementInterfaceRequirement, type, getName(\"Differential\"));",
          "context_before": [
            "    auto result = tryGetDifferentialType(builder, type);",
            "    if (!result)",
            "    {",
            "        getSink()->diagnose(",
            "            loc,"
          ],
          "context_after": [
            "            type,",
            "            getName(\"Differential\"));",
            "        return m_astBuilder->getErrorType();",
            "    }",
            "    return result;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7209,
          "statement": "Diagnostics::typeDoesntImplementInterfaceRequirement, subType, requiredMemberDeclRef);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                subType,",
            "                requiredMemberDeclRef);",
            "            getSink()->diagnose(",
            "                requiredMemberDeclRef,",
            "                Diagnostics::seeDeclarationOf,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7343,
          "statement": "Diagnostics::typeDoesntImplementInterfaceRequirement, subType, requiredMemberDeclRef);",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inheritanceDecl,"
          ],
          "context_after": [
            "                subType,",
            "                requiredMemberDeclRef);",
            "",
            "            for (auto& item : lookupResult)",
            "                getSink()->diagnose(item.declRef, Diagnostics::seeOverloadConsidered, item.declRef);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38105,
      "severity": "Error",
      "name": "memberDoesNotMatchRequirementSignature",
      "message": "member '$0' does not match interface requirement.",
      "line": 2186,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7336,
          "statement": "Diagnostics::memberDoesNotMatchRequirementSignature, lookupResult.item.declRef);",
          "context_before": [
            "        // General failure - use existing logic",
            "        if (!lookupResult.isOverloaded() && lookupResult.isValid())",
            "        {",
            "            getSink()->diagnose(",
            "                lookupResult.item.declRef,"
          ],
          "context_after": [
            "                lookupResult.item.declRef);",
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38106,
      "severity": "Error",
      "name": "memberReturnTypeMismatch",
      "message": "member '$0' return type '$1' does not match interface requirement return type '$2'.",
      "line": 2191,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7308,
          "statement": "Diagnostics::memberReturnTypeMismatch, failureDetails.candidateMethod, failureDetails.actualType, failureDetails.expectedType);",
          "context_before": [
            "    if (failureDetails.reason == WitnessSynthesisFailureReason::MethodResultTypeMismatch)",
            "    {",
            "        // Emit specific return type mismatch diagnostic",
            "        getSink()->diagnose(",
            "            failureDetails.candidateMethod,"
          ],
          "context_after": [
            "            failureDetails.candidateMethod,",
            "            failureDetails.actualType,",
            "            failureDetails.expectedType);",
            "    }",
            "    else if (failureDetails.reason == WitnessSynthesisFailureReason::ParameterDirMismatch)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38107,
      "severity": "Error",
      "name": "genericSignatureDoesNotMatchRequirement",
      "message": "generic signature of '$0' does not match interface requirement.",
      "line": 2196,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7326,
          "statement": "Diagnostics::genericSignatureDoesNotMatchRequirement, requiredMemberDeclRef.getDecl()->getName());",
          "context_before": [
            "    }",
            "    else if (failureDetails.reason == WitnessSynthesisFailureReason::GenericSignatureMismatch)",
            "    {",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            requiredMemberDeclRef.getDecl()->getName());",
            "    }",
            "    else",
            "    {",
            "        // General failure - use existing logic"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38108,
      "severity": "Error",
      "name": "parameterDirectionDoesNotMatchRequirement",
      "message": "parameter '$0' direction '$1' does not match interface requirement '$2'.",
      "line": 2201,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7317,
          "statement": "Diagnostics::parameterDirectionDoesNotMatchRequirement, failureDetails.paramDecl, failureDetails.actualDir, failureDetails.expectedDir);",
          "context_before": [
            "    }",
            "    else if (failureDetails.reason == WitnessSynthesisFailureReason::ParameterDirMismatch)",
            "    {",
            "        getSink()->diagnose(",
            "            failureDetails.paramDecl,"
          ],
          "context_after": [
            "            failureDetails.paramDecl,",
            "            failureDetails.actualDir,",
            "            failureDetails.expectedDir);",
            "    }",
            "    else if (failureDetails.reason == WitnessSynthesisFailureReason::GenericSignatureMismatch)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38101,
      "severity": "Error",
      "name": "thisExpressionOutsideOfTypeDecl",
      "message": "'this' expression can only be used in members of an aggregate type",
      "line": 2207,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6066,
          "statement": "sink->diagnose(expr, Diagnostics::thisExpressionOutsideOfTypeDecl);",
          "context_before": [
            "",
            "        scope = scope->parent;",
            "    }",
            "",
            "    if (auto sink = getSink())"
          ],
          "context_after": [
            "",
            "    return CreateErrorExpr(expr);",
            "}",
            "",
            "Expr* SemanticsExprVisitor::visitThisTypeExpr(ThisTypeExpr* expr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38102,
      "severity": "Error",
      "name": "initializerNotInsideType",
      "message": "an 'init' declaration is only allowed inside a type or 'extension' declaration",
      "line": 2212,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10818,
          "statement": "getSink()->diagnose(decl, Diagnostics::initializerNotInsideType);",
          "context_before": [
            "    // refer to in the body of the outer declaration.",
            "    //",
            "    auto thisType = calcThisType(makeDeclRef(parent));",
            "    if (!thisType)",
            "    {"
          ],
          "context_after": [
            "        thisType = m_astBuilder->getErrorType();",
            "    }",
            "    return thisType;",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38103,
      "severity": "Error",
      "name": "thisTypeOutsideOfTypeDecl",
      "message": "'This' type can only be used inside of an aggregate type",
      "line": 2217,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6094,
          "statement": "getSink()->diagnose(expr, Diagnostics::thisTypeOutsideOfTypeDecl);",
          "context_before": [
            "            return expr;",
            "        }",
            "        scope = scope->parent;",
            "    }",
            ""
          ],
          "context_after": [
            "    return CreateErrorExpr(expr);",
            "}",
            "",
            "Expr* SemanticsExprVisitor::visitThisInterfaceExpr(ThisInterfaceExpr* expr)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38104,
      "severity": "Error",
      "name": "returnValNotAvailable",
      "message": "cannot use '__return_val' here. '__return_val' is defined only in functions that return a non-copyable value.",
      "line": 2222,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6145,
          "statement": "getSink()->diagnose(expr, Diagnostics::returnValNotAvailable);",
          "context_before": [
            "                expr->type.type = parentFunc->returnType.type;",
            "                return expr;",
            "            }",
            "        }",
            "    }"
          ],
          "context_after": [
            "    expr->type = getASTBuilder()->getErrorType();",
            "    return expr;",
            "}",
            "",
            "Expr* SemanticsExprVisitor::visitAndTypeExpr(AndTypeExpr* expr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38020,
      "severity": "Error",
      "name": "mismatchEntryPointTypeArgument",
      "message": "expecting $0 entry-point type arguments, provided $1.",
      "line": 2228,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 38021,
      "severity": "Error",
      "name": "typeArgumentForGenericParameterDoesNotConformToInterface",
      "message": "type argument `$0` for generic parameter `$1` does not conform to interface `$2`.",
      "line": 2233,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1847,
          "statement": "Diagnostics::typeArgumentForGenericParameterDoesNotConformToInterface, argType, genericTypeParamDecl->nameAndLoc.name, interfaceType);",
          "context_before": [
            "                    {",
            "                        // If no witness was found, then we will be unable to satisfy",
            "                        // the conformances required.",
            "                        sink->diagnose(",
            "                            genericTypeParamDecl,"
          ],
          "context_after": [
            "                            argType,",
            "                            genericTypeParamDecl->nameAndLoc.name,",
            "                            interfaceType);",
            "                    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38022,
      "severity": "Error",
      "name": "cannotSpecializeGlobalGenericToItself",
      "message": "the global type parameter '$0' cannot be specialized to itself",
      "line": 2239,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1804,
          "statement": "Diagnostics::cannotSpecializeGlobalGenericToItself, genericTypeParamDecl->getName());",
          "context_before": [
            "                        if (argGenericParamDeclRef.getDecl() == genericTypeParamDecl)",
            "                        {",
            "                            // We are trying to specialize a generic parameter using itself.",
            "                            sink->diagnose(",
            "                                genericTypeParamDecl,"
          ],
          "context_after": [
            "                                genericTypeParamDecl->getName());",
            "                            continue;",
            "                        }",
            "                        else",
            "                        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38023,
      "severity": "Error",
      "name": "cannotSpecializeGlobalGenericToAnotherGenericParam",
      "message": "the global type parameter '$0' cannot be specialized using another global type parameter ('$1')",
      "line": 2244,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1814,
          "statement": "Diagnostics::cannotSpecializeGlobalGenericToAnotherGenericParam, genericTypeParamDecl->getName(), argGenericParamDeclRef.getName());",
          "context_before": [
            "                        {",
            "                            // We are trying to specialize a generic parameter using a *different*",
            "                            // global generic type parameter.",
            "                            sink->diagnose(",
            "                                genericTypeParamDecl,"
          ],
          "context_after": [
            "                                genericTypeParamDecl->getName(),",
            "                                argGenericParamDeclRef.getName());",
            "                            continue;",
            "                        }",
            "                    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38024,
      "severity": "Error",
      "name": "invalidDispatchThreadIDType",
      "message": "parameter with SV_DispatchThreadID must be either scalar or vector (1 to 3) of uint/int but is $0",
      "line": 2252,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 798,
          "statement": "Diagnostics::invalidDispatchThreadIDType, typeString);",
          "context_before": [
            "                    if (!isValidThreadDispatchIDType(paramType))",
            "                    {",
            "                        String typeString = paramType->toString();",
            "                        sink->diagnose(",
            "                            param->loc,"
          ],
          "context_after": [
            "                            typeString);",
            "                        return;",
            "                    }",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38025,
      "severity": "Error",
      "name": "mismatchSpecializationArguments",
      "message": "expected $0 specialization arguments ($1 provided)",
      "line": 2261,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1737,
          "statement": "Diagnostics::mismatchSpecializationArguments, getSpecializationParamCount(), argCount);",
          "context_before": [
            "{",
            "    if (argCount < getSpecializationParamCount())",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            getSpecializationParamCount(),",
            "            argCount);",
            "        return nullptr;",
            "    }",
            "    outConsumedArgCount = getSpecializationParamCount();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2000,
          "statement": "Diagnostics::mismatchSpecializationArguments, genericSpecializationParamCount + existentialSpecializationParamCount, argCount);",
          "context_before": [
            "",
            "        if (genericArgCount < 0)",
            "        {",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                genericSpecializationParamCount + existentialSpecializationParamCount,",
            "                argCount);",
            "            return nullptr;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2092,
          "statement": "Diagnostics::mismatchSpecializationArguments, genericSpecializationParamCount + existentialSpecializationParamCount, argCount);",
          "context_before": [
            "",
            "    if (argCount < existentialSpecializationParamCount)",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            genericSpecializationParamCount + existentialSpecializationParamCount,",
            "            argCount);",
            "        return nullptr;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2311,
          "statement": "Diagnostics::mismatchSpecializationArguments, specializationParamCount, specializationArgCount);",
          "context_before": [
            "    auto specializationParamCount = unspecializedProgram->getSpecializationParamCount();",
            "    if (specializationArgCount != specializationParamCount)",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            specializationParamCount,",
            "            specializationArgCount);",
            "        return nullptr;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-linkable.cpp",
          "line": 384,
          "statement": "Diagnostics::mismatchSpecializationArguments, Math::Max(consumedArgCount, getSpecializationParamCount()), specializationArgCount);",
          "context_before": [
            "        sink);",
            "    if (consumedArgCount != specializationArgCount)",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            Math::Max(consumedArgCount, getSpecializationParamCount()),",
            "            specializationArgCount);",
            "    }",
            "    if (sink->getErrorCount() != 0)",
            "        return nullptr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38026,
      "severity": "Error",
      "name": "globalTypeArgumentDoesNotConformToInterface",
      "message": "type argument `$1` for global generic parameter `$0` does not conform to interface `$2`.",
      "line": 2266,
      "param_count": 3,
      "call_sites": []
    },
    {
      "id": 38027,
      "severity": "Error",
      "name": "mismatchExistentialSlotArgCount",
      "message": "expected $0 existential slot arguments ($1 provided)",
      "line": 2272,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 38028,
      "severity": "Error",
      "name": "invalidFormOfSpecializationArg",
      "message": "global specialization argument $0 has an invalid form.",
      "line": 2277,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2042,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::invalidFormOfSpecializationArg, ii + 1);",
          "context_before": [
            "                    genericArgs.add(intExpr);",
            "                }",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        auto genAppExpr = astBuilder->create<GenericAppExpr>();",
            "        auto genExpr = astBuilder->create<VarExpr>();",
            "        genExpr->declRef = genericDeclRef;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38029,
      "severity": "Error",
      "name": "typeArgumentDoesNotConformToInterface",
      "message": "type argument '$0' does not conform to the required interface '$1'",
      "line": 2283,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1883,
          "statement": "Diagnostics::typeArgumentDoesNotConformToInterface, argType, interfaceType);",
          "context_before": [
            "                {",
            "                    // If no witness was found, then we will be unable to satisfy",
            "                    // the conformances required.",
            "                    sink->diagnose(",
            "                        SourceLoc(),"
          ],
          "context_after": [
            "                        argType,",
            "                        interfaceType);",
            "                }",
            "",
            "                ExpandedSpecializationArg expandedArg;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2115,
          "statement": "Diagnostics::typeArgumentDoesNotConformToInterface, argType, paramType);",
          "context_before": [
            "        {",
            "            // If no witness was found, then we will be unable to satisfy",
            "            // the conformances required.",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                argType,",
            "                paramType);",
            "            continue;",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 374,
          "statement": "Diagnostics::typeArgumentDoesNotConformToInterface, defaultType, constraintParam->sup);",
          "context_before": [
            "            if (!witness)",
            "            {",
            "                // diagnose",
            "                getSink()->diagnose(",
            "                    genericTypeParamDecl->initType.exp,"
          ],
          "context_after": [
            "                    defaultType,",
            "                    constraintParam->sup);",
            "                return false;",
            "            }",
            "            witnessArgs.add(witness);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 1066,
          "statement": "Diagnostics::typeArgumentDoesNotConformToInterface, sub, sup);",
          "context_before": [
            "            if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "            {",
            "                subTypeWitness = isSubtype(sub, sup, IsSubTypeOptions::None);",
            "                getSink()->diagnose(",
            "                    context.loc,"
          ],
          "context_after": [
            "                    sub,",
            "                    sup);",
            "            }",
            "            return false;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7708,
          "statement": "Diagnostics::typeArgumentDoesNotConformToInterface, aggTypeDecl->aliasedType, superType);",
          "context_before": [
            "            {",
            "                if (!as<ErrorType>(aggTypeDecl->aliasedType))",
            "                {",
            "                    getSink()->diagnose(",
            "                        inheritanceDecl,"
          ],
          "context_after": [
            "                        aggTypeDecl->aliasedType,",
            "                        superType);",
            "                }",
            "            }",
            "            return witness != nullptr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38031,
      "severity": "Error",
      "name": "invalidUseOfNoDiff",
      "message": "'no_diff' can only be used to decorate a call or a subscript operation",
      "line": 2289,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4104,
          "statement": "getSink()->diagnose(expr, Diagnostics::invalidUseOfNoDiff);",
          "context_before": [
            "    {",
            "        innerExpr = parenExpr->base;",
            "    }",
            "    if (!as<InvokeExpr>(innerExpr) && !as<IndexExpr>(innerExpr))",
            "    {"
          ],
          "context_after": [
            "    }",
            "    else if (!m_parentDifferentiableAttr)",
            "    {",
            "        getSink()->diagnose(expr, Diagnostics::cannotUseNoDiffInNonDifferentiableFunc);",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38032,
      "severity": "Error",
      "name": "useOfNoDiffOnDifferentiableFunc",
      "message": "use 'no_diff' on a call to a differentiable function has no meaning.",
      "line": 2294,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3458,
          "statement": "Diagnostics::useOfNoDiffOnDifferentiableFunc);",
          "context_before": [
            "                        }",
            "                        else",
            "                        {",
            "                            getSink()->diagnose(",
            "                                m_treatAsDifferentiableExpr,"
          ],
          "context_after": [
            "                        }",
            "                    }",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38033,
      "severity": "Error",
      "name": "cannotUseNoDiffInNonDifferentiableFunc",
      "message": "cannot use 'no_diff' in a non-differentiable function.",
      "line": 2299,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 4108,
          "statement": "getSink()->diagnose(expr, Diagnostics::cannotUseNoDiffInNonDifferentiableFunc);",
          "context_before": [
            "    {",
            "        getSink()->diagnose(expr, Diagnostics::invalidUseOfNoDiff);",
            "    }",
            "    else if (!m_parentDifferentiableAttr)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    return expr;",
            "}",
            "",
            "Expr* SemanticsExprVisitor::visitGetArrayLengthExpr(GetArrayLengthExpr* expr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38034,
      "severity": "Error",
      "name": "cannotUseBorrowInOnDifferentiableParameter",
      "message": "cannot use 'borrow in' on a differentiable parameter.",
      "line": 2304,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10271,
          "statement": "Diagnostics::cannotUseBorrowInOnDifferentiableParameter);",
          "context_before": [
            "            {",
            "                if (auto modifier = paramDecl->findModifier<BorrowModifier>())",
            "                {",
            "                    getSink()->diagnose(",
            "                        modifier,"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "        if (!isEffectivelyStatic(decl))",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38034,
      "severity": "Error",
      "name": "cannotUseConstRefOnDifferentiableMemberMethod",
      "message": "cannot use '[constref]' on a differentiable member method of a differentiable type.",
      "line": 2309,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 10285,
          "statement": "Diagnostics::cannotUseConstRefOnDifferentiableMemberMethod);",
          "context_before": [
            "            {",
            "                if (isTypeDifferentiable(calcThisType(getParentDecl(decl))))",
            "                {",
            "                    getSink()->diagnose(",
            "                        constrefAttr,"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38040,
      "severity": "Warning",
      "name": "nonUniformEntryPointParameterTreatedAsUniform",
      "message": "parameter '$0' is treated as 'uniform' because it does not have a system-value semantic.",
      "line": 2315,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 930,
          "statement": "Diagnostics::nonUniformEntryPointParameterTreatedAsUniform, param->getName());",
          "context_before": [
            "        addModifier(param, getCurrentASTBuilder()->create<HLSLUniformModifier>());",
            "        if (shouldWarnOnNonUniformParam)",
            "        {",
            "            sink->diagnose(",
            "                param,"
          ],
          "context_after": [
            "                param->getName());",
            "        }",
            "    }",
            "",
            "    // Attribute and keyword diagnostics. Check for the [[vk::binding]] and [[vk::push_constants]]"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38041,
      "severity": "Error",
      "name": "intValFromNonIntSpecConstEncountered",
      "message": "cannot cast non-integer specialization constant to compile-time integer",
      "line": 2321,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2238,
          "statement": "getSink()->diagnose(declRef, Diagnostics::intValFromNonIntSpecConstEncountered);",
          "context_before": [
            "            // to not allow such cases.",
            "            //",
            "            // Note that float-to-inst casts for non-`IntVal`s are allowed.",
            "            if (!isValidCompileTimeConstantType(decl->getType()))",
            "            {"
          ],
          "context_after": [
            "                return nullptr;",
            "            }",
            "",
            "            return m_astBuilder->getOrCreate<DeclRefIntVal>(",
            "                declRef.substitute(m_astBuilder, decl->getType()),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38200,
      "severity": "Error",
      "name": "recursiveModuleImport",
      "message": "module `$0` recursively imports itself",
      "line": 2328,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1437,
          "statement": "sink->diagnose(requestingLoc, Diagnostics::recursiveModuleImport, moduleName);",
          "context_before": [
            "        // hit a recursive case, and that is an error.",
            "        //",
            "        if (isBeingImported(previouslyLoadedModule))",
            "        {",
            "            // We seem to be in the middle of loading this module"
          ],
          "context_after": [
            "            return nullptr;",
            "        }",
            "",
            "        return previouslyLoadedModule;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Error",
      "name": "errorInImportedModule",
      "message": "import of module '$0' failed because of a compilation error",
      "line": 2329,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1234,
          "statement": "sink->diagnose(info->importLoc, Diagnostics::errorInImportedModule, info->name);",
          "context_before": [
            "",
            "void Linkage::_diagnoseErrorInImportedModule(DiagnosticSink* sink)",
            "{",
            "    for (auto info = m_modulesBeingImported; info; info = info->next)",
            "    {"
          ],
          "context_after": [
            "    }",
            "    if (!isInLanguageServer())",
            "    {",
            "        sink->diagnose(SourceLoc(), Diagnostics::compilationCeased);",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38201,
      "severity": "Error",
      "name": "glslModuleNotAvailable",
      "message": "'glsl' module is not available from the current global session. To enable GLSL compatibility mode, specify 'SlangGlobalSessionDesc::enableGLSL' when creating the global session.",
      "line": 2335,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1480,
          "statement": "sink->diagnose(requestingLoc, Diagnostics::glslModuleNotAvailable, moduleName);",
          "context_before": [
            "            // It is unclear if this should be the default behavior or not.",
            "            // Should built-in modules be prioritized over user modules?",
            "            // Should built-in modules shadow user modules, even when the",
            "            // built-in module fails to load, for some reason?",
            "            //"
          ],
          "context_after": [
            "        }",
            "        return glslModule;",
            "    }",
            "",
            "    // We are going to use a loop to search for a suitable file to"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39999,
      "severity": "Fatal",
      "name": "compilationCeased",
      "message": "compilation ceased",
      "line": 2341,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-session.cpp",
          "line": 1238,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::compilationCeased);",
          "context_before": [
            "    {",
            "        sink->diagnose(info->importLoc, Diagnostics::errorInImportedModule, info->name);",
            "    }",
            "    if (!isInLanguageServer())",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "RefPtr<Module> Linkage::loadModuleImpl(",
            "    Name* moduleName,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38203,
      "severity": "Error",
      "name": "vectorWithDisallowedElementTypeEncountered",
      "message": "vector with disallowed element type '$0' encountered",
      "line": 2343,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 652,
          "statement": "Diagnostics::vectorWithDisallowedElementTypeEncountered, targetRequest);",
          "context_before": [
            "            validateVectorOrMatrixElementType(",
            "                sink,",
            "                vectorType->sourceLoc,",
            "                elementType,",
            "                allowedWidths,"
          ],
          "context_after": [
            "                targetRequest);",
            "",
            "            validateVectorElementCount(sink, vectorType);",
            "        }",
            "    }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38203,
      "severity": "Error",
      "name": "vectorWithInvalidElementCountEncountered",
      "message": "vector has invalid element count '$0', valid values are between '$1' and '$2' inclusive",
      "line": 2349,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 603,
          "statement": "Diagnostics::vectorWithInvalidElementCountEncountered, elementCount, \"1\", maxCount);",
          "context_before": [
            "    const IRIntegerValue maxCount = 4;",
            "    if ((elementCount < minCount) || (elementCount > maxCount))",
            "    {",
            "        sink->diagnose(",
            "            vectorType->sourceLoc,"
          ],
          "context_after": [
            "            elementCount,",
            "            \"1\",",
            "            maxCount);",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38204,
      "severity": "Error",
      "name": "cannotUseResourceTypeInStructuredBuffer",
      "message": "StructuredBuffer element type '$0' cannot contain resource or opaque handle types",
      "line": 2355,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 739,
          "statement": "Diagnostics::cannotUseResourceTypeInStructuredBuffer, elementType);",
          "context_before": [
            "    // Check if the element type contains any resource/opaque handle types",
            "    if (containsOpaqueHandleTypeCached(elementType))",
            "    {",
            "        m_sink->diagnose(",
            "            inst->sourceLoc,"
          ],
          "context_after": [
            "            elementType);",
            "        m_hasErrors = true;",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 38205,
      "severity": "Error",
      "name": "recursiveTypesFoundInStructuredBuffer",
      "message": "structured buffer element type '$0' contains recursive type references",
      "line": 2361,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14949,
          "statement": "Diagnostics::recursiveTypesFoundInStructuredBuffer, elementType);",
          "context_before": [
            "    // Check if the element type contains recursive references",
            "    if (containsRecursiveType(visitor, elementType))",
            "    {",
            "        visitor->getSink()->diagnose(",
            "            varDecl->loc,"
          ],
          "context_after": [
            "            elementType);",
            "    }",
            "",
            "    // Check if the element type is NonAddressable",
            "    TypeTag elementTags = visitor->getTypeTags(elementType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39000,
      "severity": "Error",
      "name": "conflictingExplicitBindingsForParameter",
      "message": "conflicting explicit bindings for parameter '$0'",
      "line": 2369,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 885,
          "statement": "Diagnostics::conflictingExplicitBindingsForParameter, getReflectionName(varDecl));",
          "context_before": [
            "        if (bindingInfo.count.compare(count) != std::partial_ordering::equivalent ||",
            "            bindingInfo.index != semanticInfo.index || bindingInfo.space != semanticInfo.space)",
            "        {",
            "            getSink(context)->diagnose(",
            "                varDecl,"
          ],
          "context_after": [
            "                getReflectionName(varDecl));",
            "        }",
            "",
            "        // TODO(tfoley): `register` semantics can technically be",
            "        // profile-specific (not sure if anybody uses that)..."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39001,
      "severity": "Warning",
      "name": "parameterBindingsOverlap",
      "message": "explicit binding for parameter '$0' overlaps with parameter '$1'",
      "line": 2374,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 939,
          "statement": "auto& diagnosticInfo = Diagnostics::parameterBindingsOverlap;",
          "context_before": [
            "                return;",
            "            }",
            "            auto paramA = parameterInfo->varLayout->getVariable();",
            "            auto paramB = overlappedVarLayout->getVariable();",
            ""
          ],
          "context_after": [
            "",
            "            // If *both* of the shader parameters declarations agree",
            "            // that overlapping bindings should be allowed, then we",
            "            // will not emit a diagnostic. Otherwise, we will warn",
            "            // the user because such overlapping bindings are likely"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39002,
      "severity": "Error",
      "name": "shaderParameterDeclarationsDontMatch",
      "message": "declarations of shader parameter '$0' in different translation units don't match",
      "line": 2381,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39007,
      "severity": "Error",
      "name": "unknownRegisterClass",
      "message": "unknown register class: '$0'",
      "line": 2404,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1843,
          "statement": "Diagnostics::unknownRegisterClass, packOffsetModifier->registerName);",
          "context_before": [
            "    {",
            "        if (!packOffsetModifier->registerName.getContent().startsWith(\"c\"))",
            "        {",
            "            getSink()->diagnose(",
            "                packOffsetModifier,"
          ],
          "context_after": [
            "                packOffsetModifier->registerName);",
            "            return m;",
            "        }",
            "        auto uniformOffset =",
            "            stringToInt(packOffsetModifier->registerName.getContent().tail(1)) * 16;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 573,
          "statement": "sink->diagnose(registerLoc, Diagnostics::unknownRegisterClass, registerClassName);",
          "context_before": [
            "    splitNameAndIndex(registerName, registerClassName, registerIndexDigits);",
            "",
            "    LayoutResourceKind kind = findRegisterClassFromName(registerClassName);",
            "    if (kind == LayoutResourceKind::None)",
            "    {"
          ],
          "context_after": [
            "        return info;",
            "    }",
            "",
            "    // For a `register` semantic, the register index is not optional (unlike",
            "    // how it works for varying input/output semantics)."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39008,
      "severity": "Error",
      "name": "expectedARegisterIndex",
      "message": "expected a register index after '$0'",
      "line": 2405,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 581,
          "statement": "sink->diagnose(registerLoc, Diagnostics::expectedARegisterIndex, registerClassName);",
          "context_before": [
            "",
            "    // For a `register` semantic, the register index is not optional (unlike",
            "    // how it works for varying input/output semantics).",
            "    if (registerIndexDigits.getLength() == 0)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    UInt index = 0;",
            "    for (auto c : registerIndexDigits)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39009,
      "severity": "Error",
      "name": "expectedSpace",
      "message": "expected 'space', got '$0'",
      "line": 2406,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 604,
          "statement": "sink->diagnose(spaceLoc, Diagnostics::expectedSpace, spaceSpelling);",
          "context_before": [
            "        {",
            "            sink->diagnose(spaceLoc, Diagnostics::unexpectedSpecifierAfterSpace, spaceName);",
            "        }",
            "        else if (spaceSpelling != UnownedTerminatedStringSlice(\"space\"))",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else if (spaceDigits.getLength() == 0)",
            "        {",
            "            sink->diagnose(spaceLoc, Diagnostics::expectedSpaceIndex);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39010,
      "severity": "Error",
      "name": "expectedSpaceIndex",
      "message": "expected a register space index after 'space'",
      "line": 2407,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 608,
          "statement": "sink->diagnose(spaceLoc, Diagnostics::expectedSpaceIndex);",
          "context_before": [
            "        {",
            "            sink->diagnose(spaceLoc, Diagnostics::expectedSpace, spaceSpelling);",
            "        }",
            "        else if (spaceDigits.getLength() == 0)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            for (auto c : spaceDigits)",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39011,
      "severity": "Error",
      "name": "invalidComponentMask",
      "message": "invalid register component mask '$0'.",
      "line": 2408,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 1868,
          "statement": "Diagnostics::invalidComponentMask, packOffsetModifier->componentMask);",
          "context_before": [
            "                uniformOffset += 12;",
            "                break;",
            "            default:",
            "                getSink()->diagnose(",
            "                    packOffsetModifier,"
          ],
          "context_after": [
            "                    packOffsetModifier->componentMask);",
            "                break;",
            "            }",
            "        }",
            "        packOffsetModifier->uniformOffset = uniformOffset;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39012,
      "severity": "Warning",
      "name": "requestedBindlessSpaceIndexUnavailable",
      "message": "requested bindless space index '$0' is unavailable, using the next available index '$1'.",
      "line": 2410,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-dynamic-resource-heap.cpp",
          "line": 54,
          "statement": "Diagnostics::requestedBindlessSpaceIndexUnavailable, requestedIndex, availableIndex);",
          "context_before": [
            "    if (availableIndex != requestedIndex &&",
            "        targetProgram->getOptionSet().hasOption(CompilerOptionName::BindlessSpaceIndex))",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            requestedIndex,",
            "            availableIndex);",
            "    }",
            "    return availableIndex;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39013,
      "severity": "Warning",
      "name": "registerModifierButNoVulkanLayout",
      "message": "shader parameter '$0' has a 'register' specified for D3D, but no '[[vk::binding(...)]]` specified for Vulkan",
      "line": 2415,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 1095,
          "statement": "Diagnostics::registerModifierButNoVulkanLayout, varDecl.getName());",
          "context_before": [
            "            if (textureType->isCombined())",
            "            {",
            "                // Recommend [[vk::binding]] but not '-fvk-xxx-shift` for combined texture samplers",
            "                getSink(context)->diagnose(",
            "                    registerModifier,"
          ],
          "context_after": [
            "                    varDecl.getName());",
            "                return true;",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39014,
      "severity": "Error",
      "name": "unexpectedSpecifierAfterSpace",
      "message": "unexpected specifier after register space: '$0'",
      "line": 2421,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 600,
          "statement": "sink->diagnose(spaceLoc, Diagnostics::unexpectedSpecifierAfterSpace, spaceName);",
          "context_before": [
            "        UnownedStringSlice spaceDigits;",
            "        splitNameAndIndex(spaceName, spaceSpelling, spaceDigits);",
            "",
            "        if (kind == LayoutResourceKind::SubElementRegisterSpace)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else if (spaceSpelling != UnownedTerminatedStringSlice(\"space\"))",
            "        {",
            "            sink->diagnose(spaceLoc, Diagnostics::expectedSpace, spaceSpelling);",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39015,
      "severity": "Error",
      "name": "wholeSpaceParameterRequiresZeroBinding",
      "message": "shader parameter '$0' consumes whole descriptor sets, so the binding must be in the form '[[vk::binding(0, ...)]]'; the non-zero binding '$1' is not allowed",
      "line": 2426,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 1236,
          "statement": "Diagnostics::wholeSpaceParameterRequiresZeroBinding, varDecl.getName(), attr->binding);",
          "context_before": [
            "                info[kResInfo].resInfo = foundResInfo;",
            "                if (attr->binding != 0)",
            "                {",
            "                    getSink(context)->diagnose(",
            "                        attr,"
          ],
          "context_after": [
            "                        varDecl.getName(),",
            "                        attr->binding);",
            "                }",
            "                info[kResInfo].semanticInfo.index = attr->set;",
            "                info[kResInfo].semanticInfo.space = 0;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39016,
      "severity": "Warning",
      "name": "hlslToVulkanMappingNotFound",
      "message": "unable to infer Vulkan binding for '$0', automatic layout will be used",
      "line": 2433,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39017,
      "severity": "Error",
      "name": "dontExpectOutParametersForStage",
      "message": "the '$0' stage does not support `out` or `inout` entry point parameters",
      "line": 2439,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2108,
          "statement": "Diagnostics::dontExpectOutParametersForStage, getStageName(state.stage));",
          "context_before": [
            "        case Stage::Intersection:",
            "        case Stage::RayGeneration:",
            "            // Don't expect this case to have any `in out` parameters.",
            "            getSink(context)->diagnose(",
            "                state.loc,"
          ],
          "context_after": [
            "                getStageName(state.stage));",
            "            break;",
            "",
            "        case Stage::AnyHit:",
            "        case Stage::ClosestHit:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39018,
      "severity": "Error",
      "name": "dontExpectInParametersForStage",
      "message": "the '$0' stage does not support `in` entry point parameters",
      "line": 2444,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2149,
          "statement": "Diagnostics::dontExpectInParametersForStage, getStageName(state.stage));",
          "context_before": [
            "            // an `in` parameter as indicating a payload that the",
            "            // programmer doesn't intend to write to.",
            "            //",
            "            getSink(context)->diagnose(",
            "                state.loc,"
          ],
          "context_after": [
            "                getStageName(state.stage));",
            "            break;",
            "",
            "        case Stage::AnyHit:",
            "        case Stage::ClosestHit:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39019,
      "severity": "Warning",
      "name": "globalUniformNotExpected",
      "message": "'$0' is implicitly a global shader parameter, not a global variable. If a global variable is intended, add the 'static' modifier. If a uniform shader parameter is intended, add the 'uniform' modifier to silence this warning.",
      "line": 2450,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 3512,
          "statement": "->diagnose(varDecl, Diagnostics::globalUniformNotExpected, varDecl->getName());",
          "context_before": [
            "    // Don't emit the implicit global shader parameter warning if the variable is explicitly",
            "    // marked as uniform",
            "    if (!varDecl->hasModifier<HLSLUniformModifier>())",
            "    {",
            "        getSink(sharedContext)"
          ],
          "context_after": [
            "    }",
            "",
            "    // Always check and warn about binding attributes being ignored, regardless of uniform",
            "    // modifier",
            "    if (varDecl->findModifier<GLSLBindingAttribute>())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39020,
      "severity": "Error",
      "name": "tooManyShaderRecordConstantBuffers",
      "message": "can have at most one 'shader record' attributed constant buffer; found $0.",
      "line": 2458,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 4321,
          "statement": "Diagnostics::tooManyShaderRecordConstantBuffers, numShaderRecordRegs);",
          "context_before": [
            "            LayoutResourceKind::ShaderRecord);",
            "        if (numShaderRecordRegs > 1)",
            "        {",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                numShaderRecordRegs);",
            "        }",
            "    }",
            "",
            "    return programLayout;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39021,
      "severity": "Error",
      "name": "typeParametersNotAllowedOnEntryPointGlobal",
      "message": "local-root-signature shader parameter '$0' at global scope must not include existential/interface types",
      "line": 2464,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39022,
      "severity": "Warning",
      "name": "vkIndexWithoutVkLocation",
      "message": "ignoring '[[vk::index(...)]]` attribute without a corresponding '[[vk::location(...)]]' attribute",
      "line": 2471,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2027,
          "statement": "Diagnostics::vkIndexWithoutVkLocation, decl->getName());",
          "context_before": [
            "        }",
            "        else if (auto indexAttr = decl->findModifier<GLSLIndexAttribute>())",
            "        {",
            "            getSink(context)->diagnose(",
            "                indexAttr,"
          ],
          "context_after": [
            "                decl->getName());",
            "        }",
            "    }",
            "",
            "    return typeLayout;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39023,
      "severity": "Error",
      "name": "mixingImplicitAndExplicitBindingForVaryingParams",
      "message": "mixing explicit and implicit bindings for varying parameters is not supported (see '$0' and '$1')",
      "line": 2477,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2518,
          "statement": "Diagnostics::mixingImplicitAndExplicitBindingForVaryingParams, firstImplicit->getName(), firstExplicit->getName());",
          "context_before": [
            "                }",
            "                if (firstImplicit && firstExplicit)",
            "                {",
            "                    getSink(context)->diagnose(",
            "                        firstImplicit,"
          ],
          "context_after": [
            "                        firstImplicit->getName(),",
            "                        firstExplicit->getName());",
            "                }",
            "",
            "                return structLayout;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39024,
      "severity": "Warning",
      "name": "cannotInferVulkanBindingWithoutRegisterModifier",
      "message": "shader parameter '$0' doesn't have a 'register' specified, automatic layout will be used",
      "line": 2484,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 39025,
      "severity": "Error",
      "name": "conflictingVulkanInferredBindingForParameter",
      "message": "conflicting vulkan inferred binding for parameter '$0' overlap is $1 and $2",
      "line": 2490,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 3966,
          "statement": "Diagnostics::conflictingVulkanInferredBindingForParameter, getReflectionName(clashingVarLayout->getVariable()), curRangeBuf, clashRangeBuf);",
          "context_before": [
            "                        _appendRange(clashRange.begin, LayoutSize(clashRange.end), clashRangeBuf);",
            "",
            "                        // Report the clash.",
            "                        sink->diagnose(",
            "                            curVar,"
          ],
          "context_after": [
            "                            getReflectionName(clashingVarLayout->getVariable()),",
            "                            curRangeBuf,",
            "                            clashRangeBuf);",
            "                    }",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39026,
      "severity": "Error",
      "name": "matrixLayoutModifierOnNonMatrixType",
      "message": "matrix layout modifier cannot be used on non-matrix type '$0'.",
      "line": 2496,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6234,
          "statement": "Diagnostics::matrixLayoutModifierOnNonMatrixType, baseType);",
          "context_before": [
            "            }",
            "            else",
            "            {",
            "                getSink()->diagnose(",
            "                    matrixLayoutModifier,"
          ],
          "context_after": [
            "                    baseType);",
            "            }",
            "            continue;",
            "        }",
            "        auto modifierVal = checkTypeModifier(modifier, baseType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39027,
      "severity": "Error",
      "name": "getAttributeAtVertexMustReferToPerVertexInput",
      "message": "'GetAttributeAtVertex' must reference a vertex input directly, and the vertex input must be decorated with 'pervertex' or 'nointerpolation'.",
      "line": 2502,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5070,
          "statement": "Diagnostics::getAttributeAtVertexMustReferToPerVertexInput);",
          "context_before": [
            "            auto vertexAttributeArgDeclRefExpr = as<DeclRefExpr>(vertexAttributeArg);",
            "            if (!vertexAttributeArgDeclRefExpr)",
            "            {",
            "                getSink()->diagnose(",
            "                    invokeExpr,"
          ],
          "context_after": [
            "                return;",
            "            }",
            "            auto vertexAttributeArgDecl = vertexAttributeArgDeclRefExpr->declRef.getDecl();",
            "            if (!vertexAttributeArgDecl)",
            "                return;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 5081,
          "statement": "Diagnostics::getAttributeAtVertexMustReferToPerVertexInput);",
          "context_before": [
            "            if (!vertexAttributeArgDecl->findModifier<PerVertexModifier>() &&",
            "                !vertexAttributeArgDecl->findModifier<HLSLNoInterpolationModifier>())",
            "            {",
            "                getSink()->diagnose(",
            "                    vertexAttributeArgDeclRefExpr,"
          ],
          "context_after": [
            "                return;",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39028,
      "severity": "Error",
      "name": "notValidVaryingParameter",
      "message": "parameter '$0' is not a valid varying parameter.",
      "line": 2509,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2385,
          "statement": "Diagnostics::notValidVaryingParameter, fieldType);",
          "context_before": [
            "",
            "                if (!fieldTypeLayout)",
            "                {",
            "                    getSink(context)->diagnose(",
            "                        varLayout->varDecl,"
          ],
          "context_after": [
            "                        fieldType);",
            "                    continue;",
            "                }",
            "                fieldVarLayout->typeLayout = fieldTypeLayout;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 2463,
          "statement": "Diagnostics::notValidVaryingParameter, field);",
          "context_before": [
            "",
            "                    if (!fieldTypeLayout)",
            "                    {",
            "                        getSink(context)->diagnose(",
            "                            field,"
          ],
          "context_after": [
            "                            field);",
            "                        continue;",
            "                    }",
            "                    fieldVarLayout->typeLayout = fieldTypeLayout;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39029,
      "severity": "Warning",
      "name": "registerModifierButNoVkBindingNorShift",
      "message": "shader parameter '$0' has a 'register' specified for D3D, but no '[[vk::binding(...)]]` specified for Vulkan, nor is `-fvk-$1-shift` used.",
      "line": 2515,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 1110,
          "statement": "Diagnostics::registerModifierButNoVkBindingNorShift, varDecl.getName(), registerClassName);",
          "context_before": [
            "            registerClassName,",
            "            registerIndexDigits);",
            "",
            "        getSink(context)->diagnose(",
            "            registerModifier,"
          ],
          "context_after": [
            "            varDecl.getName(),",
            "            registerClassName);",
            "        return true;",
            "    }",
            "    return false;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 39071,
      "severity": "Warning",
      "name": "bindingAttributeIgnoredOnUniform",
      "message": "binding attribute on uniform '$0' will be ignored since it will be packed into the default constant buffer at descriptor set 0 binding 0. To use explicit bindings, declare the uniform inside a constant buffer.",
      "line": 2522,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 3521,
          "statement": "Diagnostics::bindingAttributeIgnoredOnUniform, varDecl->getName());",
          "context_before": [
            "    // modifier",
            "    if (varDecl->findModifier<GLSLBindingAttribute>())",
            "    {",
            "        sharedContext->m_sink->diagnose(",
            "            varDecl,"
          ],
          "context_after": [
            "            varDecl->getName());",
            "    }",
            "}",
            "",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40001,
      "severity": "Error",
      "name": "bindingAlreadyOccupiedByComponent",
      "message": "resource binding location '$0' is already occupied by component '$1'.",
      "line": 2534,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 40002,
      "severity": "Error",
      "name": "invalidBindingValue",
      "message": "binding location '$0' is out of valid range.",
      "line": 2539,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 40003,
      "severity": "Error",
      "name": "bindingExceedsLimit",
      "message": "binding location '$0' assigned to component '$1' exceeds maximum limit.",
      "line": 2540,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 40004,
      "severity": "Error",
      "name": "bindingAlreadyOccupiedByModule",
      "message": "DescriptorSet ID '$0' is already occupied by module instance '$1'.",
      "line": 2545,
      "param_count": 2,
      "call_sites": []
    },
    {
      "id": 40005,
      "severity": "Error",
      "name": "topLevelModuleUsedWithoutSpecifyingBinding",
      "message": "top level module '$0' is being used without specifying binding location. Use [Binding: \\\"index\\\"] attribute to provide a binding location.",
      "line": 2550,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 40006,
      "severity": "Error",
      "name": "unimplementedSystemValueSemantic",
      "message": "unknown system-value semantic '$0'",
      "line": 2556,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 4058,
          "statement": "Diagnostics::unimplementedSystemValueSemantic, semanticName);",
          "context_before": [
            "                break;",
            "            }",
            "        default:",
            "            m_sink->diagnose(",
            "                parentVar,"
          ],
          "context_after": [
            "                semanticName);",
            "            return result;",
            "        }",
            "        return result;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 4682,
          "statement": "Diagnostics::unimplementedSystemValueSemantic, semanticName);",
          "context_before": [
            "            }",
            "        default:",
            "            {",
            "                m_sink->diagnose(",
            "                    parentVar,"
          ],
          "context_after": [
            "                    semanticName);",
            "                return result;",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 49999,
      "severity": "Error",
      "name": "unknownSystemValueSemantic",
      "message": "unknown system-value semantic '$0'",
      "line": 2558,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 149,
          "statement": "Diagnostics::unknownSystemValueSemantic, baseName);",
          "context_before": [
            "    {",
            "        diagnoseCapabilityErrors(",
            "            sink,",
            "            visitor->getOptionSet(),",
            "            loc,"
          ],
          "context_after": [
            "            baseName);",
            "        return;",
            "    }",
            "",
            "    // If the semantic has no accessors defined, it accepts any type (e.g., ray tracing payloads)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 987,
          "statement": "Diagnostics::unknownSystemValueSemantic, semanticNameSpelling);",
          "context_before": [
            "        return inStorage;",
            "    }",
            "",
            "    context->getSink()->diagnose(",
            "        varLayout->sourceLoc,"
          ],
          "context_after": [
            "        semanticNameSpelling);",
            "    return nullptr;",
            "}",
            "",
            "void createVarLayoutForLegalizedGlobalParam("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40007,
      "severity": "Internal",
      "name": "irValidationFailed",
      "message": "IR validation failed: $0",
      "line": 2560,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 62,
          "statement": "context->getSink()->diagnose(inst, Diagnostics::irValidationFailed, message);",
          "context_before": [
            "{",
            "    if (!condition)",
            "    {",
            "        if (context)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        else",
            "        {",
            "            SLANG_ASSERT_FAILURE(\"IR validation failed\");",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40008,
      "severity": "Error",
      "name": "invalidLValueForRefParameter",
      "message": "the form of this l-value argument is not valid for a `ref` parameter",
      "line": 2562,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 8249,
          "statement": "context->getSink()->diagnose(diagnosticLocation, Diagnostics::invalidLValueForRefParameter);",
          "context_before": [
            "    if (val.flavor == LoweredValInfo::Flavor::Ptr)",
            "    {",
            "        return val.val;",
            "    }",
            ""
          ],
          "context_after": [
            "    return nullptr;",
            "}",
            "",
            "void assignExpr(",
            "    IRGenContext* context,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40009,
      "severity": "Error",
      "name": "dynamicInterfaceLacksAnyValueSizeAttribute",
      "message": "interface '$0' is being used in dynamic dispatch code but has no [anyValueSize] attribute defined.",
      "line": 2568,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 40011,
      "severity": "Error",
      "name": "unconstrainedGenericParameterNotAllowedInDynamicFunction",
      "message": "unconstrained generic paramter '$0' is not allowed in a dynamic function.",
      "line": 2576,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 40012,
      "severity": "Error",
      "name": "needCompileTimeConstant",
      "message": "expected a compile-time constant",
      "line": 2582,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-constexpr.cpp",
          "line": 555,
          "statement": "Diagnostics::needCompileTimeConstant);",
          "context_before": [
            "",
            "                        // Diagnose the failure.",
            "",
            "                        context->getSink()->diagnose(",
            "                            ii->sourceLoc,"
          ],
          "context_after": [
            "",
            "                        break;",
            "                    }",
            "                }",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40013,
      "severity": "Error",
      "name": "argIsNotConstexpr",
      "message": "arg $0 in '$1' is not a compile-time constant",
      "line": 2584,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-constexpr.cpp",
          "line": 455,
          "statement": "Diagnostics::argIsNotConstexpr, pp + 1, calleeFunc);",
          "context_before": [
            "                                // that. This is not expected.",
            "                                if (!isConstExpr(arg))",
            "                                {",
            "                                    context->getSink()->diagnose(",
            "                                        callInst->sourceLoc,"
          ],
          "context_after": [
            "                                        pp + 1,",
            "                                        calleeFunc);",
            "                                    return false;",
            "                                }",
            "                            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40020,
      "severity": "Error",
      "name": "cannotUnrollLoop",
      "message": "loop does not terminate within the limited number of iterations, unrolling is aborted.",
      "line": 2586,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-loop-unroll.cpp",
          "line": 558,
          "statement": "sink->diagnose(loopLoc, Diagnostics::cannotUnrollLoop);",
          "context_before": [
            "        auto blocks = collectBlocksInRegion(func, loop);",
            "        auto loopLoc = loop->sourceLoc;",
            "        if (!_unrollLoop(targetProgram, module, loop, blocks))",
            "        {",
            "            if (sink)"
          ],
          "context_after": [
            "            return false;",
            "        }",
            "",
            "        // Make sure we simplify things as much as possible before",
            "        // attempting to potentially unroll outer loop."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40030,
      "severity": "Fatal",
      "name": "functionNeverReturnsFatal",
      "message": "function '$0' never returns, compilation ceased.",
      "line": 2592,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-autodiff-rev.cpp",
          "line": 661,
          "statement": "getSink()->diagnose(func->sourceLoc, Diagnostics::functionNeverReturnsFatal, func);",
          "context_before": [
            "    }",
            "    else if (returnCount == 0)",
            "    {",
            "        // The function is ill-formed and never returns (such as having an infinite loop),",
            "        // we can't possibly reverse-differentiate such functions, so we will diagnose it here."
          ],
          "context_after": [
            "    }",
            "",
            "    eliminateContinueBlocksInFunc(func->getModule(), func);",
            "",
            "    eliminateMultiLevelBreakForFunc(autoDiffSharedContext->targetProgram, func->getModule(), func);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41000,
      "severity": "Warning",
      "name": "unreachableCode",
      "message": "unreachable code detected",
      "line": 2600,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 6696,
          "statement": "context->getSink()->diagnose(stmt, Diagnostics::unreachableCode);",
          "context_before": [
            "        //",
            "        // TODO: We might want to have a more robust check",
            "        // for unreachable code based on IR analysis instead,",
            "        // at which point we'd probably disable this check.",
            "        //"
          ],
          "context_after": [
            "",
            "        startBlock();",
            "    }",
            "",
            "    /// Create a new scope end block and return the previous one."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41001,
      "severity": "Error",
      "name": "recursiveType",
      "message": "type '$0' contains cyclic reference to itself.",
      "line": 2601,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-recursion.cpp",
          "line": 18,
          "statement": "sink->diagnose(field ? field : type, Diagnostics::recursiveType, type);",
          "context_before": [
            "{",
            "    auto visitElementType = [&](IRInst* elementType, IRInst* field) -> bool",
            "    {",
            "        if (!stack.add(elementType))",
            "        {"
          ],
          "context_after": [
            "            return false;",
            "        }",
            "        if (checkedTypes.add(elementType))",
            "            checkTypeRecursionImpl(checkedTypes, stack, elementType, field, sink);",
            "        stack.remove(elementType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41009,
      "severity": "Error",
      "name": "missingReturnError",
      "message": "non-void function must return in all cases for target '$0'",
      "line": 2603,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-missing-return.cpp",
          "line": 44,
          "statement": "Diagnostics::missingReturnError, TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
          "context_before": [
            "    }",
            "    else",
            "    {",
            "        sink->diagnose(",
            "            missingReturn,"
          ],
          "context_after": [
            "            TypeTextUtil::getCompileTargetName(SlangCompileTarget(target)));",
            "    }",
            "}",
            "",
            "void checkForMissingReturnsRec("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41010,
      "severity": "Warning",
      "name": "missingReturn",
      "message": "non-void function does not return in all cases",
      "line": 2608,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-missing-return.cpp",
          "line": 37,
          "statement": "sink->diagnose(missingReturn, Diagnostics::missingReturn);",
          "context_before": [
            "{",
            "    if (doesTargetAllowMissingReturns(target))",
            "    {",
            "        if (diagnoseWarning)",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "    else",
            "    {",
            "        sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41011,
      "severity": "Error",
      "name": "profileIncompatibleWithTargetSwitch",
      "message": "__target_switch has no compatable target with current profile '$0'",
      "line": 2609,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-specialize-target-switch.cpp",
          "line": 80,
          "statement": "Diagnostics::profileIncompatibleWithTargetSwitch, target->getTargetCaps());",
          "context_before": [
            "                // due to incompatability within same `target` atom. Otherwise we will have an issue",
            "                // when we process a `__target_switch() { case metal: return; }` for glsl targets.",
            "                if (failedImplies)",
            "                    sink->diagnose(",
            "                        targetSwitch->sourceLoc,"
          ],
          "context_after": [
            "                        target->getTargetCaps());",
            "                builder.emitMissingReturn();",
            "            }",
            "            targetSwitch->removeAndDeallocate();",
            "            changed = true;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41012,
      "severity": "Warning",
      "name": "profileImplicitlyUpgraded",
      "message": "entry point '$0' uses additional capabilities that are not part of the specified profile '$1'. The profile setting is automatically updated to include these capabilities: '$2'",
      "line": 2614,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1069,
          "statement": "Diagnostics::profileImplicitlyUpgraded, Diagnostics::profileImplicitlyUpgradedRestrictive, entryPointFuncDecl, target->getOptionSet().getProfile().getName(), addedAtoms.getElements<CapabilityAtom>());",
          "context_before": [
            "                maybeDiagnoseWarningOrError(",
            "                    sink,",
            "                    target->getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    entryPointFuncDecl->loc,"
          ],
          "context_after": [
            "                    Diagnostics::profileImplicitlyUpgradedRestrictive,",
            "                    entryPointFuncDecl,",
            "                    target->getOptionSet().getProfile().getName(),",
            "                    addedAtoms.getElements<CapabilityAtom>());",
            "            }"
          ],
          "call_pattern": "unknown",
          "uses_notes": [
            "profileImplicitlyUpgradedRestrictive"
          ]
        }
      ]
    },
    {
      "id": 41012,
      "severity": "Error",
      "name": "profileImplicitlyUpgradedRestrictive",
      "message": "entry point '$0' uses capabilities that are not part of the specified profile '$1'. Missing capabilities are: '$2'",
      "line": 2620,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 1070,
          "statement": "Diagnostics::profileImplicitlyUpgradedRestrictive, entryPointFuncDecl, target->getOptionSet().getProfile().getName(), addedAtoms.getElements<CapabilityAtom>());",
          "context_before": [
            "                    sink,",
            "                    target->getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    entryPointFuncDecl->loc,",
            "                    Diagnostics::profileImplicitlyUpgraded,"
          ],
          "context_after": [
            "                    entryPointFuncDecl,",
            "                    target->getOptionSet().getProfile().getName(),",
            "                    addedAtoms.getElements<CapabilityAtom>());",
            "            }",
            "        }"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41015,
      "severity": "Warning",
      "name": "usingUninitializedOut",
      "message": "use of uninitialized out parameter '$0'",
      "line": 2626,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 586,
          "statement": ": Diagnostics::usingUninitializedOut, param);",
          "context_before": [
            "    for (auto load : loads)",
            "    {",
            "        sink->diagnose(",
            "            load,",
            "            as<IRTerminatorInst>(load) ? Diagnostics::returningWithUninitializedOut"
          ],
          "context_after": [
            "            param);",
            "    }",
            "}",
            "",
            "static void checkUninitializedValues(IRFunc* func, DiagnosticSink* sink)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41016,
      "severity": "Warning",
      "name": "usingUninitializedVariable",
      "message": "use of uninitialized variable '$0'",
      "line": 2627,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 650,
          "statement": "sink->diagnose(load, Diagnostics::usingUninitializedVariable, inst);",
          "context_before": [
            "                bool hasName = inst->findDecoration<IRNameHintDecoration>() != nullptr ||",
            "                               inst->findDecoration<IRLinkageDecoration>() != nullptr;",
            "",
            "                if (hasName)",
            "                {"
          ],
          "context_after": [
            "                }",
            "                else",
            "                {",
            "                    // For poison ops and other unnamed instructions, show type instead",
            "                    sink->diagnose(load, Diagnostics::usingUninitializedValue, type);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41016,
      "severity": "Warning",
      "name": "usingUninitializedValue",
      "message": "use of uninitialized value of type '$0'",
      "line": 2628,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 655,
          "statement": "sink->diagnose(load, Diagnostics::usingUninitializedValue, type);",
          "context_before": [
            "                    sink->diagnose(load, Diagnostics::usingUninitializedVariable, inst);",
            "                }",
            "                else",
            "                {",
            "                    // For poison ops and other unnamed instructions, show type instead"
          ],
          "context_after": [
            "                }",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41017,
      "severity": "Warning",
      "name": "usingUninitializedGlobalVariable",
      "message": "use of uninitialized global variable '$0'",
      "line": 2629,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 707,
          "statement": "sink->diagnose(load, Diagnostics::usingUninitializedGlobalVariable, variable);",
          "context_before": [
            "        }",
            "    }",
            "",
            "    for (auto load : loads)",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void checkForUsingUninitializedValues(IRModule* module, DiagnosticSink* sink)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41018,
      "severity": "Warning",
      "name": "returningWithUninitializedOut",
      "message": "returning without initializing out parameter '$0'",
      "line": 2634,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 585,
          "statement": "as<IRTerminatorInst>(load) ? Diagnostics::returningWithUninitializedOut : Diagnostics::usingUninitializedOut, param);",
          "context_before": [
            "    auto loads = getUnresolvedParamLoads(reachability, func, param);",
            "    for (auto load : loads)",
            "    {",
            "        sink->diagnose(",
            "            load,"
          ],
          "context_after": [
            "                                       : Diagnostics::usingUninitializedOut,",
            "            param);",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "usingUninitializedOut"
          ]
        }
      ]
    },
    {
      "id": 41019,
      "severity": "Warning",
      "name": "returningWithPartiallyUninitializedOut",
      "message": "returning without fully initializing out parameter '$0'",
      "line": 2639,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 41020,
      "severity": "Warning",
      "name": "constructorUninitializedField",
      "message": "exiting constructor without initializing field '$0'",
      "line": 2644,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 554,
          "statement": "sink->diagnose(ret, Diagnostics::constructorUninitializedField, field->getKey());",
          "context_before": [
            "                    stype,",
            "                    field->getKey());",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "    };",
            "",
            "    // Work backwards, get exit points and find sources"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41021,
      "severity": "Warning",
      "name": "fieldNotDefaultInitialized",
      "message": "default initializer for '$0' will not initialize field '$1'",
      "line": 2649,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-use-uninitialized-values.cpp",
          "line": 548,
          "statement": "Diagnostics::fieldNotDefaultInitialized, stype, field->getKey());",
          "context_before": [
            "        {",
            "            if (synthesized)",
            "            {",
            "                sink->diagnose(",
            "                    field->getKey(),"
          ],
          "context_after": [
            "                    stype,",
            "                    field->getKey());",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41022,
      "severity": "Warning",
      "name": "inOutNeverStoredInto",
      "message": "inout parameter '$0' is never written to",
      "line": 2654,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 41023,
      "severity": "Warning",
      "name": "methodNeverMutates",
      "message": "method marked `[mutable]` but never modifies `this`",
      "line": 2655,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 41024,
      "severity": "Warning",
      "name": "commaOperatorUsedInExpression",
      "message": "comma operator used in expression (may be unintended)",
      "line": 2660,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3361,
          "statement": "getSink()->diagnose(infixExpr, Diagnostics::commaOperatorUsedInExpression);",
          "context_before": [
            "        {",
            "            // Allow comma operators in for-loop side effects and expand expressions without",
            "            // warning",
            "            if (!getInForLoopSideEffect() && !m_parentExpandExpr)",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "",
            "    expr->functionExpr = CheckTerm(expr->functionExpr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41026,
      "severity": "Warning",
      "name": "switchFallthroughRestructured",
      "message": "switch fall-through is not supported by this target and will be restructured; this may affect wave/subgroup convergence if the duplicated code contains wave operations",
      "line": 2666,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-restructure.cpp",
          "line": 688,
          "statement": "Diagnostics::switchFallthroughRestructured);",
          "context_before": [
            "                                breakLabel,",
            "                                visited))",
            "                        {",
            "                            ctx->getSink()->diagnose(",
            "                                switchInst,"
          ],
          "context_after": [
            "                            warnedAboutFallthrough = true;",
            "                        }",
            "                    }",
            "",
            "                    // Now we can actually generate the region."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41024,
      "severity": "Error",
      "name": "cannotDefaultInitializeResource",
      "message": "cannot default-initialize $0 with '{}'. Resource types must be explicitly initialized",
      "line": 2673,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-detect-uninitialized-resources.cpp",
          "line": 206,
          "statement": "Diagnostics::cannotDefaultInitializeResource, resourceName);",
          "context_before": [
            "                    {",
            "                        // Direct resource initialization",
            "                        String resourceName = getResourceTypeName(uninitializedType);",
            "                        sink->diagnose(",
            "                            sourceLoc,"
          ],
          "context_after": [
            "                            resourceName);",
            "                    }",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41024,
      "severity": "Error",
      "name": "cannotDefaultInitializeStructWithUninitializedResource",
      "message": "cannot default-initialize struct '$0' with '{}' because it contains an uninitialized $1 field",
      "line": 2679,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-detect-uninitialized-resources.cpp",
          "line": 178,
          "statement": "Diagnostics::cannotDefaultInitializeStructWithUninitializedResource, structName, resourceName);",
          "context_before": [
            "                            String resourceName = getResourceTypeName(uninitializedType);",
            "",
            "                            // Main error",
            "                            sink->diagnose(",
            "                                sourceLoc,"
          ],
          "context_after": [
            "                                structName,",
            "                                resourceName);",
            "",
            "                            // Note pointing to struct definition",
            "                            if (structType->sourceLoc.isValid())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41024,
      "severity": "Error",
      "name": "cannotDefaultInitializeStructContainingResources",
      "message": "cannot default-initialize struct '$0' with '{}' because it contains resource fields",
      "line": 2685,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-detect-uninitialized-resources.cpp",
          "line": 196,
          "statement": "Diagnostics::cannotDefaultInitializeStructContainingResources, structName);",
          "context_before": [
            "                        else",
            "                        {",
            "                            // Struct contains nested resources",
            "                            sink->diagnose(",
            "                                sourceLoc,"
          ],
          "context_after": [
            "                                structName);",
            "                        }",
            "                    }",
            "                    else",
            "                    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41011,
      "severity": "Error",
      "name": "typeDoesNotFitAnyValueSize",
      "message": "type '$0' does not fit in the size required by its conforming interface.",
      "line": 2691,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-any-value-inference.cpp",
          "line": 239,
          "statement": "sink->diagnose(implType, Diagnostics::typeDoesNotFitAnyValueSize, implType);",
          "context_before": [
            "            maxAnyValueSize = Math::Max(maxAnyValueSize, sizeAndAlignment.size);",
            "",
            "            // Diagnose if the existing any-value-size is smaller than the inferred size.",
            "            if (existingMaxSize < sizeAndAlignment.size)",
            "            {"
          ],
          "context_after": [
            "                sink->diagnoseWithoutSourceView(",
            "                    implType,",
            "                    Diagnostics::typeAndLimit,",
            "                    implType,",
            "                    sizeAndAlignment.size,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "typeAndLimit"
          ]
        }
      ]
    },
    {
      "id": 41014,
      "severity": "Error",
      "name": "typeCannotBePackedIntoAnyValue",
      "message": "type '$0' contains fields that cannot be packed into ordinary bytes for dynamic dispatch.",
      "line": 2697,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-reinterpret.cpp",
          "line": 94,
          "statement": "Slang::Diagnostics::typeCannotBePackedIntoAnyValue, fromType);",
          "context_before": [
            "        SlangInt fromTypeSize = getAnyValueSize(fromType, targetProgram->getTargetReq());",
            "        if (fromTypeSize < 0)",
            "        {",
            "            sink->diagnose(",
            "                inst->sourceLoc,"
          ],
          "context_after": [
            "                fromType);",
            "        }",
            "        SlangInt toTypeSize = getAnyValueSize(toType, targetProgram->getTargetReq());",
            "        if (toTypeSize < 0)",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-lower-reinterpret.cpp",
          "line": 102,
          "statement": "Slang::Diagnostics::typeCannotBePackedIntoAnyValue, toType);",
          "context_before": [
            "        SlangInt toTypeSize = getAnyValueSize(toType, targetProgram->getTargetReq());",
            "        if (toTypeSize < 0)",
            "        {",
            "            sink->diagnose(",
            "                inst->sourceLoc,"
          ],
          "context_after": [
            "                toType);",
            "        }",
            "        SlangInt anyValueSize = Math::Max(fromTypeSize, toTypeSize);",
            "",
            "        IRBuilder builder(module);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-lower-dynamic-dispatch-insts.cpp",
          "line": 871,
          "statement": "Slang::Diagnostics::typeCannotBePackedIntoAnyValue, type);",
          "context_before": [
            "            //",
            "            if (sink && !canTypeBeStored(type))",
            "            {",
            "                sink->diagnose(",
            "                    type->sourceLoc,"
          ],
          "context_after": [
            "                    type);",
            "            }",
            "        }",
            "",
            "        // Defaults to 0 if any type could not be sized."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41020,
      "severity": "Error",
      "name": "lossOfDerivativeDueToCallOfNonDifferentiableFunction",
      "message": "derivative cannot be propagated through call to non-$1-differentiable function `$0`, use 'no_diff' to clarify intention.",
      "line": 2702,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-differentiability.cpp",
          "line": 548,
          "statement": "Diagnostics::lossOfDerivativeDueToCallOfNonDifferentiableFunction, getResolvedInstForDecorations(call->getCallee()), requiredDiffLevel == DifferentiableLevel::Forward ? \"forward\" : \"backward\");",
          "context_before": [
            "                        if (!isNeverDiffFuncType(cast<IRFuncType>(callee->getDataType())) &&",
            "                            !shouldCallImpliesNoDiff(diffTypeContext, call))",
            "                        {",
            "                            sink->diagnose(",
            "                                inst,"
          ],
          "context_after": [
            "                                getResolvedInstForDecorations(call->getCallee()),",
            "                                requiredDiffLevel == DifferentiableLevel::Forward ? \"forward\"",
            "                                                                                  : \"backward\");",
            "                        }",
            "                    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41024,
      "severity": "Error",
      "name": "lossOfDerivativeAssigningToNonDifferentiableLocation",
      "message": "derivative is lost during assignment to non-differentiable location, use 'detach()' to clarify intention.",
      "line": 2708,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-differentiability.cpp",
          "line": 660,
          "statement": "Diagnostics::lossOfDerivativeAssigningToNonDifferentiableLocation);",
          "context_before": [
            "                    if (carryNonTrivialDiffSet.contains(storeInst->getVal()) &&",
            "                        !canAddressHoldDerivative(diffTypeContext, storeInst->getPtr()))",
            "                    {",
            "                        sink->diagnose(",
            "                            storeInst->sourceLoc,"
          ],
          "context_after": [
            "                    }",
            "                }",
            "                else if (auto callInst = as<IRCall>(inst))",
            "                {",
            "                    if (!isDifferentiableFunc(callInst->getCallee(), DifferentiableLevel::Forward))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41025,
      "severity": "Error",
      "name": "lossOfDerivativeUsingNonDifferentiableLocationAsOutArg",
      "message": "derivative is lost when passing a non-differentiable location to an `out` or `inout` parameter, consider passing a temporary variable instead.",
      "line": 2714,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 41021,
      "severity": "Error",
      "name": "differentiableFuncMustHaveOutput",
      "message": "a differentiable function must have at least one differentiable output.",
      "line": 2720,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 41022,
      "severity": "Error",
      "name": "differentiableFuncMustHaveInput",
      "message": "a differentiable function must have at least one differentiable input.",
      "line": 2725,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 41023,
      "severity": "Error",
      "name": "getStringHashMustBeOnStringLiteral",
      "message": "getStringHash can only be called when argument is statically resolvable to a string literal",
      "line": 2730,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-string-hash.cpp",
          "line": 90,
          "statement": "sink->diagnose(inst, Diagnostics::getStringHashMustBeOnStringLiteral);",
          "context_before": [
            "    {",
            "        if (inst->getStringLit() == nullptr)",
            "        {",
            "            if (sink)",
            "            {"
          ],
          "context_after": [
            "            }",
            "",
            "            // Doesn't access a string literal",
            "            return SLANG_FAIL;",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41030,
      "severity": "Warning",
      "name": "operatorShiftLeftOverflow",
      "message": "left shift amount exceeds the number of bits and the result will be always zero, (`$0` << `$1`).",
      "line": 2736,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-operator-shift-overflow.cpp",
          "line": 47,
          "statement": "Diagnostics::operatorShiftLeftOverflow, lhsType, shiftAmount);",
          "context_before": [
            "                        IRIntegerValue shiftAmount = rhsLit->getValue();",
            "                        if (sizeAlignment.size * 8 <= shiftAmount)",
            "                        {",
            "                            sink->diagnose(",
            "                                opInst,"
          ],
          "context_after": [
            "                                lhsType,",
            "                                shiftAmount);",
            "                        }",
            "                        break;",
            "                    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41901,
      "severity": "Error",
      "name": "unsupportedUseOfLValueForAutoDiff",
      "message": "unsupported use of L-value for auto differentiation.",
      "line": 2743,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-addr-inst-elimination.cpp",
          "line": 182,
          "statement": "Diagnostics::unsupportedUseOfLValueForAutoDiff);",
          "context_before": [
            "                case kIROp_GetOffsetPtr:",
            "                    break;",
            "                default:",
            "                    sink->diagnose(",
            "                        use->getUser()->sourceLoc,"
          ],
          "context_after": [
            "                    break;",
            "                }",
            "                use = nextUse;",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41902,
      "severity": "Error",
      "name": "cannotDifferentiateDynamicallyIndexedData",
      "message": "cannot auto-differentiate mixed read/write access to dynamically indexed data in '$0'.",
      "line": 2748,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 41903,
      "severity": "Error",
      "name": "unableToSizeOf",
      "message": "sizeof could not be performed for type '$0'.",
      "line": 2754,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 41904,
      "severity": "Error",
      "name": "unableToAlignOf",
      "message": "alignof could not be performed for type '$0'.",
      "line": 2755,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 42001,
      "severity": "Error",
      "name": "invalidUseOfTorchTensorTypeInDeviceFunc",
      "message": "invalid use of TorchTensor type in device/kernel functions. use `TensorView` instead.",
      "line": 2757,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-differentiability.cpp",
          "line": 317,
          "statement": "sink->diagnose(loc, Diagnostics::invalidUseOfTorchTensorTypeInDeviceFunc);",
          "context_before": [
            "                    }",
            "",
            "                    auto loc = inst->sourceLoc;",
            "                    if (!loc.isValid())",
            "                        loc = funcInst->sourceLoc;"
          ],
          "context_after": [
            "                    return;",
            "                }",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 42050,
      "severity": "Warning",
      "name": "potentialIssuesWithPreferRecomputeOnSideEffectMethod",
      "message": "$0 has [PreferRecompute] and may have side effects. side effects may execute multiple times. use [PreferRecompute(SideEffectBehavior.Allow)], or mark function with [__NoSideEffect]",
      "line": 2763,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-autodiff.cpp",
          "line": 3805,
          "statement": "Diagnostics::potentialIssuesWithPreferRecomputeOnSideEffectMethod, nameHint->getName());",
          "context_before": [
            "                // Find function name. (don't diagnose on nameless functions)",
            "                if (auto nameHint = func->findDecoration<IRNameHintDecoration>())",
            "                {",
            "                    sink->diagnose(",
            "                        func,"
          ],
          "context_after": [
            "                        nameHint->getName());",
            "                }",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 45001,
      "severity": "Error",
      "name": "unresolvedSymbol",
      "message": "unresolved external symbol '$0'.",
      "line": 2770,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1568,
          "statement": "sink->diagnose(bestVal->sourceLoc, Diagnostics::unresolvedSymbol, bestVal);",
          "context_before": [
            "    // which are not valid (extensions cannot define new requirements).",
            "    if (!isFunctionDefinedOrImported(bestVal))",
            "    {",
            "        if (auto sink = context->shared->sink)",
            "        {"
          ],
          "context_after": [
            "",
            "            // Emit notes for all available declarations of this symbol",
            "            for (IRSpecSymbol* ss = sym; ss; ss = ss->nextWithSameName)",
            "            {",
            "                sink->diagnose("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1846,
          "statement": "Diagnostics::unresolvedSymbol, globalSym);",
          "context_before": [
            "                if (auto constant = as<IRGlobalConstant>(globalSym))",
            "                {",
            "                    if (constant->getOperandCount() == 0)",
            "                        sink->diagnose(",
            "                            globalSym->sourceLoc,"
          ],
          "context_after": [
            "                            globalSym);",
            "                }",
            "                else if (auto genericSym = as<IRGeneric>(globalSym))",
            "                {",
            "                    globalSym = findGenericReturnVal(genericSym);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1860,
          "statement": "Diagnostics::unresolvedSymbol, globalSym);",
          "context_before": [
            "                {",
            "                    if (!doesFuncHaveDefinition(funcSym) &&",
            "                        !doesTargetAllowUnresolvedFuncSymbol(req))",
            "                        sink->diagnose(",
            "                            globalSym->sourceLoc,"
          ],
          "context_after": [
            "                            globalSym);",
            "                }",
            "                else if (auto witnessSym = as<IRWitnessTable>(globalSym))",
            "                {",
            "                    if (!doesWitnessTableHaveDefinition(witnessSym))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1869,
          "statement": "Diagnostics::unresolvedSymbol, witnessSym);",
          "context_before": [
            "                {",
            "                    if (!doesWitnessTableHaveDefinition(witnessSym))",
            "                    {",
            "                        sink->diagnose(",
            "                            globalSym->sourceLoc,"
          ],
          "context_after": [
            "                            witnessSym);",
            "                        if (auto concreteType = witnessSym->getConcreteType())",
            "                            sink->diagnose(",
            "                                concreteType->sourceLoc,",
            "                                Diagnostics::seeDeclarationOf,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41201,
      "severity": "Warning",
      "name": "expectDynamicUniformArgument",
      "message": "argument for '$0' might not be a dynamic uniform, use `asDynamicUniform()` to silence this warning.",
      "line": 2772,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-uniformity.cpp",
          "line": 363,
          "statement": "Diagnostics::expectDynamicUniformArgument, param);",
          "context_before": [
            "                                            auto param = getParamAt(func->getFirstBlock(), argi);",
            "                                            if (param->findDecoration<IRDynamicUniformDecoration>())",
            "                                            {",
            "                                                sink->diagnose(",
            "                                                    callInst->sourceLoc,"
          ],
          "context_after": [
            "                                                    param);",
            "                                            }",
            "                                            else",
            "                                            {",
            "                                                key.nonUniformParams.add(i);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41201,
      "severity": "Warning",
      "name": "expectDynamicUniformValue",
      "message": "value stored at this location must be dynamic uniform, use `asDynamicUniform()` to silence this warning.",
      "line": 2778,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-uniformity.cpp",
          "line": 308,
          "statement": "Diagnostics::expectDynamicUniformValue, ptr);",
          "context_before": [
            "                                addToWorkList(ptr);",
            "                                if (isDynamicUniformLocation(ptr))",
            "                                {",
            "                                    sink->diagnose(",
            "                                        user->sourceLoc,"
          ],
          "context_after": [
            "                                        ptr);",
            "                                }",
            "                                else",
            "                                {",
            "                                    // Conservatively treat the entire composite at root addr as"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41202,
      "severity": "Error",
      "name": "notEqualBitCastSize",
      "message": "invalid to bit_cast differently sized types: '$0' with size '$1' casted into '$2' with size '$3'",
      "line": 2786,
      "param_count": 4,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-bit-cast.cpp",
          "line": 265,
          "statement": "Diagnostics::notEqualBitCastSize, fromType, fromTypeSize.size, toType, toTypeSize.size);",
          "context_before": [
            "        if (fromBasicType && toBasicType)",
            "        {",
            "            if (fromTypeSize.size != toTypeSize.size)",
            "                sink->diagnose(",
            "                    inst->sourceLoc,"
          ],
          "context_after": [
            "                    fromType,",
            "                    fromTypeSize.size,",
            "                    toType,",
            "                    toTypeSize.size);",
            "            // Both fromType and toType are basic types, no processing needed."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-lower-bit-cast.cpp",
          "line": 373,
          "statement": "Diagnostics::notEqualBitCastSize, fromType, fromTypeSize.size, toType, toTypeSize.size);",
          "context_before": [
            "        }",
            "",
            "        if (fromTypeSize.size != toTypeSize.size)",
            "            sink->diagnose(",
            "                inst->sourceLoc,"
          ],
          "context_after": [
            "                fromType,",
            "                fromTypeSize.size,",
            "                toType,",
            "                toTypeSize.size);",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41300,
      "severity": "Error",
      "name": "byteAddressBufferUnaligned",
      "message": "invalid alignment `$0` specified for the byte address buffer resource with the element size of `$1`",
      "line": 2793,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-byte-address-legalize.cpp",
          "line": 270,
          "statement": "Slang::Diagnostics::byteAddressBufferUnaligned, alignInst->getValue(), alignmentVal);",
          "context_before": [
            "            {",
            "                return true;",
            "            }",
            "            m_sink->diagnose(",
            "                offset->sourceLoc,"
          ],
          "context_after": [
            "                alignInst->getValue(),",
            "                alignmentVal);",
            "        }",
            "        return false;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41400,
      "severity": "Error",
      "name": "staticAssertionFailure",
      "message": "static assertion failed, $0",
      "line": 2800,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 502,
          "statement": "Diagnostics::staticAssertionFailure, msgLit->getStringSlice());",
          "context_before": [
            "                    IRInst* msg = inst->getOperand(1);",
            "                    if (auto msgLit = as<IRStringLit>(msg))",
            "                    {",
            "                        sink->diagnose(",
            "                            inst,"
          ],
          "context_after": [
            "                            msgLit->getStringSlice());",
            "                    }",
            "                    else",
            "                    {",
            "                        sink->diagnose(inst, Diagnostics::staticAssertionFailureWithoutMessage);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41401,
      "severity": "Error",
      "name": "staticAssertionFailureWithoutMessage",
      "message": "static assertion failed.",
      "line": 2801,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 507,
          "statement": "sink->diagnose(inst, Diagnostics::staticAssertionFailureWithoutMessage);",
          "context_before": [
            "                            Diagnostics::staticAssertionFailure,",
            "                            msgLit->getStringSlice());",
            "                    }",
            "                    else",
            "                    {"
          ],
          "context_after": [
            "                    }",
            "                    diagnoseCallStack(inst, sink);",
            "                }",
            "            }",
            "            else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41402,
      "severity": "Error",
      "name": "staticAssertionConditionNotConstant",
      "message": "condition for static assertion cannot be evaluated at compile time.",
      "line": 2802,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 514,
          "statement": "sink->diagnose(condi, Diagnostics::staticAssertionConditionNotConstant);",
          "context_before": [
            "                    diagnoseCallStack(inst, sink);",
            "                }",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "",
            "            return true;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41402,
      "severity": "Error",
      "name": "multiSampledTextureDoesNotAllowWrites",
      "message": "cannot write to a multisampled texture with target '$0'.",
      "line": 2808,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-image-subscript.cpp",
          "line": 41,
          "statement": "Diagnostics::multiSampledTextureDoesNotAllowWrites, target->getTarget());",
          "context_before": [
            "    bool seperateSampleCoord = (textureType->isMultisample()); // seperate sample param",
            "",
            "    if (seperateSampleCoord && isMetalTarget(target))",
            "        sink->diagnose(",
            "            imageSubscript->getImage(),"
          ],
          "context_after": [
            "            target->getTarget());",
            "",
            "    IRType* indexingType = builder.getIntType();",
            "    if (isMetalTarget(target))",
            "        indexingType = builder.getUIntType();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41403,
      "severity": "Error",
      "name": "invalidAtomicDestinationPointer",
      "message": "cannot perform atomic operation because destination is neither groupshared nor from a device buffer.",
      "line": 2814,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-validate.cpp",
          "line": 535,
          "statement": "sink->diagnose(inst->sourceLoc, Diagnostics::invalidAtomicDestinationPointer);",
          "context_before": [
            "    case kIROp_AtomicInc:",
            "    case kIROp_AtomicDec:",
            "        {",
            "            IRInst* destinationPtr = inst->getOperand(0);",
            "            if (!isValidAtomicDest(skipFuncParamValidation, destinationPtr))"
          ],
          "context_after": [
            "        }",
            "        break;",
            "",
            "    default:",
            "        break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 41404,
      "severity": "Error",
      "name": "cannotWriteToReadOnlyPointer",
      "message": "cannot write to a read-only pointer",
      "line": 2821,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50010,
      "severity": "Internal",
      "name": "missingExistentialBindingsForParameter",
      "message": "missing argument for existential parameter slot",
      "line": 2827,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-bind-existentials.cpp",
          "line": 231,
          "statement": "sink->diagnose(param->sourceLoc, Diagnostics::missingExistentialBindingsForParameter);",
          "context_before": [
            "        {",
            "            // Note: This error is considered an internal error because",
            "            // we should be detecting and diagnosing this problem before",
            "            // we make it to back-end code generation.",
            "            //"
          ],
          "context_after": [
            "            return;",
            "        }",
            "",
            "        // Each existential slot corresponds to *two* arguments",
            "        // on the binding instruction: one for the type, and"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-bind-existentials.cpp",
          "line": 246,
          "statement": "sink->diagnose(param->sourceLoc, Diagnostics::missingExistentialBindingsForParameter);",
          "context_before": [
            "        //",
            "        UInt bindOperandCount = bindSlotsInst->getOperandCount();",
            "        UInt slotOperandCount = 2 * slotCount;",
            "        if ((ioSlotOperandOffset + slotOperandCount) > bindOperandCount)",
            "        {"
          ],
          "context_after": [
            "            return;",
            "        }",
            "        //",
            "        // If there are enough operands, then we will offset to",
            "        // get to the starting point for the current parameter,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50011,
      "severity": "Warning",
      "name": "spirvVersionNotSupported",
      "message": "Slang's SPIR-V backend only supports SPIR-V version 1.3 and later. Use `-emit-spirv-via-glsl` option to produce SPIR-V 1.0 through 1.2.",
      "line": 2832,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-spirv-legalize.cpp",
          "line": 2014,
          "statement": "m_sharedContext->m_sink->diagnose(SourceLoc(), Diagnostics::spirvVersionNotSupported);",
          "context_before": [
            "",
            "        if (m_sharedContext->m_spvVersion < 0x10300)",
            "        {",
            "            // Direct SPIRV backend does not support generating SPIRV before 1.3,",
            "            // we will issue an error message here."
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    struct SpirvAddressSpaceAssigner : InitialAddressSpaceAssigner",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidTessCoordType",
      "message": "TessCoord must have vec2 or vec3 type.",
      "line": 2838,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidFragCoordType",
      "message": "FragCoord must be a vec4.",
      "line": 2839,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidInvocationIdType",
      "message": "InvocationId must have int type.",
      "line": 2840,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidThreadIdType",
      "message": "ThreadId must have int type.",
      "line": 2841,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidPrimitiveIdType",
      "message": "PrimitiveId must have int type.",
      "line": 2842,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50020,
      "severity": "Error",
      "name": "invalidPatchVertexCountType",
      "message": "PatchVertexCount must have int type.",
      "line": 2843,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50022,
      "severity": "Error",
      "name": "worldIsNotDefined",
      "message": "world '$0' is not defined.",
      "line": 2844,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 50023,
      "severity": "Error",
      "name": "stageShouldProvideWorldAttribute",
      "message": "'$0' should provide 'World' attribute.",
      "line": 2845,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 50040,
      "severity": "Error",
      "name": "componentHasInvalidTypeForPositionOutput",
      "message": "'$0': component used as 'loc' output must be of vec4 type.",
      "line": 2846,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 50041,
      "severity": "Error",
      "name": "componentNotDefined",
      "message": "'$0': component not defined.",
      "line": 2851,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "domainShaderRequiresControlPointCount",
      "message": "'DomainShader' requires attribute 'ControlPointCount'.",
      "line": 2853,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresControlPointCount",
      "message": "'HullShader' requires attribute 'ControlPointCount'.",
      "line": 2858,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresControlPointWorld",
      "message": "'HullShader' requires attribute 'ControlPointWorld'.",
      "line": 2863,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresCornerPointWorld",
      "message": "'HullShader' requires attribute 'CornerPointWorld'.",
      "line": 2868,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresDomain",
      "message": "'HullShader' requires attribute 'Domain'.",
      "line": 2873,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresInputControlPointCount",
      "message": "'HullShader' requires attribute 'InputControlPointCount'.",
      "line": 2874,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresOutputTopology",
      "message": "'HullShader' requires attribute 'OutputTopology'.",
      "line": 2879,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresPartitioning",
      "message": "'HullShader' requires attribute 'Partitioning'.",
      "line": 2884,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresPatchWorld",
      "message": "'HullShader' requires attribute 'PatchWorld'.",
      "line": 2889,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresTessLevelInner",
      "message": "'HullShader' requires attribute 'TessLevelInner'.",
      "line": 2894,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50052,
      "severity": "Error",
      "name": "hullShaderRequiresTessLevelOuter",
      "message": "'HullShader' requires attribute 'TessLevelOuter'.",
      "line": 2899,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50053,
      "severity": "Error",
      "name": "invalidTessellationDomian",
      "message": "'Domain' should be either 'triangles' or 'quads'.",
      "line": 2905,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50053,
      "severity": "Error",
      "name": "invalidTessellationOutputTopology",
      "message": "'OutputTopology' must be one of: 'point', 'line', 'triangle_cw', or 'triangle_ccw'.",
      "line": 2910,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50053,
      "severity": "Error",
      "name": "invalidTessellationPartitioning",
      "message": "'Partitioning' must be one of: 'integer', 'pow2', 'fractional_even', or 'fractional_odd'.",
      "line": 2915,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50053,
      "severity": "Error",
      "name": "invalidTessellationDomain",
      "message": "'Domain' should be either 'triangles' or 'quads'.",
      "line": 2920,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 50060,
      "severity": "Error",
      "name": "invalidMeshStageOutputTopology",
      "message": "Invalid mesh stage output topology '$0' for target '$1', must be one of: $2",
      "line": 2926,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-entry-point-decorations.cpp",
          "line": 87,
          "statement": "Diagnostics::invalidMeshStageOutputTopology, decoration->getTopology()->getStringSlice(), TypeTextUtil::getCompileTargetName(SlangCompileTarget(m_target)), validTopologies);",
          "context_before": [
            "        IROutputTopologyDecoration* decoration,",
            "        String validTopologies)",
            "    {",
            "        m_sink->diagnose(",
            "            decoration,"
          ],
          "context_after": [
            "            decoration->getTopology()->getStringSlice(),",
            "            TypeTextUtil::getCompileTargetName(SlangCompileTarget(m_target)),",
            "            validTopologies);",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50082,
      "severity": "Error",
      "name": "importingFromPackedBufferUnsupported",
      "message": "importing type '$0' from PackedBuffer is not supported by the GLSL backend.",
      "line": 2932,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 51090,
      "severity": "Error",
      "name": "cannotGenerateCodeForExternComponentType",
      "message": "cannot generate code for extern component type '$0'.",
      "line": 2937,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 51091,
      "severity": "Error",
      "name": "typeCannotBePlacedInATexture",
      "message": "type '$0' cannot be placed in a texture.",
      "line": 2942,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 51092,
      "severity": "Error",
      "name": "stageDoesntHaveInputWorld",
      "message": "'$0' doesn't appear to have any input world",
      "line": 2943,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 50100,
      "severity": "Error",
      "name": "noTypeConformancesFoundForInterface",
      "message": "No type conformances are found for interface '$0'. Code generation for current target requires at least one implementation type present in the linkage.",
      "line": 2945,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-typeflow-specialize.cpp",
          "line": 1521,
          "statement": "Diagnostics::noTypeConformancesFoundForInterface, interfaceType);",
          "context_before": [
            "            }",
            "            else",
            "            {",
            "                sink->diagnose(",
            "                    inst,"
          ],
          "context_after": [
            "                    interfaceType);",
            "                module->getContainerPool().free(&tables);",
            "                return none();",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-typeflow-specialize.cpp",
          "line": 1767,
          "statement": "Diagnostics::noTypeConformancesFoundForInterface, interfaceType);",
          "context_before": [
            "                        }",
            "                        else",
            "                        {",
            "                            sink->diagnose(",
            "                                loadInst,"
          ],
          "context_after": [
            "                                interfaceType);",
            "                            module->getContainerPool().free(&tables);",
            "                            return none();",
            "                        }",
            "                    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50101,
      "severity": "Error",
      "name": "dynamicDispatchOnPotentiallyUninitializedExistential",
      "message": "Cannot dynamically dispatch on potentially uninitialized interface object '$0'.",
      "line": 2951,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-typeflow-specialize.cpp",
          "line": 2526,
          "statement": "Diagnostics::dynamicDispatchOnPotentiallyUninitializedExistential, uninitElement->getOperand(0));",
          "context_before": [
            "            auto tableSet = taggedUnion->getWitnessTableSet();",
            "            if (auto uninitElement = tableSet->tryGetUninitializedElement())",
            "            {",
            "                sink->diagnose(",
            "                    inst->sourceLoc,"
          ],
          "context_after": [
            "                    uninitElement->getOperand(0));",
            "",
            "                return none(); // We'll return none so that the analysis doesn't",
            "                               // crash early, before we can detect the error count",
            "                               // and exit gracefully."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52000,
      "severity": "Error",
      "name": "multiLevelBreakUnsupported",
      "message": "control flow appears to require multi-level `break`, which Slang does not yet support",
      "line": 2968,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-restructure.cpp",
          "line": 267,
          "statement": "ctx->getSink()->diagnose(block, Diagnostics::multiLevelBreakUnsupported);",
          "context_before": [
            "            // because if it *isn't* we currently can't generate code.",
            "            //",
            "            if (block != registeredBlock[(int)ll->op])",
            "            {",
            "                if (ctx->getSink())"
          ],
          "context_after": [
            "            }",
            "",
            "            // Now we need to create a structured `break` or `continue` operation",
            "            // to match the operation associated with the target.",
            "            //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52001,
      "severity": "Warning",
      "name": "dxilNotFound",
      "message": "dxil shared library not found, so 'dxc' output cannot be signed! Shader code will not be runnable in non-development environments.",
      "line": 2974,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check.cpp",
          "line": 32,
          "statement": "m_sink->diagnose(SourceLoc(), Diagnostics::dxilNotFound);",
          "context_before": [
            "        if (SLANG_FAILED(res) && m_sink)",
            "        {",
            "            String filename = Path::getFileNameWithoutExt(path);",
            "            if (filename == \"dxil\")",
            "            {"
          ],
          "context_after": [
            "            }",
            "            else",
            "            {",
            "                m_sink->diagnose(SourceLoc(), Diagnostics::noteFailedToLoadDynamicLibrary, path);",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52002,
      "severity": "Error",
      "name": "passThroughCompilerNotFound",
      "message": "could not find a suitable pass-through compiler for '$0'.",
      "line": 2981,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-artifact-output-util.cpp",
          "line": 65,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::passThroughCompilerNotFound, compilerName);",
          "context_before": [
            "    {",
            "        if (sink)",
            "        {",
            "            auto compilerName =",
            "                TypeTextUtil::getPassThroughAsHumanText((SlangPassThrough)downstreamCompiler);"
          ],
          "context_after": [
            "        }",
            "        return SLANG_FAIL;",
            "    }",
            "    auto downstreamStartTime = std::chrono::high_resolution_clock::now();",
            "    SLANG_RETURN_ON_FAIL(compiler->convert(artifact, assemblyDesc, outArtifact));"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-code-gen.cpp",
          "line": 403,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::passThroughCompilerNotFound, compilerName);",
          "context_before": [
            "    // Get the required downstream compiler",
            "    IDownstreamCompiler* compiler = session->getOrLoadDownstreamCompiler(compilerType, sink);",
            "    if (!compiler)",
            "    {",
            "        auto compilerName = TypeTextUtil::getPassThroughAsHumanText((SlangPassThrough)compilerType);"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    Dictionary<String, String> preprocessorDefinitions;",
            "    List<String> includePaths;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52003,
      "severity": "Error",
      "name": "cannotDisassemble",
      "message": "cannot disassemble '$0'.",
      "line": 2986,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-options.cpp",
          "line": 3261,
          "statement": "m_sink->diagnose(arg.loc, Diagnostics::cannotDisassemble, fileName.value);",
          "context_before": [
            "                if (module)",
            "                {",
            "                    ComPtr<slang::IBlob> disassemblyBlob;",
            "                    if (SLANG_FAILED(module->disassemble(disassemblyBlob.writeRef())))",
            "                    {"
          ],
          "context_after": [
            "                        return SLANG_FAIL;",
            "                    }",
            "                    else",
            "                    {",
            "                        // success, print out the disassembly in a way that slang-test can read"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-artifact-output-util.cpp",
          "line": 37,
          "statement": "Diagnostics::cannotDisassemble, ArtifactDescUtil::getText(desc));",
          "context_before": [
            "    {",
            "        if (sink)",
            "        {",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                ArtifactDescUtil::getText(desc));",
            "        }",
            "        return SLANG_FAIL;",
            "    }",
            "    // Get the downstream disassembler that can be used for this target"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52004,
      "severity": "Error",
      "name": "unableToWriteFile",
      "message": "unable to write file '$0'",
      "line": 2988,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1594,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::unableToWriteFile, reflectionPath);",
          "context_before": [
            "            auto builder = bufferWriter.getBuilder();",
            "            StdWriters::getOut().write(builder.getBuffer(), builder.getLength());",
            "        }",
            "        else if (SLANG_FAILED(File::writeAllText(reflectionPath, bufferWriter.getBuilder())))",
            "        {"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    return res;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52005,
      "severity": "Error",
      "name": "unableToReadFile",
      "message": "unable to read file '$0'",
      "line": 2989,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-global-session.cpp",
          "line": 856,
          "statement": "sink.diagnose(SourceLoc{}, Diagnostics::unableToReadFile, path.stringValue);",
          "context_before": [
            "                SourceLoc{},",
            "                &sink,",
            "                artifact.writeRef());",
            "            if (SLANG_FAILED(result))",
            "            {"
          ],
          "context_after": [
            "                return result;",
            "            }",
            "            linkage->m_libModules.add(artifact);",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-global-session.cpp",
          "line": 1073,
          "statement": "sink.diagnose(SourceLoc{}, Diagnostics::unableToReadFile, jsonPath);",
          "context_before": [
            "",
            "        String contents;",
            "        const auto readRes = File::readAllText(jsonPath, contents);",
            "        if (SLANG_FAILED(readRes))",
            "        {"
          ],
          "context_after": [
            "            return readRes;",
            "        }",
            "        const auto pathInfo = PathInfo::makeFromString(jsonPath);",
            "        const auto sourceFile = sourceManager->createSourceFileWithString(pathInfo, contents);",
            "        const auto sourceView = sourceManager->createSourceView(sourceFile, nullptr, SourceLoc());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2033,
          "statement": "m_sink->diagnose(reproName.loc, Diagnostics::unableToReadFile, reproName.value);",
          "context_before": [
            "    List<uint8_t> buffer;",
            "    {",
            "        const Result res = ReproUtil::loadState(reproName.value, m_sink, buffer);",
            "        if (SLANG_FAILED(res))",
            "        {"
          ],
          "context_after": [
            "            return res;",
            "        }",
            "    }",
            "",
            "    auto requestState = ReproUtil::getRequest(buffer);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-options.cpp",
          "line": 2151,
          "statement": "m_sink->diagnose(reproName.loc, Diagnostics::unableToReadFile, reproName.value);",
          "context_before": [
            "    CommandLineArg reproName;",
            "    SLANG_RETURN_ON_FAIL(m_reader.expectArg(reproName));",
            "",
            "    if (SLANG_FAILED(_loadRepro(reproName.value, m_sink, m_requestImpl)))",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    m_hasLoadedRepro = true;",
            "    return SLANG_OK;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52006,
      "severity": "Error",
      "name": "compilerNotDefinedForTransition",
      "message": "compiler not defined for transition '$0' to '$1'.",
      "line": 2991,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-code-gen.cpp",
          "line": 389,
          "statement": "Diagnostics::compilerNotDefinedForTransition, sourceName, targetName);",
          "context_before": [
            "            auto sourceName = TypeTextUtil::getCompileTargetName(SlangCompileTarget(sourceTarget));",
            "            auto targetName = TypeTextUtil::getCompileTargetName(SlangCompileTarget(target));",
            "",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                sourceName,",
            "                targetName);",
            "            return SLANG_FAIL;",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 52007,
      "severity": "Error",
      "name": "typeCannotBeUsedInDynamicDispatch",
      "message": "failed to generate dynamic dispatch code for type '$0'.",
      "line": 2997,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 52008,
      "severity": "Error",
      "name": "dynamicDispatchOnSpecializeOnlyInterface",
      "message": "type '$0' is marked for specialization only, but dynamic dispatch is needed for the call.",
      "line": 3002,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 52009,
      "severity": "Error",
      "name": "cannotEmitReflectionWithoutTarget",
      "message": "cannot emit reflection JSON; no compilation target available",
      "line": 3007,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1582,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::cannotEmitReflectionWithoutTarget);",
          "context_before": [
            "    if (reflectionPath.getLength() != 0)",
            "    {",
            "        auto reflection = this->getReflection();",
            "        if (!reflection)",
            "        {"
          ],
          "context_after": [
            "            return SLANG_FAIL;",
            "        }",
            "        auto bufferWriter = PrettyWriter();",
            "        emitReflectionJSON(this, reflection, bufferWriter);",
            "        if (reflectionPath == \"-\")"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 53001,
      "severity": "Error",
      "name": "invalidTypeMarshallingForImportedDLLSymbol",
      "message": "invalid type marshalling in imported func $0.",
      "line": 3012,
      "param_count": 1,
      "call_sites": []
    },
    {
      "id": 54001,
      "severity": "Warning",
      "name": "meshOutputMustBeOut",
      "message": "Mesh shader outputs must be declared with 'out'.",
      "line": 3018,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9696,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::meshOutputMustBeOut);",
          "context_before": [
            "    }",
            "    // HLSL requires an 'out' modifier here, but since we don't operate",
            "    // under such strict compatability we can just not warn here.",
            "    if (!varDecl->findModifier<OutModifier>() && modifier)",
            "    {"
          ],
          "context_after": [
            "    }",
            "",
            "    //",
            "    // If necessary, convert to our typed representation",
            "    //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 54002,
      "severity": "Error",
      "name": "meshOutputMustBeArray",
      "message": "HLSL style mesh shader outputs must be arrays",
      "line": 3019,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9715,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::meshOutputMustBeArray);",
          "context_before": [
            "        return;",
            "    }",
            "    auto indexExpr = as<IndexExpr>(varDecl->type.exp);",
            "    if (!indexExpr)",
            "    {"
          ],
          "context_after": [
            "        varDecl->type.type = m_astBuilder->getErrorType();",
            "        return;",
            "    }",
            "    if (indexExpr->indexExprs.getCount() != 1)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 54003,
      "severity": "Error",
      "name": "meshOutputArrayMustHaveSize",
      "message": "HLSL style mesh shader output arrays must have a length specified",
      "line": 3020,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9721,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::meshOutputArrayMustHaveSize);",
          "context_before": [
            "        varDecl->type.type = m_astBuilder->getErrorType();",
            "        return;",
            "    }",
            "    if (indexExpr->indexExprs.getCount() != 1)",
            "    {"
          ],
          "context_after": [
            "        varDecl->type.type = m_astBuilder->getErrorType();",
            "        return;",
            "    }",
            "    auto base = ExpectAType(indexExpr->baseExpression);",
            "    auto index = CheckIntegerConstantExpression("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 54004,
      "severity": "Warning",
      "name": "unnecessaryHLSLMeshOutputModifier",
      "message": "Unnecessary HLSL style mesh shader output modifier",
      "line": 3025,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9708,
          "statement": "getSink()->diagnose(modifier, Diagnostics::unnecessaryHLSLMeshOutputModifier);",
          "context_before": [
            "    {",
            "        return;",
            "    }",
            "    if (meshOutputType)",
            "    {"
          ],
          "context_after": [
            "        varDecl->type.type = m_astBuilder->getErrorType();",
            "        return;",
            "    }",
            "    auto indexExpr = as<IndexExpr>(varDecl->type.exp);",
            "    if (!indexExpr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55101,
      "severity": "Error",
      "name": "invalidTorchKernelReturnType",
      "message": "'$0' is not a valid return type for a pytorch kernel function.",
      "line": 3031,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-pytorch-cpp-binding.cpp",
          "line": 381,
          "statement": "Diagnostics::invalidTorchKernelReturnType, func->getResultType());",
          "context_before": [
            "    auto hostReturnType = translateToTupleType(builder, func->getResultType());",
            "    if (!hostReturnType)",
            "    {",
            "        sink->diagnose(",
            "            func->sourceLoc,"
          ],
          "context_after": [
            "            func->getResultType());",
            "        return;",
            "    }",
            "    List<IRType*> hostParamTypes;",
            "    auto funcType = as<IRFuncType>(func->getDataType());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55102,
      "severity": "Error",
      "name": "invalidTorchKernelParamType",
      "message": "'$0' is not a valid parameter type for a pytorch kernel function.",
      "line": 3036,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-pytorch-cpp-binding.cpp",
          "line": 410,
          "statement": "sink->diagnose(param->sourceLoc, Diagnostics::invalidTorchKernelParamType, paramType);",
          "context_before": [
            "    {",
            "        auto paramType = param->getFullType();",
            "        auto newParamType = translateToTupleType(builder, paramType);",
            "        if (!newParamType)",
            "        {"
          ],
          "context_after": [
            "            return;",
            "        }",
            "        auto newParam = builder.emitParam(newParamType);",
            "        param->transferDecorationsTo(newParam);",
            "        newParams.add(newParam);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55200,
      "severity": "Error",
      "name": "unsupportedBuiltinType",
      "message": "'$0' is not a supported builtin type for the target.",
      "line": 3042,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-unsupported-inst.cpp",
          "line": 40,
          "statement": "Diagnostics::unsupportedBuiltinType, globalInst);",
          "context_before": [
            "                if (!as<IRBasicType>(globalInst->getOperand(0)) &&",
            "                    !as<IRPackedFloatType>(globalInst->getOperand(0)))",
            "                {",
            "                    sink->diagnose(",
            "                        findFirstUseLoc(globalInst),"
          ],
          "context_after": [
            "                        globalInst);",
            "                }",
            "                break;",
            "            }",
            "        case kIROp_Func:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55201,
      "severity": "Error",
      "name": "unsupportedRecursion",
      "message": "recursion detected in call to '$0', but the current code generation target does not allow recursion.",
      "line": 3047,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-recursion.cpp",
          "line": 85,
          "statement": "sink->diagnose(callInst, Diagnostics::unsupportedRecursion, callee);",
          "context_before": [
            "            auto callee = as<IRFunc>(callInst->getCallee());",
            "            if (!callee)",
            "                continue;",
            "            if (!callStack.add(callee))",
            "            {"
          ],
          "context_after": [
            "                return false;",
            "            }",
            "            if (checkedFuncs.add(callee))",
            "                checkFunctionRecursionImpl(checkedFuncs, callStack, callee, sink);",
            "            callStack.remove(callee);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55202,
      "severity": "Error",
      "name": "systemValueAttributeNotSupported",
      "message": "system value semantic '$0' is not supported for the current target.",
      "line": 3053,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 2969,
          "statement": "Diagnostics::systemValueAttributeNotSupported, semanticName);",
          "context_before": [
            "",
            "    void reportUnsupportedSystemAttribute(IRInst* param, String semanticName)",
            "    {",
            "        m_sink->diagnose(",
            "            param->sourceLoc,"
          ],
          "context_after": [
            "            semanticName);",
            "    }",
            "",
            "    template<LayoutResourceKind K>",
            "    void ensureStructHasUserSemantic(IRStructType* structType, IRVarLayout* varLayout)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55203,
      "severity": "Error",
      "name": "systemValueTypeIncompatible",
      "message": "system value semantic '$0' should have type '$1' or be convertible to type '$1'.",
      "line": 3058,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 2544,
          "statement": "Diagnostics::systemValueTypeIncompatible, semanticName, typeNameSB.produceString());",
          "context_before": [
            "                {",
            "                    StringBuilder typeNameSB;",
            "                    getTypeNameHint(typeNameSB, permittedType);",
            "                    m_sink->diagnose(",
            "                        var->sourceLoc,"
          ],
          "context_after": [
            "                        semanticName,",
            "                        typeNameSB.produceString());",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55204,
      "severity": "Error",
      "name": "unsupportedTargetIntrinsic",
      "message": "intrinsic operation '$0' is not supported for the current target.",
      "line": 3063,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-hlsl.cpp",
          "line": 601,
          "statement": "Diagnostics::unsupportedTargetIntrinsic, \"floating point atomic operation\");",
          "context_before": [
            "{",
            "    auto diagnoseFloatAtommic = [&]()",
            "    {",
            "        getSink()->diagnose(",
            "            inst,"
          ],
          "context_after": [
            "            \"floating point atomic operation\");",
            "    };",
            "    switch (inst->getOp())",
            "    {",
            "    case kIROp_AtomicLoad:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-metal.cpp",
          "line": 340,
          "statement": "Diagnostics::unsupportedTargetIntrinsic, \"atomic operation on non-scalar texture\");",
          "context_before": [
            "    {",
            "        if (as<IRVectorType>(textureType->getElementType()))",
            "        {",
            "            getSink()->diagnose(",
            "                inst,"
          ],
          "context_after": [
            "                \"atomic operation on non-scalar texture\");",
            "        }",
            "    }",
            "    bool isArray = resourceType && getIntVal(resourceType->getIsArrayInst()) != 0;",
            "    if (isArray)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-metal.cpp",
          "line": 364,
          "statement": "Diagnostics::unsupportedTargetIntrinsic, \"invalid image coordinate for atomic operation\");",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                inst,"
          ],
          "context_after": [
            "                \"invalid image coordinate for atomic operation\");",
            "        }",
            "    }",
            "    else",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-metal.cpp",
          "line": 444,
          "statement": "Diagnostics::unsupportedTargetIntrinsic, \"Unsupported floating point atomic operation\");",
          "context_before": [
            "    };",
            "    auto diagnoseFloatAtomic = [&]()",
            "    {",
            "        getSink()->diagnose(",
            "            inst,"
          ],
          "context_after": [
            "            \"Unsupported floating point atomic operation\");",
            "    };",
            "    switch (inst->getOp())",
            "    {",
            "    case kIROp_Discard:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 55205,
      "severity": "Error",
      "name": "unsupportedSpecializationConstantForNumThreads",
      "message": "Specialization constants are not supported in the 'numthreads' attribute for the current target.",
      "line": 3068,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 2231,
          "statement": "Diagnostics::unsupportedSpecializationConstantForNumThreads);",
          "context_before": [
            "",
            "        if (!groupExtents)",
            "        {",
            "            m_sink->diagnose(",
            "                m_entryPointFunc,"
          ],
          "context_after": [
            "",
            "            // Fill in placeholder values.",
            "            static const int kAxisCount = 3;",
            "            IRInst* groupExtentAlongAxis[kAxisCount] = {};",
            "            for (int axis = 0; axis < kAxisCount; axis++)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 4210,
          "statement": "Diagnostics::unsupportedSpecializationConstantForNumThreads);",
          "context_before": [
            "                emitCalcGroupExtents(svBuilder, entryPoint.entryPointFunc, uint3Type);",
            "            if (!computeExtent)",
            "            {",
            "                m_sink->diagnose(",
            "                    entryPoint.entryPointFunc,"
          ],
          "context_after": [
            "",
            "                // Fill in placeholder values.",
            "                static const int kAxisCount = 3;",
            "                IRInst* groupExtentAlongAxis[kAxisCount] = {};",
            "                for (int axis = 0; axis < kAxisCount; axis++)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-c-like.cpp",
          "line": 306,
          "statement": "getSink()->diagnose(decor, Diagnostics::unsupportedSpecializationConstantForNumThreads);",
          "context_before": [
            "",
            "    for (auto id : specializationConstantIds)",
            "    {",
            "        if (id >= 0)",
            "        {"
          ],
          "context_after": [
            "            break;",
            "        }",
            "    }",
            "    return decor;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56001,
      "severity": "Error",
      "name": "unableToAutoMapCUDATypeToHostType",
      "message": "Could not automatically map '$0' to a host type. Automatic binding generation failed for '$1'",
      "line": 3074,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-pytorch-cpp-binding.cpp",
          "line": 536,
          "statement": "sink->diagnose(type->sourceLoc, Diagnostics::unableToAutoMapCUDATypeToHostType, type, func);",
          "context_before": [
            "    default:",
            "        break;",
            "    }",
            "",
            "    if (sink)"
          ],
          "context_after": [
            "    return nullptr;",
            "}",
            "",
            "// Propagates name hints through field extracts.",
            "IRInst* propagateNameHint(IRBuilder* builder, IRFieldExtract* inst)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56002,
      "severity": "Error",
      "name": "attemptToQuerySizeOfUnsizedArray",
      "message": "cannot obtain the size of an unsized array.",
      "line": 3079,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-unsupported-inst.cpp",
          "line": 19,
          "statement": "sink->diagnose(inst, Diagnostics::attemptToQuerySizeOfUnsizedArray);",
          "context_before": [
            "        for (auto inst : block->getChildren())",
            "        {",
            "            switch (inst->getOp())",
            "            {",
            "            case kIROp_GetArrayLength:"
          ],
          "context_after": [
            "                break;",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56003,
      "severity": "Fatal",
      "name": "useOfUninitializedOpaqueHandle",
      "message": "use of uninitialized opaque handle '$0'.",
      "line": 3085,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-types.cpp",
          "line": 1978,
          "statement": "context->m_sink->diagnose(loc, Diagnostics::useOfUninitializedOpaqueHandle, opaqueType);",
          "context_before": [
            "        SourceLoc loc = findBestSourceLocFromUses(inst);",
            "",
            "        if (!loc.isValid())",
            "            loc = getDiagnosticPos(opaqueType);",
            ""
          ],
          "context_after": [
            "    }",
            "",
            "    // It is not ideal, but this pass legalizes an undefined value to... nothing.",
            "    //",
            "    // As a result, in any context that tries to consume a `LegalVal` based on its type,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56100,
      "severity": "Error",
      "name": "constantBufferInParameterBlockNotAllowedOnMetal",
      "message": "nested 'ConstantBuffer' inside a 'ParameterBlock' is not supported on Metal, use 'ParameterBlock' instead.",
      "line": 3088,
      "param_count": 0,
      "call_sites": []
    },
    {
      "id": 56101,
      "severity": "Error",
      "name": "resourceTypesInConstantBufferInParameterBlockNotAllowedOnMetal",
      "message": "nesting a 'ConstantBuffer' containing resource types inside a 'ParameterBlock' is not supported on Metal, please use 'ParameterBlock' instead.",
      "line": 3094,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-check-shader-parameter-type.cpp",
          "line": 90,
          "statement": "Diagnostics::resourceTypesInConstantBufferInParameterBlockNotAllowedOnMetal);",
          "context_before": [
            "            }",
            "",
            "            if (!foundUseSite)",
            "                sink->diagnose(",
            "                    inst,"
          ],
          "context_after": [
            "        }",
            "    }",
            "}",
            "void checkForInvalidShaderParameterType(",
            "    IRModule* module,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56102,
      "severity": "Error",
      "name": "divisionByMatrixNotSupported",
      "message": "division by matrix is not supported for Metal and WGSL targets.",
      "line": 3100,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-binary-operator.cpp",
          "line": 99,
          "statement": "sink->diagnose(inst, Diagnostics::divisionByMatrixNotSupported);",
          "context_before": [
            "    builder.setInsertBefore(inst);",
            "",
            "    // Division by matrix is not supported on Metal and WGSL.",
            "    if (isDivisionByMatrix(inst))",
            "    {"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    // For shifts, ensure that the shift amount is unsigned, as required by",
            "    // https://www.w3.org/TR/WGSL/#bit-expr."
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56103,
      "severity": "Error",
      "name": "int16NotSupportedInWGSL",
      "message": "16-bit integer type '$0' is not supported by the WGSL backend.",
      "line": 3105,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-wgsl.cpp",
          "line": 525,
          "statement": "diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"int16_t\");",
          "context_before": [
            "        {",
            "            m_writer->emit(getDefaultBuiltinTypeName(type->getOp()));",
            "            return;",
            "        }",
            "    case kIROp_Int16Type:"
          ],
          "context_after": [
            "        return;",
            "    case kIROp_UInt16Type:",
            "        diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"uint16_t\");",
            "        return;",
            "    case kIROp_Int64Type:"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-wgsl.cpp",
          "line": 528,
          "statement": "diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"uint16_t\");",
          "context_before": [
            "        }",
            "    case kIROp_Int16Type:",
            "        diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"int16_t\");",
            "        return;",
            "    case kIROp_UInt16Type:"
          ],
          "context_after": [
            "        return;",
            "    case kIROp_Int64Type:",
            "    case kIROp_IntPtrType:",
            "        m_writer->emit(\"i64\");",
            "        return;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-wgsl.cpp",
          "line": 989,
          "statement": "diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"int16_t\");",
          "context_before": [
            "                        SLANG_UNEXPECTED(\"8 bit integer value emitted\");",
            "                        break;",
            "                    }",
            "                case BaseType::Int16:",
            "                    {"
          ],
          "context_after": [
            "                        break;",
            "                    }",
            "                case BaseType::UInt16:",
            "                    {",
            "                        diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"uint16_t\");"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-wgsl.cpp",
          "line": 994,
          "statement": "diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"uint16_t\");",
          "context_before": [
            "                        diagnoseOnce(SourceLoc(), Diagnostics::int16NotSupportedInWGSL, \"int16_t\");",
            "                        break;",
            "                    }",
            "                case BaseType::UInt16:",
            "                    {"
          ],
          "context_after": [
            "                        break;",
            "                    }",
            "                case BaseType::Int:",
            "                    {",
            "                        m_writer->emit(\"i32(\");"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 56104,
      "severity": "Error",
      "name": "assignToRefNotSupported",
      "message": "whole struct must be assiged to mesh output at once for Metal target.",
      "line": 3110,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-metal-legalize.cpp",
          "line": 228,
          "statement": "sink->diagnose(getDiagnosticPos(inst), Diagnostics::assignToRefNotSupported);",
          "context_before": [
            "    case kIROp_Geq:",
            "    case kIROp_Leq:",
            "        legalizeBinaryOp(inst, sink, targetProgram);",
            "        break;",
            "    case kIROp_MeshOutputRef:"
          ],
          "context_after": [
            "        break;",
            "    case kIROp_MetalCastToDepthTexture:",
            "        {",
            "            // If the operand is already a depth texture, don't do anything.",
            "            auto textureType = as<IRTextureTypeBase>(inst->getOperand(0)->getDataType());"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 57001,
      "severity": "Warning",
      "name": "spirvOptFailed",
      "message": "spirv-opt failed. $0",
      "line": 3116,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 2634,
          "statement": "codeGenContext->getSink()->diagnose(SourceLoc(), Diagnostics::spirvOptFailed, optErr);",
          "context_before": [
            "",
            "#if 0",
            "    String optErr;",
            "    if (SLANG_FAILED(optimizeSPIRV(spirv, optErr, outSpirv)))",
            "    {"
          ],
          "context_after": [
            "        spirv = _Move(outSpirv);",
            "    }",
            "#endif",
            "",
            "    artifact->addRepresentationUnknown(ListBlob::moveCreate(spirv));"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 57002,
      "severity": "Error",
      "name": "unknownPatchConstantParameter",
      "message": "unknown patch constant parameter '$0'.",
      "line": 3117,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1231,
          "statement": "Diagnostics::unknownPatchConstantParameter, param);",
          "context_before": [
            "        {",
            "            if (!outputPatchArg)",
            "            {",
            "                context->getSink()->diagnose(",
            "                    param->sourceLoc,"
          ],
          "context_after": [
            "                    param);",
            "                return;",
            "            }",
            "            param->setFullType(outputPatchArg->getDataType());",
            "            args.add(outputPatchArg);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1244,
          "statement": "Diagnostics::unknownPatchConstantParameter, param);",
          "context_before": [
            "        {",
            "            if (!inputPatchArg)",
            "            {",
            "                context->getSink()->diagnose(",
            "                    param->sourceLoc,"
          ],
          "context_after": [
            "                    param);",
            "                return;",
            "            }",
            "            auto arrayType = builder.getArrayType(",
            "                inputPatchType->getElementType(),"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1261,
          "statement": "Diagnostics::unknownPatchConstantParameter, param);",
          "context_before": [
            "            auto layout = findVarLayout(param);",
            "            if (!layout)",
            "            {",
            "                context->getSink()->diagnose(",
            "                    param->sourceLoc,"
          ],
          "context_after": [
            "                    param);",
            "                return;",
            "            }",
            "            auto sysAttr = layout->findSystemValueSemanticAttr();",
            "            if (!sysAttr)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1270,
          "statement": "Diagnostics::unknownPatchConstantParameter, param);",
          "context_before": [
            "            auto sysAttr = layout->findSystemValueSemanticAttr();",
            "            if (!sysAttr)",
            "            {",
            "                context->getSink()->diagnose(",
            "                    param->sourceLoc,"
          ],
          "context_after": [
            "                    param);",
            "                return;",
            "            }",
            "            if (sysAttr->getName().caseInsensitiveEquals(toSlice(\"SV_OutputControlPointID\")))",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-glsl-legalize.cpp",
          "line": 1288,
          "statement": "Diagnostics::unknownPatchConstantParameter, param);",
          "context_before": [
            "            }",
            "            else",
            "            {",
            "                context->getSink()->diagnose(",
            "                    param->sourceLoc,"
          ],
          "context_after": [
            "                    param);",
            "                return;",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 57003,
      "severity": "Error",
      "name": "unknownTessPartitioning",
      "message": "unknown tessellation partitioning '$0'.",
      "line": 3118,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 5637,
          "statement": "Diagnostics::unknownTessPartitioning, arg);",
          "context_before": [
            "                            else if (arg.caseInsensitiveEquals(toSlice(\"fractional_odd\")))",
            "                                mode = SpvExecutionModeSpacingFractionalOdd;",
            "                            else",
            "                                m_sink->diagnose(",
            "                                    partitioningDecor,"
          ],
          "context_after": [
            "                                    arg);",
            "                        }",
            "                        requireSPIRVExecutionMode(nullptr, getIRInstSpvID(entryPoint), mode);",
            "                    }",
            "                    break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 57004,
      "severity": "Error",
      "name": "outputSpvIsEmpty",
      "message": "output SPIR-V contains no exported symbols. Please make sure to specify at least one entrypoint.",
      "line": 3119,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 10435,
          "statement": "sink->diagnose(irModule->getModuleInst(), Diagnostics::outputSpvIsEmpty);",
          "context_before": [
            "        symbolsEmitted = true;",
            "    }",
            "",
            "    if (!symbolsEmitted)",
            "    {"
          ],
          "context_after": [
            "        return SLANG_FAIL;",
            "    }",
            "",
            "    // Move forward delcared pointers to the end.",
            "    do"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 58001,
      "severity": "Error",
      "name": "entryPointMustReturnVoidWhenGlobalOutputPresent",
      "message": "entry point must return 'void' when global output variables are present.",
      "line": 3127,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-translate-global-varying-var.cpp",
          "line": 281,
          "statement": "Diagnostics::entryPointMustReturnVoidWhenGlobalOutputPresent);",
          "context_before": [
            "                if (as<IRFuncType>(entryPoint->getDataType())->getResultType()->getOp() !=",
            "                    kIROp_VoidType)",
            "                {",
            "                    context->getSink()->diagnose(",
            "                        entryPointFunc,"
          ],
          "context_after": [
            "                    continue;",
            "                }",
            "                builder.setInsertBefore(entryPointFunc);",
            "                resultType = builder.createStructType();",
            "                IRStructTypeLayout::Builder typeLayoutBuilder(&builder);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 58002,
      "severity": "Error",
      "name": "unhandledGLSLSSBOType",
      "message": "Unhandled GLSL Shader Storage Buffer Object contents, unsized arrays as a final parameter must be the only parameter",
      "line": 3132,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-glsl-ssbo-types.cpp",
          "line": 230,
          "statement": "sink->diagnose(ssbo, Diagnostics::unhandledGLSLSSBOType);",
          "context_before": [
            "        module,",
            "        [&](IRInst* inst)",
            "        {",
            "            if (const auto ssbo = as<IRGLSLShaderStorageBufferType>(inst))",
            "            {"
          ],
          "context_after": [
            "            }",
            "        });",
            "}",
            "",
            "void lowerGLSLShaderStorageBufferObjectsToStructuredBuffers(IRModule* module, DiagnosticSink* sink)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 58003,
      "severity": "Error",
      "name": "inconsistentPointerAddressSpace",
      "message": "'$0': use of pointer with inconsistent address space.",
      "line": 3139,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-spirv-legalize.cpp",
          "line": 751,
          "statement": "Diagnostics::inconsistentPointerAddressSpace, inst);",
          "context_before": [
            "                        if (addressSpace == AddressSpace::Generic)",
            "                            addressSpace = argPtrType->getAddressSpace();",
            "                        else if (addressSpace != argPtrType->getAddressSpace())",
            "                            m_sharedContext->m_sink->diagnose(",
            "                                inst,"
          ],
          "context_after": [
            "                                inst);",
            "                    }",
            "                }",
            "            }",
            "            if (addressSpace != AddressSpace::Generic)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 90001,
      "severity": "Warning",
      "name": "ignoredDocumentationOnOverloadCandidate",
      "message": "documentation comment on overload candidate '$0' is ignored",
      "line": 3160,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-doc-markdown-writer.cpp",
          "line": 1524,
          "statement": "Diagnostics::ignoredDocumentationOnOverloadCandidate, decl);",
          "context_before": [
            "            if (!descriptionSB.toString().startsWith(markup))",
            "            {",
            "                auto decl = as<Decl>(entry->m_node);",
            "                m_sink->diagnose(",
            "                    decl->loc,"
          ],
          "context_after": [
            "                    decl);",
            "            }",
            "        }",
            "        else",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 81110,
      "severity": "Error",
      "name": "nvapiMacroMismatch",
      "message": "conflicting definitions for NVAPI macro '$0': '$1' and '$2'",
      "line": 3172,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-compile-request.h",
          "line": 354,
          "statement": "Diagnostics::nvapiMacroMismatch, macroName, existingValue, newValue);",
          "context_before": [
            "    {",
            "        if (existingValue != newValue)",
            "        {",
            "            m_sink->diagnose(",
            "                loc,"
          ],
          "context_after": [
            "                macroName,",
            "                existingValue,",
            "                newValue);",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 81111,
      "severity": "Error",
      "name": "opaqueReferenceMustResolveToGlobal",
      "message": "could not determine register/space for a resource or sampler used with NVAPI",
      "line": 3178,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-binding-query.cpp",
          "line": 201,
          "statement": "sink->diagnose(inst, Diagnostics::opaqueReferenceMustResolveToGlobal);",
          "context_before": [
            "            // If we cannot find or compute a replacement value,",
            "            // then we need to treat it as an error, since the",
            "            // binding query intrinsics don't admit any reasonable",
            "            // runtime implementation.",
            "            //"
          ],
          "context_after": [
            "            return;",
            "        }",
            "",
            "        inst->replaceUsesWith(replacementValue);",
            "        inst->removeAndDeallocate();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "unimplemented",
      "message": "unimplemented feature in Slang compiler: $0\\nFor assistance, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord (https://khr.io/slangdiscord)",
      "line": 3186,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-marshal-native-call.cpp",
          "line": 173,
          "statement": "Diagnostics::unimplemented, \"marshal string to native return value\");",
          "context_before": [
            "        break;",
            "    case kIROp_StringType:",
            "        {",
            "            diagnosticSink->diagnose(",
            "                originalArg,"
          ],
          "context_after": [
            "                \"marshal string to native return value\");",
            "        }",
            "        break;",
            "    case kIROp_ClassType:",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-marshal-native-call.cpp",
          "line": 181,
          "statement": "Diagnostics::unimplemented, \"marshal class to native return value\");",
          "context_before": [
            "        break;",
            "    case kIROp_ClassType:",
            "        {",
            "            diagnosticSink->diagnose(",
            "                originalArg,"
          ],
          "context_after": [
            "                \"marshal class to native return value\");",
            "        }",
            "        break;",
            "    case kIROp_InterfaceType:",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-type.cpp",
          "line": 338,
          "statement": "Diagnostics::unimplemented, \"can't fill in default for generic type parameter\");",
          "context_before": [
            "                {",
            "                    if (diagSink)",
            "                    {",
            "                        diagSink->diagnose(",
            "                            typeExp.exp,"
          ],
          "context_after": [
            "                            \"can't fill in default for generic type parameter\");",
            "                        *outProperType = m_astBuilder->getErrorType();",
            "                    }",
            "                    return false;",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3311,
          "statement": "Diagnostics::unimplemented, \"no applicable generic\");",
          "context_before": [
            "",
            "            // TODO(tfoley): print a reasonable message here...",
            "",
            "            getSink()->diagnose(",
            "                genericAppExpr,"
          ],
          "context_after": [
            "                \"no applicable generic\");",
            "",
            "            return CreateErrorExpr(genericAppExpr);",
            "        }",
            "        else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 5319,
          "statement": "Diagnostics::unimplemented, \"didn't expect multiple declarations here\");",
          "context_before": [
            "        }",
            "    }",
            "",
            "    parser->sink->diagnose(",
            "        declBase->loc,"
          ],
          "context_after": [
            "        \"didn't expect multiple declarations here\");",
            "    return nullptr;",
            "}",
            "",
            "static bool parseGLSLGlobalDecl(Parser* parser, ContainerDecl* containerDecl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parser.cpp",
          "line": 9091,
          "statement": "parser->sink->diagnose(outToken, Diagnostics::unimplemented, \"unknown intrinsic op\");",
          "context_before": [
            "        ;",
            "        auto op = findIROp(outToken.getContent());",
            "",
            "        if (op == kIROp_Invalid)",
            "        {"
          ],
          "context_after": [
            "        }",
            "        return op;",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-llvm.cpp",
          "line": 2409,
          "statement": "Diagnostics::unimplemented, \"unexpected string hash for non-literal string\");",
          "context_before": [
            "                    // slang-rt or in core module. Ideally, if built-in hashing",
            "                    // support in the core module becomes a thing, that can be",
            "                    // used for this too.",
            "                    getSink()->diagnose(",
            "                        inst,"
          ],
          "context_after": [
            "                        \"unexpected string hash for non-literal string\");",
            "                }",
            "            }",
            "            break;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 1047,
          "statement": "Diagnostics::unimplemented, \"this target doesn't support this system-defined varying parameter\");",
          "context_before": [
            "    {",
            "        SLANG_UNUSED(info);",
            "",
            "        m_sink->diagnose(",
            "            m_param,"
          ],
          "context_after": [
            "            \"this target doesn't support this system-defined varying parameter\");",
            "",
            "        return LegalizedVaryingVal();",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 1059,
          "statement": "Diagnostics::unimplemented, \"this target doesn't support this user-defined varying parameter\");",
          "context_before": [
            "    {",
            "        SLANG_UNUSED(info);",
            "",
            "        m_sink->diagnose(",
            "            m_param,"
          ],
          "context_after": [
            "            \"this target doesn't support this user-defined varying parameter\");",
            "",
            "        return LegalizedVaryingVal();",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 10232,
          "statement": "Diagnostics::unimplemented, \"lower unknown AggType to IR\");",
          "context_before": [
            "        }",
            "        else",
            "        {",
            "            getSink()->diagnose(",
            "                decl->loc,"
          ],
          "context_after": [
            "                \"lower unknown AggType to IR\");",
            "            return LoweredValInfo::simple(subBuilder->getVoidType());",
            "        }",
            "",
            "        maybeAddDebugLocationDecoration(context, irAggType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-c-like.cpp",
          "line": 2339,
          "statement": "getSink()->diagnose(inst, Diagnostics::unimplemented, \"unexpected IR opcode during code emit\");",
          "context_before": [
            "    defaultEmitInstStmt(inst);",
            "}",
            "",
            "void CLikeSourceEmitter::diagnoseUnhandledInst(IRInst* inst)",
            "{"
          ],
          "context_after": [
            "}",
            "",
            "bool CLikeSourceEmitter::hasExplicitConstantBufferOffset(IRInst* cbufferType)",
            "{",
            "    auto type = as<IRUniformParameterGroupType>(cbufferType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-c-like.cpp",
          "line": 2796,
          "statement": "Diagnostics::unimplemented, \"kIROp_ImageSubscript is unimplemented for Metal, expected legalization \" \"beforehand\");",
          "context_before": [
            "    case kIROp_ImageSubscript:",
            "        // We should have legalized ImageSubscript before emit for metal targets",
            "        if (isMetalTarget(this->getTargetReq()))",
            "            getSink()->diagnose(",
            "                inst,"
          ],
          "context_after": [
            "                \"kIROp_ImageSubscript is unimplemented for Metal, expected legalization \"",
            "                \"beforehand\");",
            "        [[fallthrough]];",
            "    case kIROp_GetElement:",
            "    case kIROp_MeshOutputRef:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-transcriber-base.cpp",
          "line": 1230,
          "statement": "Diagnostics::unimplemented, \"this instruction cannot be differentiated\");",
          "context_before": [
            "    if (result.primal == nullptr && result.differential == nullptr)",
            "    {",
            "        // If we reach this statement, the instruction type is likely unhandled.",
            "        getSink()->diagnose(",
            "            origInst->sourceLoc,"
          ],
          "context_after": [
            "            \"this instruction cannot be differentiated\");",
            "    }",
            "",
            "    return result;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-fwd.cpp",
          "line": 322,
          "statement": "Diagnostics::unimplemented, \"this arithmetic instruction cannot be differentiated\");",
          "context_before": [
            "                }",
            "            }",
            "        default:",
            "            getSink()->diagnose(",
            "                origArith->sourceLoc,"
          ],
          "context_after": [
            "                \"this arithmetic instruction cannot be differentiated\");",
            "        }",
            "    }",
            "",
            "    return InstPair(primalArith, nullptr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-fwd.cpp",
          "line": 1088,
          "statement": "Diagnostics::unimplemented, \"attempting to differentiate unhandled control flow\");",
          "context_before": [
            "        return InstPair(diffBranch, diffBranch);",
            "    }",
            "",
            "    getSink()->diagnose(",
            "        origInst->sourceLoc,"
          ],
          "context_after": [
            "        \"attempting to differentiate unhandled control flow\");",
            "",
            "    return InstPair(nullptr, nullptr);",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-fwd.cpp",
          "line": 1107,
          "statement": "Diagnostics::unimplemented, \"attempting to differentiate unhandled const type\");",
          "context_before": [
            "        return InstPair(origInst, origInst);",
            "    }",
            "",
            "    getSink()->diagnose(",
            "        origInst->sourceLoc,"
          ],
          "context_after": [
            "        \"attempting to differentiate unhandled const type\");",
            "",
            "    return InstPair(nullptr, nullptr);",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.h",
          "line": 43,
          "statement": "Slang::Diagnostics::unimplemented,          \\ what)  #else #define SLANG_INTERNAL_ERROR(sink, pos) \\ (sink)->diagnose(pos, Slang::Diagnostics::internalCompilerError) #define SLANG_UNIMPLEMENTED(sink, pos, what) \\ (sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)  #endif  #define SLANG_DIAGNOSE_UNEXPECTED(sink, pos, message) \\",
          "context_before": [
            "        Slang::SourceLoc(__LINE__, 0, 0, __FILE__), \\",
            "        Slang::Diagnostics::internalCompilerError)",
            "#define SLANG_UNIMPLEMENTED(sink, pos, what)        \\",
            "    (sink)->diagnose(                               \\",
            "        Slang::SourceLoc(__LINE__, 0, 0, __FILE__), \\"
          ],
          "context_after": [
            "        what)",
            "",
            "#else",
            "#define SLANG_INTERNAL_ERROR(sink, pos) \\",
            "    (sink)->diagnose(pos, Slang::Diagnostics::internalCompilerError)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.h",
          "line": 50,
          "statement": "(sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)  #endif  #define SLANG_DIAGNOSE_UNEXPECTED(sink, pos, message) \\ (sink)->diagnose(pos, Slang::Diagnostics::unexpected, message)  #endif ",
          "context_before": [
            "",
            "#else",
            "#define SLANG_INTERNAL_ERROR(sink, pos) \\",
            "    (sink)->diagnose(pos, Slang::Diagnostics::internalCompilerError)",
            "#define SLANG_UNIMPLEMENTED(sink, pos, what) \\"
          ],
          "context_after": [
            "",
            "#endif",
            "",
            "#define SLANG_DIAGNOSE_UNEXPECTED(sink, pos, message) \\",
            "    (sink)->diagnose(pos, Slang::Diagnostics::unexpected, message)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "unexpected",
      "message": "unexpected condition encountered in Slang compiler: $0\\nFor assistance, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord (https://khr.io/slangdiscord)",
      "line": 3193,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-varying-params.cpp",
          "line": 2111,
          "statement": "Diagnostics::unexpected, \"the supplied hit attribute exceeds the maximum hit attribute structure \" \"size (32 bytes)\");",
          "context_before": [
            "                    /*the builder in use*/ &builder);",
            "                if (ioBaseAttributeIndex > 8)",
            "                {",
            "                    m_sink->diagnose(",
            "                        m_param,"
          ],
          "context_after": [
            "                        \"the supplied hit attribute exceeds the maximum hit attribute structure \"",
            "                        \"size (32 bytes)\");",
            "                    return LegalizedVaryingVal();",
            "                }",
            "                return LegalizedVaryingVal::makeValue(getHitAttributes);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6281,
          "statement": "Diagnostics::unexpected, \"unknown type modifier in semantic checking\");",
          "context_before": [
            "    else",
            "    {",
            "        // TODO: more complete error message here",
            "        getSink()->diagnose(",
            "            modifier,"
          ],
          "context_after": [
            "            \"unknown type modifier in semantic checking\");",
            "        return nullptr;",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.h",
          "line": 55,
          "statement": "(sink)->diagnose(pos, Slang::Diagnostics::unexpected, message)  #endif ",
          "context_before": [
            "    (sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)",
            "",
            "#endif",
            "",
            "#define SLANG_DIAGNOSE_UNEXPECTED(sink, pos, message) \\"
          ],
          "context_after": [
            "",
            "#endif",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "internalCompilerError",
      "message": "Slang internal compiler error\\nFor assistance, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord (https://khr.io/slangdiscord)",
      "line": 3201,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-shader.cpp",
          "line": 2235,
          "statement": "Diagnostics::internalCompilerError, \"couldn't parse specialization argument\");",
          "context_before": [
            "",
            "        if (!argExpr)",
            "        {",
            "            sink->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                \"couldn't parse specialization argument\");",
            "            return;",
            "        }",
            "",
            "        outGenericArgs.add(argExpr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-transcriber-base.cpp",
          "line": 41,
          "statement": "Diagnostics::internalCompilerError, \"inconsistent primal instruction for original\");",
          "context_before": [
            "    if (cloneEnv.mapOldValToNew.containsKey(origInst) &&",
            "        cloneEnv.mapOldValToNew[origInst] != primalInst)",
            "    {",
            "        getSink()->diagnose(",
            "            origInst->sourceLoc,"
          ],
          "context_after": [
            "            \"inconsistent primal instruction for original\");",
            "    }",
            "    else",
            "    {",
            "        cloneEnv.mapOldValToNew[origInst] = primalInst;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-transcriber-base.cpp",
          "line": 819,
          "statement": "Diagnostics::internalCompilerError, \"could not generate zero value for given type\");",
          "context_before": [
            "            return builder->getIntValue(primalType, 0);",
            "        }",
            "",
            "        getSink()->diagnose(",
            "            primalType->sourceLoc,"
          ],
          "context_after": [
            "            \"could not generate zero value for given type\");",
            "        return nullptr;",
            "    }",
            "}",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-transcriber-base.cpp",
          "line": 1168,
          "statement": "Diagnostics::internalCompilerError, \"failed to transcibe instruction\");",
          "context_before": [
            "        }",
            "        return pair.differential;",
            "    }",
            "    getSink()->diagnose(",
            "        origInst->sourceLoc,"
          ],
          "context_after": [
            "        \"failed to transcibe instruction\");",
            "    return nullptr;",
            "}",
            "",
            "InstPair AutoDiffTranscriberBase::transcribeInst(IRBuilder* builder, IRInst* origInst)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-autodiff-fwd.cpp",
          "line": 696,
          "statement": "Diagnostics::internalCompilerError, \"attempting to differentiate unresolved callee\");",
          "context_before": [
            "        // differentiate such calls safely.",
            "        // TODO(sai): Should probably get checked in the front-end.",
            "        //",
            "        getSink()->diagnose(",
            "            origCall->sourceLoc,"
          ],
          "context_after": [
            "            \"attempting to differentiate unresolved callee\");",
            "",
            "        return InstPair(nullptr, nullptr);",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 8163,
          "statement": "m_sink->diagnose(inst, Diagnostics::internalCompilerError);",
          "context_before": [
            "",
            "        // We'd better give some diagnostics to at least point out which line in the shader is",
            "        // wrong, so it can help the user or developers to locate the issue easier.",
            "        if (!isFloatOrPackedFloatType(fromType))",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        if (!isFloatOrPackedFloatType(toType))",
            "        {",
            "            m_sink->diagnose(inst, Diagnostics::internalCompilerError);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 8168,
          "statement": "m_sink->diagnose(inst, Diagnostics::internalCompilerError);",
          "context_before": [
            "            m_sink->diagnose(inst, Diagnostics::internalCompilerError);",
            "        }",
            "",
            "        if (!isFloatOrPackedFloatType(toType))",
            "        {"
          ],
          "context_after": [
            "        }",
            "",
            "        if (isTypeEqual(fromType, toType))",
            "        {",
            "            auto inner = ensureInst(inst->getOperand(0));"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.h",
          "line": 39,
          "statement": "Slang::Diagnostics::internalCompilerError) #define SLANG_UNIMPLEMENTED(sink, pos, what)        \\ (sink)->diagnose(                               \\ Slang::SourceLoc(__LINE__, 0, 0, __FILE__), \\ Slang::Diagnostics::unimplemented,          \\ what)  #else #define SLANG_INTERNAL_ERROR(sink, pos) \\ (sink)->diagnose(pos, Slang::Diagnostics::internalCompilerError) #define SLANG_UNIMPLEMENTED(sink, pos, what) \\ (sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)",
          "context_before": [
            "",
            "#ifdef _DEBUG",
            "#define SLANG_INTERNAL_ERROR(sink, pos)             \\",
            "    (sink)->diagnose(                               \\",
            "        Slang::SourceLoc(__LINE__, 0, 0, __FILE__), \\"
          ],
          "context_after": [
            "#define SLANG_UNIMPLEMENTED(sink, pos, what)        \\",
            "    (sink)->diagnose(                               \\",
            "        Slang::SourceLoc(__LINE__, 0, 0, __FILE__), \\",
            "        Slang::Diagnostics::unimplemented,          \\",
            "        what)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-diagnostics.h",
          "line": 48,
          "statement": "(sink)->diagnose(pos, Slang::Diagnostics::internalCompilerError) #define SLANG_UNIMPLEMENTED(sink, pos, what) \\ (sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)  #endif  #define SLANG_DIAGNOSE_UNEXPECTED(sink, pos, message) \\ (sink)->diagnose(pos, Slang::Diagnostics::unexpected, message)  #endif ",
          "context_before": [
            "        Slang::Diagnostics::unimplemented,          \\",
            "        what)",
            "",
            "#else",
            "#define SLANG_INTERNAL_ERROR(sink, pos) \\"
          ],
          "context_after": [
            "#define SLANG_UNIMPLEMENTED(sink, pos, what) \\",
            "    (sink)->diagnose(pos, Slang::Diagnostics::unimplemented, what)",
            "",
            "#endif",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "unimplemented"
          ]
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Error",
      "name": "compilationAborted",
      "message": "Slang compilation aborted due to internal error\\nFor assistance, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord (https://khr.io/slangdiscord)",
      "line": 3208,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1509,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::compilationAborted);",
          "context_before": [
            "    {",
            "        // The compiler failed due to some exception that wasn't a sublass of",
            "        // `Exception`, so something really fishy is going on. We want to",
            "        // let the user know that we messed up, so they know to blame Slang",
            "        // and not some other component in their system."
          ],
          "context_after": [
            "    }",
            "    m_diagnosticOutput = getSink()->outputBuffer.produceString();",
            "",
            "#else",
            "    // When debugging, we probably don't want to filter out any errors, since"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Error",
      "name": "compilationAbortedDueToException",
      "message": "Slang compilation aborted due to an exception of $0: $1\\nFor assistance, file an issue on GitHub (https://github.com/shader-slang/slang/issues) or join the Slang Discord (https://khr.io/slangdiscord)",
      "line": 3215,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1486,
          "statement": "Diagnostics::compilationAbortedDueToException, typeid(e).name(), e.Message);",
          "context_before": [
            "        {",
            "            // If for some reason we didn't output any diagnostic, something is",
            "            // going wrong, but we want to make sure we at least output something.",
            "            getSink()->diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                typeid(e).name(),",
            "                e.Message);",
            "        }",
            "    }",
            "    catch (const Exception& e)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1499,
          "statement": "Diagnostics::compilationAbortedDueToException, typeid(e).name(), e.Message);",
          "context_before": [
            "        // We will print out information on the exception to help out the user",
            "        // in either filing a bug, or locating what in their code created",
            "        // a problem.",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            typeid(e).name(),",
            "            e.Message);",
            "    }",
            "    catch (...)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-linkable.cpp",
          "line": 750,
          "statement": "Diagnostics::compilationAbortedDueToException, typeid(e).name(), e.Message);",
          "context_before": [
            "            DiagnosticSink sink(linkage->getSourceManager(), Lexer::sourceLocationLexer);",
            "            applySettingsToDiagnosticSink(&sink, &sink, linkage->m_optionSet);",
            "            applySettingsToDiagnosticSink(&sink, &sink, m_optionSet);",
            "            sink.diagnose(",
            "                SourceLoc(),"
          ],
          "context_after": [
            "                typeid(e).name(),",
            "                e.Message);",
            "            sink.getBlobIfNeeded(outDiagnostics);",
            "        }",
            "        return nullptr;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-target-program.cpp",
          "line": 118,
          "statement": "Diagnostics::compilationAbortedDueToException, typeid(e).name(), e.Message);",
          "context_before": [
            "    }",
            "    catch (const Exception& e)",
            "    {",
            "        sink->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            typeid(e).name(),",
            "            e.Message);",
            "        return nullptr;",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "serialDebugVerificationFailed",
      "message": "Verification of serial debug information failed.",
      "line": 3223,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-compile-request.cpp",
          "line": 483,
          "statement": "Diagnostics::serialDebugVerificationFailed);",
          "context_before": [
            "            if (SLANG_FAILED(",
            "                    SerialContainerUtil::verifyIRSerialize(irModule, getSession(), options)))",
            "            {",
            "                getSink()->diagnose(",
            "                    irModule->getModuleInst()->sourceLoc,"
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        // Set the module on the translation unit",
            "        translationUnit->getModule()->setIRModule(irModule);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "spirvValidationFailed",
      "message": "Validation of generated SPIR-V failed.",
      "line": 3228,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 2720,
          "statement": "Diagnostics::spirvValidationFailed);",
          "context_before": [
            "                    compiler->validate((uint32_t*)spirv.getBuffer(), int(spirv.getCount() / 4))))",
            "            {",
            "                compiler->disassemble((uint32_t*)spirv.getBuffer(), int(spirv.getCount() / 4));",
            "                codeGenContext->getSink()->diagnoseWithoutSourceView(",
            "                    SourceLoc{},"
          ],
          "context_after": [
            "            }",
            "        }",
            "",
            "        ComPtr<IArtifact> optimizedArtifact;",
            "        DownstreamCompileOptions downstreamOptions;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 99999,
      "severity": "Internal",
      "name": "noBlocksOrIntrinsic",
      "message": "no blocks found for function definition, is there a '$0' intrinsic missing?",
      "line": 3230,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-spirv.cpp",
          "line": 3709,
          "statement": "m_sink->diagnose(irFunc, Diagnostics::noBlocksOrIntrinsic, \"spirv\");",
          "context_before": [
            "",
            "    /// Emit a SPIR-V function definition for the Slang IR function `irFunc`.",
            "    SpvInst* emitFuncDefinition(IRFunc* irFunc)",
            "    {",
            "        if (!irFunc->getFirstBlock())"
          ],
          "context_after": [
            "",
            "        // [2.4: Logical Layout of a Module]",
            "        //",
            "        // > All function definitions (functions with a body).",
            "        //"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40100,
      "severity": "Warning",
      "name": "mainEntryPointRenamed",
      "message": "entry point '$0' is not allowed, and has been renamed to '$1'",
      "line": 3236,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-c-like.cpp",
          "line": 1130,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::mainEntryPointRenamed, name, newName);",
          "context_before": [
            "        isMetalTarget(getTargetReq()))",
            "    {",
            "        if (name == \"main\")",
            "        {",
            "            String newName = _generateUniqueName(name.getUnownedSlice());"
          ],
          "context_after": [
            "            return newName;",
            "        }",
            "    }",
            "    return name;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40000,
      "severity": "Error",
      "name": "rayPayloadFieldMissingAccessQualifiers",
      "message": "field '$0' in ray payload struct must have either 'read' OR 'write' access qualifiers",
      "line": 3246,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2294,
          "statement": "Diagnostics::rayPayloadFieldMissingAccessQualifiers, fieldVarDecl->getName());",
          "context_before": [
            "        if (!hasReadModifier && !hasWriteModifier)",
            "        {",
            "            // Emit the diagnostic error",
            "            getSink()->diagnose(",
            "                fieldVarDecl,"
          ],
          "context_after": [
            "                fieldVarDecl->getName());",
            "        }",
            "",
            "        // Check stage names in read qualifier",
            "        if (readModifier)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 40001,
      "severity": "Error",
      "name": "rayPayloadInvalidStageInAccessQualifier",
      "message": "invalid stage name '$0' in ray payload access qualifier; valid stages are 'anyhit', 'closesthit', 'miss', and 'caller'",
      "line": 3251,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2308,
          "statement": "Diagnostics::rayPayloadInvalidStageInAccessQualifier, stageName);",
          "context_before": [
            "                String stageName = stageToken.getContent();",
            "                if (!validStages.contains(stageName))",
            "                {",
            "                    getSink()->diagnose(",
            "                        stageToken,"
          ],
          "context_after": [
            "                        stageName);",
            "                }",
            "            }",
            "        }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-modifier.cpp",
          "line": 2324,
          "statement": "Diagnostics::rayPayloadInvalidStageInAccessQualifier, stageName);",
          "context_before": [
            "                String stageName = stageToken.getContent();",
            "                if (!validStages.contains(stageName))",
            "                {",
            "                    getSink()->diagnose(",
            "                        stageToken,"
          ],
          "context_after": [
            "                        stageName);",
            "                }",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50000,
      "severity": "Error",
      "name": "cooperativeMatrixUnsupportedElementType",
      "message": "Element type '$0' is not supported for matrix'$1'.",
      "line": 3261,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-cuda.cpp",
          "line": 1282,
          "statement": "Diagnostics::cooperativeMatrixUnsupportedElementType, typeName, matrixUse == 0 ? \"A\" : (matrixUse == 1 ? \"B\" : \"C\"));",
          "context_before": [
            "    if (!typeCheck(elementType->getOp(), matrixUse))",
            "    {",
            "        StringBuilder msg;",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            typeName,",
            "            matrixUse == 0 ? \"A\" : (matrixUse == 1 ? \"B\" : \"C\"));",
            "        SLANG_RELEASE_ASSERT(false);",
            "        return SLANG_FAIL;",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 50000,
      "severity": "Error",
      "name": "cooperativeMatrixInvalidShape",
      "message": "Invalid shape ['$0', '$1'] for cooperative matrix'$2'.",
      "line": 3267,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-emit-cuda.cpp",
          "line": 1296,
          "statement": "Diagnostics::cooperativeMatrixInvalidShape, rowCount, colCount, matrixUse == 0 ? \"A\" : (matrixUse == 1 ? \"B\" : \"C\"));",
          "context_before": [
            "    FragmentShape shape = computeShapeCombination(matrixUse, rowCount, colCount);",
            "    if (!shape.isValid())",
            "    {",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            rowCount,",
            "            colCount,",
            "            matrixUse == 0 ? \"A\" : (matrixUse == 1 ? \"B\" : \"C\"));",
            "        SLANG_RELEASE_ASSERT(false);",
            "        return SLANG_FAIL;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    },
    {
      "id": 51701,
      "severity": "Fatal",
      "name": "cooperativeMatrixUnsupportedCapture",
      "message": "'CoopMat.MapElement' per-element function cannot capture buffers, resources or any opaque type values. Consider pre-loading the content of any referenced buffers into a local variable before calling 'CoopMat.MapElement', or moving any referenced resources to global scope.",
      "line": 3273,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-legalize-types.cpp",
          "line": 2268,
          "statement": "Diagnostics::cooperativeMatrixUnsupportedCapture);",
          "context_before": [
            "                // If functor legalizes to one or many special (resource) values, we",
            "                // can't handle this case very easily at the moment, so diagnose an error",
            "                // instead of crashing.",
            "                context->m_sink->diagnose(",
            "                    inst->getIFuncCall(),"
          ],
          "context_after": [
            "                return LegalVal();",
            "            }",
            "        }",
            "    }",
            "    return LegalVal::simple(inst);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ]
    }
  ],
  "notes": [
    {
      "id": -1,
      "severity": "Note",
      "name": "alsoSeePipelineDefinition",
      "message": "also see pipeline definition",
      "line": 25,
      "param_count": 0,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "implicitParameterMatchingFailedBecauseNameNotAccessible",
      "message": "implicit parameter matching failed because the component of the same name is not accessible from '$0'.\\ncheck if you have declared necessary requirements and properly used the 'public' qualifier.",
      "line": 26,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "implicitParameterMatchingFailedBecauseShaderDoesNotDefineComponent",
      "message": "implicit parameter matching failed because shader '$0' does not define component '$1'.",
      "line": 33,
      "param_count": 2,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "implicitParameterMatchingFailedBecauseTypeMismatch",
      "message": "implicit parameter matching failed because the component of the same name does not match parameter type '$0'.",
      "line": 38,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "noteShaderIsTargetingPipeine",
      "message": "shader '$0' is targeting pipeline '$1'",
      "line": 44,
      "param_count": 2,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDefinitionOf",
      "message": "see definition of '$0'",
      "line": 45,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 233,
          "statement": "getSink()->diagnose(decl, Diagnostics::seeDefinitionOf, decl->getName());",
          "context_before": [
            "            return true;",
            "",
            "        if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "        {",
            "            getSink()->diagnose(context.loc, Diagnostics::expectedPrefixOperator);"
          ],
          "context_after": [
            "        }",
            "",
            "        return false;",
            "    }",
            "    else if (const auto postfixExpr = as<PostfixExpr>(expr))"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 246,
          "statement": "getSink()->diagnose(decl, Diagnostics::seeDefinitionOf, decl->getName());",
          "context_before": [
            "            return true;",
            "",
            "        if (context.mode != OverloadResolveContext::Mode::JustTrying)",
            "        {",
            "            getSink()->diagnose(context.loc, Diagnostics::expectedPostfixOperator);"
          ],
          "context_after": [
            "        }",
            "",
            "        return false;",
            "    }",
            "    else"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3777,
          "statement": "getSink()->diagnose(sourceLoc, Diagnostics::seeDefinitionOf, differentialType);",
          "context_before": [
            "            getSink()->diagnose(",
            "                inheritanceDecl,",
            "                Diagnostics::differentialTypeShouldServeAsItsOwnDifferentialType,",
            "                differentialType,",
            "                diffDiffType);"
          ],
          "context_after": [
            "        }",
            "",
            "        // Check that all [DerivativeMember(...)] attributes have their references checked.",
            "        for (auto member : inheritanceDecl->parentDecl->getMembersOfType<VarDeclBase>())",
            "        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14005,
          "statement": "Diagnostics::seeDefinitionOf, funcDecl);",
          "context_before": [
            "    maybeDiagnose(",
            "        visitor->getSink(),",
            "        visitor->getOptionSet(),",
            "        diagnosticCategory,",
            "        funcDecl,"
          ],
          "context_after": [
            "        funcDecl);",
            "}",
            "",
            "static void _propagateRequirement(",
            "    SemanticsVisitor* visitor,"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15024,
          "statement": "Diagnostics::seeDefinitionOf, referencedDecl);",
          "context_before": [
            "        maybeDiagnose(",
            "            sink,",
            "            optionSet,",
            "            DiagnosticCategory::Capability,",
            "            referencedDecl->loc,"
          ],
          "context_after": [
            "            referencedDecl);",
            "        // If we find a 'require' modifier, this is contributing to the overall capability",
            "        // incompatibility. We should hint to the user that this declaration is problematic.",
            "        if (auto requireCapabilityAttribute =",
            "                referencedDecl->findModifier<RequireCapabilityAttribute>())"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15106,
          "statement": "Diagnostics::seeDefinitionOf, declToPrint);",
          "context_before": [
            "        maybeDiagnose(",
            "            sink,",
            "            optionSet,",
            "            DiagnosticCategory::Capability,",
            "            declToPrint->loc,"
          ],
          "context_after": [
            "            declToPrint);",
            "    }",
            "}",
            "",
            "void SemanticsDeclCapabilityVisitor::diagnoseUndeclaredCapability("
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "differentialTypeShouldServeAsItsOwnDifferentialType",
        "expectedPostfixOperator",
        "expectedPrefixOperator"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDefinitionOfStruct",
      "message": "see definition of struct '$0'",
      "line": 46,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-detect-uninitialized-resources.cpp",
          "line": 187,
          "statement": "Diagnostics::seeDefinitionOfStruct, structName);",
          "context_before": [
            "                            // Note pointing to struct definition",
            "                            if (structType->sourceLoc.isValid())",
            "                            {",
            "                                sink->diagnose(",
            "                                    structType->sourceLoc,"
          ],
          "context_after": [
            "                                    structName);",
            "                            }",
            "                        }",
            "                        else",
            "                        {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeConstantBufferDefinition",
      "message": "see constant buffer definition.",
      "line": 47,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2990,
          "statement": "getSink()->diagnose(varDecl->loc, Diagnostics::seeConstantBufferDefinition);",
          "context_before": [
            "            {",
            "                getSink()->diagnose(",
            "                    trailingArrayField->loc,",
            "                    Diagnostics::cannotUseUnsizedTypeInConstantBuffer,",
            "                    trailingArrayType);"
          ],
          "context_after": [
            "            }",
            "        }",
            "    }",
            "    maybeRegisterDifferentiableType(getASTBuilder(), varDecl->getType());",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "cannotUseUnsizedTypeInConstantBuffer"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeInterfaceDefinitionOf",
      "message": "see interface definition of '$0'",
      "line": 48,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeUsingOf",
      "message": "see using of '$0'",
      "line": 49,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15016,
          "statement": "Diagnostics::seeUsingOf, referencedDecl);",
          "context_before": [
            "        maybeDiagnose(",
            "            sink,",
            "            optionSet,",
            "            DiagnosticCategory::Capability,",
            "            provNode.referenceLoc,"
          ],
          "context_after": [
            "            referencedDecl);",
            "        // Diagnose the definition as the problem",
            "        maybeDiagnose(",
            "            sink,",
            "            optionSet,"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15045,
          "statement": "Diagnostics::seeUsingOf, provNode.referencedNode->astNodeType);",
          "context_before": [
            "        maybeDiagnose(",
            "            sink,",
            "            optionSet,",
            "            DiagnosticCategory::Capability,",
            "            provNode.referenceLoc,"
          ],
          "context_after": [
            "            provNode.referencedNode->astNodeType);",
            "    }",
            "}",
            "",
            "void diagnoseCapabilityProvenance("
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15073,
          "statement": "Diagnostics::seeUsingOf, provenance.referencedNode->astNodeType);",
          "context_before": [
            "                maybeDiagnose(",
            "                    sink,",
            "                    optionSet,",
            "                    DiagnosticCategory::Capability,",
            "                    provenance.referenceLoc,"
          ],
          "context_after": [
            "                    provenance.referencedNode->astNodeType);",
            "                break;",
            "            }",
            "",
            "            if (!CapabilitySet{referencedDecl->inferredCapabilityRequirements}.implies(atomToFind))"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15085,
          "statement": "Diagnostics::seeUsingOf, referencedDecl);",
          "context_before": [
            "            maybeDiagnose(",
            "                sink,",
            "                optionSet,",
            "                DiagnosticCategory::Capability,",
            "                provenance.referenceLoc,"
          ],
          "context_after": [
            "                referencedDecl);",
            "            declToPrint = referencedDecl;",
            "            if (printedDecls.contains(declToPrint))",
            "                break;",
            "            if (declToPrint->findModifier<RequireCapabilityAttribute>())"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDefinitionOfShader",
      "message": "see definition of shader '$0'",
      "line": 50,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeInclusionOf",
      "message": "see inclusion of '$0'",
      "line": 51,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeModuleBeingUsedIn",
      "message": "see module '$0' being used in '$1'",
      "line": 52,
      "param_count": 2,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeCallOfFunc",
      "message": "see call to '$0'",
      "line": 53,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 475,
          "statement": "sink->diagnose(call, Diagnostics::seeCallOfFunc, func);",
          "context_before": [
            "        for (auto use = func->firstUse; use; use = use->nextUse)",
            "        {",
            "            auto user = use->getUser();",
            "            if (auto call = as<IRCall>(user))",
            "            {"
          ],
          "context_after": [
            "                inst = call;",
            "                shouldContinue = true;",
            "                break;",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seePipelineRequirementDefinition",
      "message": "see pipeline requirement definition",
      "line": 54,
      "param_count": 0,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seePotentialDefinitionOfComponent",
      "message": "see potential definition of component '$0'",
      "line": 55,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seePreviousDefinition",
      "message": "see previous definition",
      "line": 60,
      "param_count": 0,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seePreviousDefinitionOf",
      "message": "see previous definition of '$0'",
      "line": 61,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9458,
          "statement": "Diagnostics::seePreviousDefinitionOf, prevDecl->getName());",
          "context_before": [
            "                    }",
            "",
            "                    auto prevDecl = *found;",
            "                    getSink()->diagnose(",
            "                        prevDecl,"
          ],
          "context_after": [
            "                        prevDecl->getName());",
            "                }",
            "",
            "                hasConflict = true;",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3810,
          "statement": "sink->diagnose(oldMacro->getLoc(), Diagnostics::seePreviousDefinitionOf, name);",
          "context_before": [
            "            sink->diagnose(nameToken.loc, Diagnostics::builtinMacroRedefinition, name);",
            "        }",
            "        else",
            "        {",
            "            sink->diagnose(nameToken.loc, Diagnostics::macroRedefinition, name);"
          ],
          "context_after": [
            "        }",
            "",
            "        delete oldMacro;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "macroRedefinition"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeRequirementDeclaration",
      "message": "see requirement declaration",
      "line": 62,
      "param_count": 0,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "doYouForgetToMakeComponentAccessible",
      "message": "do you forget to make component '$0' acessible from '$1' (missing public qualifier)?",
      "line": 63,
      "param_count": 2,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDeclarationOf",
      "message": "see declaration of '$0'",
      "line": 69,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1924,
          "statement": "Diagnostics::seeDeclarationOf, candidate.item.declRef);",
          "context_before": [
            "                sink->diagnose(fromExpr, Diagnostics::ambiguousConversion, fromType, toType);",
            "                for (auto candidate : overloadContext.bestCandidates)",
            "                {",
            "                    sink->diagnose(",
            "                        candidate.item.declRef,"
          ],
          "context_after": [
            "                        candidate.item.declRef);",
            "                }",
            "            }",
            "",
            "            *outToExpr = CreateErrorExpr(fromExpr);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1575,
          "statement": "Diagnostics::seeDeclarationOf, ss->irGlobalValue);",
          "context_before": [
            "            // Emit notes for all available declarations of this symbol",
            "            for (IRSpecSymbol* ss = sym; ss; ss = ss->nextWithSameName)",
            "            {",
            "                sink->diagnose(",
            "                    ss->irGlobalValue->sourceLoc,"
          ],
          "context_after": [
            "                    ss->irGlobalValue);",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-ir-link.cpp",
          "line": 1874,
          "statement": "Diagnostics::seeDeclarationOf, concreteType);",
          "context_before": [
            "                            Diagnostics::unresolvedSymbol,",
            "                            witnessSym);",
            "                        if (auto concreteType = witnessSym->getConcreteType())",
            "                            sink->diagnose(",
            "                                concreteType->sourceLoc,"
          ],
          "context_after": [
            "                                concreteType);",
            "                    }",
            "                }",
            "                break;",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-parameter-binding.cpp",
          "line": 961,
          "statement": "Diagnostics::seeDeclarationOf, getReflectionName(paramB));",
          "context_before": [
            "                    getReflectionName(paramA),",
            "                    getReflectionName(paramB));",
            "                if (written)",
            "                    getSink(context)->diagnose(",
            "                        paramB,"
          ],
          "context_after": [
            "                        getReflectionName(paramB));",
            "            }",
            "        }",
            "    }",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7214,
          "statement": "Diagnostics::seeDeclarationOf, requiredMemberDeclRef);",
          "context_before": [
            "                Diagnostics::typeDoesntImplementInterfaceRequirement,",
            "                subType,",
            "                requiredMemberDeclRef);",
            "            getSink()->diagnose(",
            "                requiredMemberDeclRef,"
          ],
          "context_after": [
            "                requiredMemberDeclRef);",
            "            return false;",
            "        }",
            "    }",
            "    if (lookupResult.isOverloaded())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 13284,
          "statement": "Diagnostics::seeDeclarationOf, calleeDeclRef.getDecl());",
          "context_before": [
            "            Diagnostics::declAlreadyHasAttribute,",
            "            calleeDeclRef,",
            "            getDerivativeAttrName<TDerivativeAttr>());",
            "        visitor->getSink()->diagnose(",
            "            existingModifier->loc,"
          ],
          "context_after": [
            "            calleeDeclRef.getDecl());",
            "    }",
            "",
            "    derivativeOfAttr->funcExpr = calleeDeclRefExpr;",
            "    auto derivativeAttr = astBuilder->create<TDerivativeAttr>();"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14638,
          "statement": "Diagnostics::seeDeclarationOf, requirementDecl);",
          "context_before": [
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    requirementDecl,"
          ],
          "context_after": [
            "                    requirementDecl);",
            "            }",
            "            else if (",
            "                checkCapabilityResult ==",
            "                CheckCapabilityRequirementResult::RequiredIsMissingAbstractAtoms)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14658,
          "statement": "Diagnostics::seeDeclarationOf, requirementDecl);",
          "context_before": [
            "                maybeDiagnose(",
            "                    getSink(),",
            "                    getOptionSet(),",
            "                    DiagnosticCategory::Capability,",
            "                    requirementDecl,"
          ],
          "context_after": [
            "                    requirementDecl);",
            "            }",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14687,
          "statement": "Diagnostics::seeDeclarationOf, inheritanceDecl->base);",
          "context_before": [
            "        maybeDiagnose(",
            "            getSink(),",
            "            getOptionSet(),",
            "            DiagnosticCategory::Capability,",
            "            inheritanceDecl->base,"
          ],
          "context_after": [
            "            inheritanceDecl->base);",
            "    }",
            "    else if (",
            "        checkCapabilityResult == CheckCapabilityRequirementResult::RequiredIsMissingAbstractAtoms)",
            "    {"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 14706,
          "statement": "Diagnostics::seeDeclarationOf, inheritanceDecl->base);",
          "context_before": [
            "        maybeDiagnose(",
            "            getSink(),",
            "            getOptionSet(),",
            "            DiagnosticCategory::Capability,",
            "            inheritanceDecl->base,"
          ],
          "context_after": [
            "            inheritanceDecl->base);",
            "    }",
            "}",
            "",
            "DeclVisibility getDeclVisibility(Decl* decl)"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 15035,
          "statement": "Diagnostics::seeDeclarationOf, requireCapabilityAttribute);",
          "context_before": [
            "            maybeDiagnose(",
            "                sink,",
            "                optionSet,",
            "                DiagnosticCategory::Capability,",
            "                requireCapabilityAttribute->loc,"
          ],
          "context_after": [
            "                requireCapabilityAttribute);",
            "    }",
            "    else",
            "    {",
            "        maybeDiagnose("
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDeclarationOfInterfaceRequirement",
      "message": "see interface requirement declaration of '$0'",
      "line": 70,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7353,
          "statement": "Diagnostics::seeDeclarationOfInterfaceRequirement, requiredMemberDeclRef);",
          "context_before": [
            "                getSink()->diagnose(item.declRef, Diagnostics::seeOverloadConsidered, item.declRef);",
            "        }",
            "    }",
            "    getSink()->diagnose(",
            "        requiredMemberDeclRef,"
          ],
          "context_after": [
            "        requiredMemberDeclRef);",
            "    return false;",
            "}",
            "",
            "RefPtr<WitnessTable> SemanticsVisitor::checkInterfaceConformance("
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeOverloadConsidered",
      "message": "see overloads considered: '$0'.",
      "line": 76,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 7348,
          "statement": "getSink()->diagnose(item.declRef, Diagnostics::seeOverloadConsidered, item.declRef);",
          "context_before": [
            "                Diagnostics::typeDoesntImplementInterfaceRequirement,",
            "                subType,",
            "                requiredMemberDeclRef);",
            "",
            "            for (auto& item : lookupResult)"
          ],
          "context_after": [
            "        }",
            "    }",
            "    getSink()->diagnose(",
            "        requiredMemberDeclRef,",
            "        Diagnostics::seeDeclarationOfInterfaceRequirement,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "declaredHere",
      "message": "declared here",
      "line": 80,
      "param_count": 0,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeOtherDeclarationOf",
      "message": "see other declaration of '$0'",
      "line": 81,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seePreviousDeclarationOf",
      "message": "see previous declaration of '$0'",
      "line": 82,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9379,
          "statement": "getSink()->diagnose(oldDecl, Diagnostics::seePreviousDeclarationOf, newDecl->getName());",
          "context_before": [
            "            newDecl,",
            "            Diagnostics::functionRedeclarationWithDifferentReturnType,",
            "            newDecl->getName(),",
            "            resultType,",
            "            prevResultType);"
          ],
          "context_after": [
            "",
            "        // Don't bother emitting other errors at this point",
            "        return SLANG_FAIL;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 9542,
          "statement": "getSink()->diagnose(oldDecl, Diagnostics::seePreviousDeclarationOf, oldDecl->getName());",
          "context_before": [
            "",
            "    // We will diagnose a redeclaration error at the new declaration,",
            "    // and point to the old declaration for context.",
            "    //",
            "    getSink()->diagnose(newDecl, Diagnostics::redeclaration, newDecl->getName());"
          ],
          "context_after": [
            "    return SLANG_FAIL;",
            "}",
            "",
            "",
            "void SemanticsVisitor::checkForRedeclaration(Decl* decl)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "redeclaration"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "includeOutput",
      "message": "include $0",
      "line": 83,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-compile-request.cpp",
          "line": 158,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::includeOutput, buf);",
          "context_before": [
            "    // You might want to know where this include was from.",
            "    // If I output this though there will be a problem... as the indenting won't be clearly shown.",
            "    // Perhaps I output in two sections, one the hierarchy and the other the locations of the",
            "    // includes?",
            ""
          ],
          "context_after": [
            "}",
            "",
            "static void _outputIncludesRec(",
            "    SourceView* sourceView,",
            "    Index depth,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "genericSignatureTried",
      "message": "see declaration of $0",
      "line": 84,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 1162,
          "statement": "getSink()->diagnose(candidate.item.declRef, Diagnostics::genericSignatureTried, declString);",
          "context_before": [
            "    {",
            "        String callString = getCallSignatureString(context);",
            "        getSink()->diagnose(context.loc, Diagnostics::genericArgumentInferenceFailed, callString);",
            "",
            "        String declString = ASTPrinter::getDeclSignatureString(candidate.item, m_astBuilder);"
          ],
          "context_after": [
            "        goto error;",
            "    }",
            "",
            "    context.mode = OverloadResolveContext::Mode::ForReal;",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "genericArgumentInferenceFailed"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "entryPointCandidate",
      "message": "see candidate declaration for entry point '$0'",
      "line": 85,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 102,
      "severity": "Note",
      "name": "downstreamCompileTime",
      "message": "downstream compile time: $0s",
      "line": 322,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1528,
          "statement": "getSink()->diagnose(SourceLoc(), Diagnostics::downstreamCompileTime, downstreamTimeStr);",
          "context_before": [
            "        double downstreamEndTime = 0;",
            "        double totalEndTime = 0;",
            "        getSession()->getCompilerElapsedTime(&totalEndTime, &downstreamEndTime);",
            "        double downstreamTime = downstreamEndTime - downstreamStartTime;",
            "        String downstreamTimeStr = String(downstreamTime, \"%.2f\");"
          ],
          "context_after": [
            "    }",
            "    if (getOptionSet().getBoolOption(CompilerOptionName::ReportPerfBenchmark))",
            "    {",
            "        StringBuilder perfResult;",
            "        PerformanceProfiler::getProfiler()->getResult(perfResult);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 103,
      "severity": "Note",
      "name": "performanceBenchmarkResult",
      "message": "compiler performance benchmark:\\n$0",
      "line": 323,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-end-to-end-request.cpp",
          "line": 1537,
          "statement": "Diagnostics::performanceBenchmarkResult, perfResult.produceString());",
          "context_before": [
            "        StringBuilder perfResult;",
            "        PerformanceProfiler::getProfiler()->getResult(perfResult);",
            "        perfResult << \"\\nType Dictionary Size: \" << getSession()->m_typeDictionarySize << \"\\n\";",
            "        getSink()->diagnose(",
            "            SourceLoc(),"
          ],
          "context_after": [
            "            perfResult.produceString());",
            "    }",
            "",
            "    // Repro dump handling",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 99999,
      "severity": "Note",
      "name": "noteFailedToLoadDynamicLibrary",
      "message": "failed to load dynamic library '$0'",
      "line": 324,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check.cpp",
          "line": 36,
          "statement": "m_sink->diagnose(SourceLoc(), Diagnostics::noteFailedToLoadDynamicLibrary, path);",
          "context_before": [
            "            {",
            "                m_sink->diagnose(SourceLoc(), Diagnostics::dxilNotFound);",
            "            }",
            "            else",
            "            {"
          ],
          "context_after": [
            "            }",
            "        }",
            "        return res;",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeDirective",
      "message": "see '$0' directive",
      "line": 339,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3347,
          "statement": "GetSink(context)->diagnose(conditional->elseToken.loc, Diagnostics::seeDirective);",
          "context_before": [
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),",
            "            Diagnostics::directiveAfterElse,",
            "            GetDirectiveName(context));"
          ],
          "context_after": [
            "        return;",
            "    }",
            "    conditional->elseToken = context->m_directiveToken;",
            "",
            "    switch (conditional->state)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3411,
          "statement": "GetSink(context)->diagnose(conditional->elseToken.loc, Diagnostics::seeDirective);",
          "context_before": [
            "    {",
            "        GetSink(context)->diagnose(",
            "            GetDirectiveLoc(context),",
            "            Diagnostics::directiveAfterElse,",
            "            GetDirectiveName(context));"
          ],
          "context_after": [
            "        return;",
            "    }",
            "",
            "    switch (conditional->state)",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 4663,
          "statement": "Diagnostics::seeDirective, conditional->ifToken.getContent());",
          "context_before": [
            "         conditional = conditional->parent)",
            "    {",
            "        GetSink(this)->diagnose(eofToken, Diagnostics::endOfFileInPreprocessorConditional);",
            "        GetSink(this)->diagnose(",
            "            conditional->ifToken,"
          ],
          "context_after": [
            "            conditional->ifToken.getContent());",
            "    }",
            "",
            "    {",
            "        SourceView* sourceView = inputFile->getLexer()->m_sourceView;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "directiveAfterElse",
        "endOfFileInPreprocessorConditional"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "seeOpeningToken",
      "message": "see opening '$0'",
      "line": 388,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2939,
          "statement": "GetSink(context)->diagnose(leftParen.loc, Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "            if (!Expect(",
            "                    context,",
            "                    TokenType::RParent,",
            "                    Diagnostics::expectedTokenInPreprocessorExpression))",
            "            {"
          ],
          "context_after": [
            "            }",
            "            return value;",
            "        }",
            "",
            "    case TokenType::IntegerLiteral:"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 2982,
          "statement": "Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "                            TokenType::RParent,",
            "                            Diagnostics::expectedTokenInDefinedExpression))",
            "                    {",
            "                        GetSink(context)->diagnose(",
            "                            leftParen.loc,"
          ],
          "context_after": [
            "                            leftParen);",
            "                        return 0;",
            "                    }",
            "                }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 3022,
          "statement": "Diagnostics::seeOpeningToken, leftParen);",
          "context_before": [
            "                            TokenType::RParent,",
            "                            Diagnostics::expectedTokenInDefinedExpression))",
            "                    {",
            "                        GetSink(context)->diagnose(",
            "                            leftParen.loc,"
          ],
          "context_after": [
            "                            leftParen);",
            "                        return 0;",
            "                    }",
            "                }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "expectedTokenInPreprocessorExpression"
      ]
    },
    {
      "id": 15616,
      "severity": "Note",
      "name": "pragmaWarningPointSuppress",
      "message": "#pragma warning for id '$0' was suppressed here",
      "line": 478,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-preprocessor.cpp",
          "line": 1161,
          "statement": "Diagnostics::pragmaWarningPointSuppress, id);",
          "context_before": [
            "                const Entry* prevEntry = findEntry(location);",
            "                if (prevEntry && prevEntry->specifier == PragmaWarningSpecifier::Suppress)",
            "                {",
            "                    sink->diagnose(",
            "                        SourceLoc::fromRaw(prevEntry->debugLocation),"
          ],
          "context_after": [
            "                        id);",
            "                }",
            "            }",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 29102,
      "severity": "Note",
      "name": "considerOpCopyObject",
      "message": "consider adding an OpCopyObject instruction to the end of the spirv_asm expression",
      "line": 572,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 6458,
          "statement": "Diagnostics::considerOpCopyObject);",
          "context_before": [
            "                    if (!isLast)",
            "                    {",
            "                        getSink()->diagnose(operand.token, Diagnostics::misplacedResultIdMarker);",
            "                        getSink()->diagnoseWithoutSourceView(",
            "                            expr,"
          ],
          "context_after": [
            "                    }",
            "                }",
            "                else if (operand.flavor == SPIRVAsmOperand::NamedValue)",
            "                {",
            "                    // First try and look it up with the knowledge of this operand's type"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "misplacedResultIdMarker"
      ]
    },
    {
      "id": 29103,
      "severity": "Note",
      "name": "noSuchAddress",
      "message": "unable to take the address of this address-of asm operand",
      "line": 577,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-lower-to-ir.cpp",
          "line": 4934,
          "statement": "context->getSink()->diagnose(operand.expr, Diagnostics::noSuchAddress);",
          "context_before": [
            "                            TryGetAddressMode::Default);",
            "                        if (addr.flavor == LoweredValInfo::Flavor::Ptr)",
            "                            i = addr.val;",
            "                        else",
            "                        {"
          ],
          "context_after": [
            "                            return nullptr;",
            "                        }",
            "                    }",
            "                    return builder->emitSPIRVAsmOperandInst(i);",
            "                }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 30049,
      "severity": "Note",
      "name": "attemptingToAssignToConstVariable",
      "message": "attempting to assign to a const variable or immutable member; use '[mutating]' attribute on the containing method to allow modification",
      "line": 739,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 2809,
          "statement": "getSink()->diagnoseWithoutSourceView(expr, Diagnostics::attemptingToAssignToConstVariable);",
          "context_before": [
            "    }",
            "",
            "    // Check if we're trying to assign to a non-l-value (const variable, immutable member, etc.)",
            "    if (!expr->type.isLeftValue)",
            "    {"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "Expr* SemanticsVisitor::checkAssignWithCheckedOperands(AssignExpr* expr)",
            "{"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 30062,
      "severity": "Note",
      "name": "implicitCastUsedAsLValueRef",
      "message": "argument was implicitly cast from '$0' to '$1', and Slang does not support using an implicit cast as an l-value with a reference",
      "line": 782,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3126,
          "statement": "diagnostic = &Diagnostics::implicitCastUsedAsLValueRef;",
          "context_before": [
            "                                    // Try and determine reason for failure",
            "                                    if (as<RefParamType>(paramType))",
            "                                    {",
            "                                        // Ref types are not allowed to use this mechanism",
            "                                        // because it breaks atomics"
          ],
          "context_after": [
            "                                    }",
            "                                    else if (!_canLValueCoerce(",
            "                                                 implicitCastExpr->arguments[0]->type,",
            "                                                 implicitCastExpr->type))",
            "                                    {"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 30063,
      "severity": "Note",
      "name": "implicitCastUsedAsLValueType",
      "message": "argument was implicitly cast from '$0' to '$1', and Slang does not support using an implicit cast as an l-value with this type",
      "line": 788,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3135,
          "statement": "diagnostic = &Diagnostics::implicitCastUsedAsLValueType;",
          "context_before": [
            "                                                 implicitCastExpr->type))",
            "                                    {",
            "                                        // We restict what types can use this mechanism -",
            "                                        // currently int/uint and same sized matrix/vectors of",
            "                                        // those types."
          ],
          "context_after": [
            "                                    }",
            "                                    else",
            "                                    {",
            "                                        // Fall back, in case there are other reasons...",
            "                                        diagnostic = &Diagnostics::implicitCastUsedAsLValue;"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 30064,
      "severity": "Note",
      "name": "implicitCastUsedAsLValue",
      "message": "argument was implicitly cast from '$0' to '$1', and Slang does not support using an implicit cast as an l-value for this usage",
      "line": 794,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 3140,
          "statement": "diagnostic = &Diagnostics::implicitCastUsedAsLValue;",
          "context_before": [
            "                                        diagnostic = &Diagnostics::implicitCastUsedAsLValueType;",
            "                                    }",
            "                                    else",
            "                                    {",
            "                                        // Fall back, in case there are other reasons..."
          ],
          "context_after": [
            "                                    }",
            "                                    getSink()->diagnoseWithoutSourceView(",
            "                                        argExpr,",
            "                                        *diagnostic,",
            "                                        implicitCastExpr->arguments[0]->type,"
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "doYouMeanStaticConst",
      "message": "do you intend to define a `static const` instead?",
      "line": 848,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2968,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::doYouMeanStaticConst);",
          "context_before": [
            "            varDecl->hasModifier<HLSLStaticModifier>())",
            "        {",
            "            // Opaque type global variable must be const.",
            "            getSink()->diagnose(varDecl, Diagnostics::globalVarCannotHaveOpaqueType);",
            "            if (varDecl->initExpr)"
          ],
          "context_after": [
            "            else",
            "                getSink()->diagnose(varDecl, Diagnostics::doYouMeanUniform);",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "doYouMeanUniform"
          ]
        }
      ],
      "referenced_by": [
        "globalVarCannotHaveOpaqueType"
      ]
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "doYouMeanUniform",
      "message": "do you intend to define a `uniform` parameter instead?",
      "line": 849,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 2970,
          "statement": "getSink()->diagnose(varDecl, Diagnostics::doYouMeanUniform);",
          "context_before": [
            "            // Opaque type global variable must be const.",
            "            getSink()->diagnose(varDecl, Diagnostics::globalVarCannotHaveOpaqueType);",
            "            if (varDecl->initExpr)",
            "                getSink()->diagnose(varDecl, Diagnostics::doYouMeanStaticConst);",
            "            else"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    if (auto elementType = getConstantBufferElementType(varDecl->getType()))",
            "    {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "noteExplicitConversionPossible",
      "message": "explicit conversion from '$0' to '$1' is possible",
      "line": 970,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-check-conversion.cpp",
          "line": 1986,
          "statement": "Diagnostics::noteExplicitConversionPossible, fromType, toType);",
          "context_before": [
            "                if (sink)",
            "                {",
            "                    sink->diagnose(fromExpr, Diagnostics::typeMismatch, toType, fromType);",
            "                    sink->diagnoseWithoutSourceView(",
            "                        fromExpr,"
          ],
          "context_after": [
            "                        fromType,",
            "                        toType);",
            "                }",
            "            }",
            "            else if (cost >= kConversionCost_Default)"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "typeMismatch"
      ]
    },
    {
      "id": 30402,
      "severity": "Note",
      "name": "invalidEqualityConstraintSubType",
      "message": "type '$0' cannot be constrained by a type equality",
      "line": 1753,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-decl.cpp",
          "line": 3313,
          "statement": "sink->diagnose(type.exp, Diagnostics::invalidEqualityConstraintSubType, type);",
          "context_before": [
            "    {",
            "        if (sink)",
            "        {",
            "            if (decl->isEqualityConstraint)",
            "            {"
          ],
          "context_after": [
            "            }",
            "            else",
            "            {",
            "                sink->diagnose(type.exp, Diagnostics::invalidConstraintSubType, type);",
            "            }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 39999,
      "severity": "Note",
      "name": "overloadCandidate",
      "message": "candidate: $0",
      "line": 2030,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 205,
          "statement": "getSink()->diagnose(candidate.item.declRef, Diagnostics::overloadCandidate, declString);",
          "context_before": [
            "",
            "        // Add a note showing the candidate signature for context",
            "        if (candidate.item.declRef.getDecl())",
            "        {",
            "            String declString = ASTPrinter::getDeclSignatureString(candidate.item, m_astBuilder);"
          ],
          "context_after": [
            "        }",
            "        else if (candidate.funcType)",
            "        {",
            "            // For Flavor::Expr cases where there's no decl, show the function type",
            "            getSink()->diagnose(context.loc, Diagnostics::overloadCandidate, candidate.funcType);"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 210,
          "statement": "getSink()->diagnose(context.loc, Diagnostics::overloadCandidate, candidate.funcType);",
          "context_before": [
            "            getSink()->diagnose(candidate.item.declRef, Diagnostics::overloadCandidate, declString);",
            "        }",
            "        else if (candidate.funcType)",
            "        {",
            "            // For Flavor::Expr cases where there's no decl, show the function type"
          ],
          "context_after": [
            "        }",
            "    }",
            "",
            "    return false;",
            "}"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3053,
          "statement": "Diagnostics::overloadCandidate, declString);",
          "context_before": [
            "                                Diagnostics::invisibleOverloadCandidate,",
            "                                declString);",
            "                        else",
            "                            getSink()->diagnose(",
            "                                candidate.item.declRef,"
          ],
          "context_after": [
            "                                declString);",
            "",
            "                        candidateIndex++;",
            "                        if (candidateIndex == maxCandidatesToPrint)",
            "                            break;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-expr.cpp",
          "line": 1284,
          "statement": "getSink()->diagnose(item.declRef, Diagnostics::overloadCandidate, declString);",
          "context_before": [
            "        lookupResult.items[0].declRef.getName());",
            "",
            "    for (auto item : lookupResult.items)",
            "    {",
            "        String declString = ASTPrinter::getDeclSignatureString(item, m_astBuilder);"
          ],
          "context_after": [
            "    }",
            "}",
            "",
            "void SemanticsVisitor::diagnoseAmbiguousReference(Expr* expr)",
            "{"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 39999,
      "severity": "Note",
      "name": "invisibleOverloadCandidate",
      "message": "candidate (invisible): $0",
      "line": 2031,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3048,
          "statement": "Diagnostics::invisibleOverloadCandidate, declString);",
          "context_before": [
            "                            ASTPrinter::getDeclSignatureString(candidate.item, m_astBuilder);",
            "",
            "                        if (candidate.status == OverloadCandidate::Status::VisibilityChecked)",
            "                            getSink()->diagnose(",
            "                                candidate.item.declRef,"
          ],
          "context_after": [
            "                                declString);",
            "                        else",
            "                            getSink()->diagnose(",
            "                                candidate.item.declRef,",
            "                                Diagnostics::overloadCandidate,"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 39999,
      "severity": "Note",
      "name": "moreOverloadCandidates",
      "message": "$0 more overload candidates",
      "line": 2033,
      "param_count": 1,
      "call_sites": [
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3012,
          "statement": "Diagnostics::moreOverloadCandidates, candidateCount - candidateIndex);",
          "context_before": [
            "                // Emit additional note for remaining candidates if needed",
            "                if (candidateIndex != candidateCount)",
            "                {",
            "                    getSink()->diagnose(",
            "                        expr,"
          ],
          "context_after": [
            "                        candidateCount - candidateIndex);",
            "                }",
            "            }",
            "            else",
            "            {"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        },
        {
          "file": "source/slang/slang-check-overload.cpp",
          "line": 3064,
          "statement": "Diagnostics::moreOverloadCandidates, candidateCount - candidateIndex);",
          "context_before": [
            "                    }",
            "                    if (candidateIndex != candidateCount)",
            "                    {",
            "                        getSink()->diagnose(",
            "                            expr,"
          ],
          "context_after": [
            "                            candidateCount - candidateIndex);",
            "                    }",
            "                }",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "noteWhenCompilingEntryPoint",
      "message": "when compiling entry point '$0'",
      "line": 2259,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 39003,
      "severity": "Note",
      "name": "shaderParameterTypeMismatch",
      "message": "type is declared as '$0' in one translation unit, and '$0' in another",
      "line": 2387,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 39004,
      "severity": "Note",
      "name": "fieldTypeMisMatch",
      "message": "type of field '$0' is declared as '$1' in one translation unit, and '$2' in another",
      "line": 2392,
      "param_count": 3,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 39005,
      "severity": "Note",
      "name": "fieldDeclarationsDontMatch",
      "message": "type '$0' is declared with different fields in each translation unit",
      "line": 2397,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 39006,
      "severity": "Note",
      "name": "usedInDeclarationOf",
      "message": "used in declaration of '$0'",
      "line": 2402,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": 40010,
      "severity": "Note",
      "name": "seeInterfaceUsage",
      "message": "see usage of interface '$0'.",
      "line": 2574,
      "param_count": 1,
      "call_sites": [],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "typeAndLimit",
      "message": "sizeof($0) is $1, limit is $2",
      "line": 2696,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-any-value-inference.cpp",
          "line": 242,
          "statement": "Diagnostics::typeAndLimit, implType, sizeAndAlignment.size, existingMaxSize);",
          "context_before": [
            "            if (existingMaxSize < sizeAndAlignment.size)",
            "            {",
            "                sink->diagnose(implType, Diagnostics::typeDoesNotFitAnyValueSize, implType);",
            "                sink->diagnoseWithoutSourceView(",
            "                    implType,"
          ],
          "context_after": [
            "                    implType,",
            "                    sizeAndAlignment.size,",
            "                    existingMaxSize);",
            "            }",
            "        }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": [
        "typeDoesNotFitAnyValueSize"
      ]
    },
    {
      "id": 50102,
      "severity": "Note",
      "name": "dynamicDispatchCodeGeneratedHere",
      "message": "generated dynamic dispatch code for this site. $0 possible types: '$1'",
      "line": 2956,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-dynamic-dispatch-insts.cpp",
          "line": 604,
          "statement": "Diagnostics::dynamicDispatchCodeGeneratedHere, count, tableElementsStr.getUnownedSlice());",
          "context_before": [
            "                    count++;",
            "                });",
            "",
            "            m_sink->diagnose(",
            "                use->getUser()->sourceLoc,"
          ],
          "context_after": [
            "                count,",
            "                tableElementsStr.getUnownedSlice());",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": 50103,
      "severity": "Note",
      "name": "specializedDynamicDispatchCodeGeneratedHere",
      "message": "generated specialized dynamic dispatch code for this site. $0 possible types: '$1'. specialization arguments: '$2'.",
      "line": 2961,
      "param_count": 3,
      "call_sites": [
        {
          "file": "source/slang/slang-ir-lower-dynamic-dispatch-insts.cpp",
          "line": 655,
          "statement": "Diagnostics::specializedDynamicDispatchCodeGeneratedHere, count, tableElementsStr.getUnownedSlice(), specArgsStr.getUnownedSlice());",
          "context_before": [
            "                printDiagnosticArg(specArgsStr, arg);",
            "            }",
            "",
            "            m_sink->diagnose(",
            "                use->getUser()->sourceLoc,"
          ],
          "context_after": [
            "                count,",
            "                tableElementsStr.getUnownedSlice(),",
            "                specArgsStr.getUnownedSlice());",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "reportCheckpointIntermediates",
      "message": "checkpointing context of $1 bytes associated with function: '$0'",
      "line": 3146,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 259,
          "statement": "Diagnostics::reportCheckpointIntermediates, func, structSize.size);",
          "context_before": [
            "            continue;",
            "",
            "        auto func = checkpointDecoration->getSourceFunction();",
            "        sink->diagnose(",
            "            structType,"
          ],
          "context_after": [
            "            func,",
            "            structSize.size);",
            "        nonEmptyStructs++;",
            "",
            "        for (auto field : structType->getFields())"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "reportCheckpointVariable",
      "message": "$0 bytes ($1) used to checkpoint the following item:",
      "line": 3151,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 279,
          "statement": ": Diagnostics::reportCheckpointVariable, fieldSize.size, typeWriter.getContent());",
          "context_before": [
            "",
            "            sink->diagnose(",
            "                field->sourceLoc,",
            "                field->findDecoration<IRLoopCounterDecoration>()",
            "                    ? Diagnostics::reportCheckpointCounter"
          ],
          "context_after": [
            "                fieldSize.size,",
            "                typeWriter.getContent());",
            "        }",
            "    }",
            ""
          ],
          "call_pattern": "unknown",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "reportCheckpointCounter",
      "message": "$0 bytes ($1) used for a loop counter here:",
      "line": 3156,
      "param_count": 2,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 278,
          "statement": "? Diagnostics::reportCheckpointCounter : Diagnostics::reportCheckpointVariable, fieldSize.size, typeWriter.getContent());",
          "context_before": [
            "            emitter.emitType(fieldType);",
            "",
            "            sink->diagnose(",
            "                field->sourceLoc,",
            "                field->findDecoration<IRLoopCounterDecoration>()"
          ],
          "context_after": [
            "                    : Diagnostics::reportCheckpointVariable,",
            "                fieldSize.size,",
            "                typeWriter.getContent());",
            "        }",
            "    }"
          ],
          "call_pattern": "diagnose",
          "uses_notes": [
            "reportCheckpointVariable"
          ]
        }
      ],
      "referenced_by": []
    },
    {
      "id": -1,
      "severity": "Note",
      "name": "reportCheckpointNone",
      "message": "no checkpoint contexts to report",
      "line": 3157,
      "param_count": 0,
      "call_sites": [
        {
          "file": "source/slang/slang-emit.cpp",
          "line": 286,
          "statement": "sink->diagnose(SourceLoc(), Diagnostics::reportCheckpointNone);",
          "context_before": [
            "                typeWriter.getContent());",
            "        }",
            "    }",
            "",
            "    if (nonEmptyStructs == 0)"
          ],
          "context_after": [
            "}",
            "",
            "struct LinkingAndOptimizationOptions",
            "{",
            "    bool shouldLegalizeExistentialAndResourceTypes = true;"
          ],
          "call_pattern": "diagnose",
          "uses_notes": []
        }
      ],
      "referenced_by": []
    }
  ],
  "stats": {
    "total_diagnostics": 709,
    "total_notes": 61,
    "total_call_sites": 891,
    "diagnostics_with_no_call_sites": 118,
    "diagnostics_with_note_chains": 14
  }
}